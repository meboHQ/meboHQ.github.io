[
  {
    "__docId__": 0,
    "kind": "file",
    "name": "src/Action.js",
    "content": "const assert = require('assert');\nconst TypeCheck = require('js-typecheck');\nconst Utils = require('./Utils');\nconst Settings = require('./Settings');\nconst Session = require('./Session');\nconst Input = require('./Input');\nconst Metadata = require('./Metadata');\n\n// symbols used for private instance variables to avoid any potential clashing\n// caused by re-implementations\nconst _inputs = Symbol('inputs');\nconst _session = Symbol('session');\nconst _metadata = Symbol('metadata');\n\nclass InvalidActionError extends Error{\n}\n\n\n/**\n * An action is used to perform an evaluation.\n *\n * By implementing an evaluation through an action, the evaluation is wrapped by an\n * interface that can be triggered from many different forms ({@link Handler}).\n *\n * ```\n  * class HelloWorld extends Mebo.Action{\n *   _perform(data){\n *     return Promise.resolve('Hello World');\n *   }\n * }\n *\n * const action = new HelloWorld();\n * action.run().then(...) //  HelloWorld\n * ```\n *\n * The data used to perform an evaluation is held by inputs ({@link Action.createInput}).\n * These inputs can be widely configured to enforce quality control via properties.\n * The available properties can be found under the documentation for each input type.\n *\n * ```\n * class HelloWorld extends Mebo.Action{\n *   constructor(){\n *     super();\n *     this.createInput('repeat: numeric', {max: 100});\n *   }\n *   _perform(data){\n *     const result = 'HelloWorld '.repeat(data.repeat);\n *     return Promise.resolve(result);\n *   }\n * }\n *\n * const action = new HelloWorld();\n * action.input('repeat').setValue(3);\n * action.run().then(...) //  HelloWorld HelloWorld HelloWorld\n * ```\n *\n * An evaluation is triggered through {@link Action.run} which internally calls\n * {@link Action._perform}. Use `perform` to implement the evaluation of your action.\n * Also, you can implement {@link Action._finalize} to execute secondary routines.\n *\n * Actions are registered via {@link Action.register}, in case you want\n * to use a compound name with a prefix common across some group of\n * actions you can use '.' as separator. Also, there are two ways to create actions:\n *\n * - {@link Action.createAction} - allows actions to be created from inside of another action.\n * By doing that it creates actions that share the same {@link Session}.\n *\n * - {@link Action.create} - factory an action with custom session when supplied\n * otherwise it creates a new session.\n *\n * Also, actions can take advantage of the caching mechanism designed to improve the performance\n * by avoiding re-evaluations in actions that might be executed multiple times. This can enabled\n * through {@link Action.isCacheable}.\n */\nclass Action{\n\n  /**\n   * creates an action\n   */\n  constructor(){\n    this[_inputs] = new Map();\n    this[_metadata] = new Metadata();\n  }\n\n  /**\n   * Creates a new input through {@link Input.create} then adds it\n   * to the action inputs {@link Action.addInput}\n   *\n   * @param {string} inputInterface - string followed by either the pattern `name: type`\n   * or `name?: type` in case of optional {@link Input}\n   * @param {...*} args - arguments passed to the input's constructor\n   * @return {Input} Returns the created input instance\n   */\n  createInput(inputInterface, ...args){\n    const inputInstance = Input.create(inputInterface, ...args);\n    this.addInput(inputInstance);\n\n    return inputInstance;\n  }\n\n  /**\n   * Adds an {@link Input} instance to the action\n   *\n   * @param {Input} inputInstance - input that should be added to the action\n   */\n  addInput(inputInstance){\n    // making sure the input is derived from Inputs\n    assert(inputInstance instanceof Input, 'Invalid Input Type!');\n\n    // making sure the new input name is not in use\n    const inputName = inputInstance.name();\n    if (this[_inputs].has(inputName)){\n      throw new Error('Input name is already in use!');\n    }\n\n    this[_inputs].set(inputName, inputInstance);\n  }\n\n  /**\n   * Returns the action input names\n   *\n   * @return {Array<string>}\n   */\n  inputNames(){\n    return [...this[_inputs].keys()];\n  }\n\n  /**\n   * Returns the input instance based on the given name\n   *\n   * @param {string} inputName - name of the input\n   * @param {*} [defaultValue] - default value that is returned in case the\n   * input does not exist\n   * @return {Input}\n   */\n  input(inputName, defaultValue=null){\n    assert(TypeCheck.isString(inputName), 'inputName needs to be defined as string!');\n\n    if (this[_inputs].has(inputName)){\n      return this[_inputs].get(inputName);\n    }\n\n    return defaultValue;\n  }\n\n  /**\n   * Runs the validations of all inputs\n   *\n   * @return {Promise}\n   */\n  validate(){\n    return Promise.all([...this[_inputs].values()].map(input => input.validate()));\n  }\n\n  /**\n  * Returns a boolean telling if the action is cacheable (`false` by default).\n  *\n  * This method should be overridden by derived classes to tell if the action\n  * is cacheable. This information is used by {@link Action.run}.\n  *\n  * The configuration about the LRU cache can be found under the {@link Session}.\n  *\n  * @return {boolean}\n  */\n  isCacheable(){\n    return false;\n  }\n\n  /**\n   * Executes the action and returns the result through a promise\n   *\n   * @param {boolean} [useCache=true] - tells if the action should try to use the LRU\n   * cache to avoid the execution. This option is only used when the action is {@link Action.isCacheable}\n   * @return {Promise<*>}\n   */\n  async run(useCache=true){\n\n    // in case the result cache does not exist yet, creating it as an arbitrary\n    // data under the session, therefore when the session is cloned by nested\n    // actions this cache will be shared across them\n    let resultCache = this.session().get('_actionResultCache');\n    if (!resultCache){\n      resultCache = new Utils.LruCache(\n        Settings.get('action/lruCacheSize'),\n        Settings.get('action/lruCacheLifespan') * 1000,\n      );\n      this.session().set('_actionResultCache', resultCache);\n    }\n\n    // pulling out result from the cache (if applicable)\n    let actionSignature = null;\n    if (useCache && this.isCacheable()){\n\n      actionSignature = await this.id();\n\n      // checking if the input hash is under the cache\n      if (resultCache.has(actionSignature)){\n        return resultCache.get(actionSignature);\n      }\n    }\n\n    // the action is performed inside of a try/catch block to call the _finalize\n    // no matter what, since that can be used to perform clean-up operations...\n    let result = null;\n    let err = null;\n    try{\n      // calling super class validations & executing action\n      result = await this._execute();\n    }\n    catch(errr){\n      err = this._processError(errr);\n      throw err;\n    }\n    // running the finalize\n    finally{\n      await this._finalize(err, result);\n    }\n\n    // adding the result to the cache\n    if (actionSignature){\n      resultCache.set(actionSignature, result);\n    }\n\n    return result;\n  }\n\n  /**\n   * Serializes the current interface of the action into json format. Serialized\n   * actions can be recreated later through {@link Action.createFromJSON}\n   * or in case of non-registered actions the baked information can be loaded\n   * directly to an instance through {@link Action.fromJSON}.\n   *\n   * @param {boolean} [autofill=true] - tells if the {@link Session.autofill} will be\n   * included in the serialization\n   * @param {boolean} [avoidHidden=true] - tells if inputs with the 'hidden' property\n   * should be ignored\n   * @return {Promise<string>} serialized json version of the action\n   */\n  async bakeToJSON(autofill=true, avoidHidden=true){\n\n    const actionInputs = await this._serializeInputs(avoidHidden);\n    const session = this.session();\n\n    // collecting autofill values\n    const autofillData = {};\n    if (autofill && session){\n      for (const key of session.autofillKeys()){\n        autofillData[key] = session.autofill(key);\n      }\n    }\n\n    const result = {\n      id: this.id(),\n      inputs: actionInputs,\n      metadata: {\n        action: this.meta('action', {}),\n      },\n      session: {\n        autofill: autofillData,\n      },\n    };\n\n    return JSON.stringify(result, null, '\\t');\n  }\n\n  /**\n   * Loads the interface of the action from json (serialized through {@link Action.bakeToJSON}).\n   *\n   * @param {string} serializedAction - serialized json information generated by {@link Action.bakeToJSON}\n   * @param {boolean} [autofill=true] - tells if the {@link Session.autofill} should\n   * be loaded\n   */\n  fromJSON(serializedAction, autofill=true){\n\n    const actionContents = JSON.parse(serializedAction);\n\n    this._loadContents(actionContents, autofill);\n  }\n\n  /**\n   * Returns an unique signature based on the action's current state. It's based\n   * on the input types, input values and meta data information about the action.\n   *\n   * For a more reliable signature make sure that the action has been created through\n   * the factory method ({@link Action.create}).\n   *\n   * @return {Promise<string>}\n   */\n  async id(){\n    let actionSignature = '';\n    const separator = ';\\n';\n\n    // header\n    const actionRegisteredName = this.meta('action.name');\n    if (actionRegisteredName){\n      actionSignature = actionRegisteredName;\n    }\n    // using the class name can be very flawed, make sure to always creating actions\n    // via their registration name\n    else{\n      actionSignature = `!${this.constructor.name}`;\n    }\n    actionSignature += separator;\n    actionSignature += this.inputNames().length;\n    actionSignature += separator;\n\n    // contents\n    const actionInputs = await this._serializeInputs(false);\n    for (const inputName in actionInputs){\n      actionSignature += `${inputName}: ${actionInputs[inputName]}${separator}`;\n    }\n\n    return Utils.hash(Buffer.from(actionSignature));\n  }\n\n  /**\n   * Allows the creation of an action based on the current action. By doing this it passes\n   * the current {@link Action.session} to the static create method ({@link Action.create}).\n   * Therefore creating an action that shares the same session.\n   *\n   * @param {string} actionName - registered action name (case-insensitive)\n   * @return {Action}\n   */\n  createAction(actionName){\n    const action = Action.create(actionName, this.session());\n\n    // overriding the metadata information about the origin of the action, by telling\n    // it has been created from inside of another action\n    action.setMeta('action.origin', 'nested');\n\n    return action;\n  }\n\n  /**\n   * Creates an action based on the registered action name, in case the action does\n   * not exist `null` is returned instead\n   *\n   * @param {string} actionName - registered action name (case-insensitive)\n   * @param {Session} [session] - optional custom session object\n   * @return {Action}\n   */\n  static create(actionName, session=null){\n    assert(TypeCheck.isString(actionName), 'Action name needs to be defined as string');\n\n    const RegisteredAction = this.registeredAction(actionName);\n\n    // creating action\n    const action = new RegisteredAction();\n\n    // setting session\n    if (session){\n      action.setSession(session);\n    }\n\n    // adding the action name used to create the action under the metadata\n    action.setMeta('action.name', actionName.toLowerCase());\n\n    // adding a metadata information telling the action is a top level one\n    // it has not being created inside of another action through the\n    // Action.createAction\n    action.setMeta('action.origin', 'topLevel');\n\n    return action;\n  }\n\n  /**\n   * Creates an action based on the serialized input which is generated by\n   * {@link Action.bakeToJSON}\n   *\n   * @param {string} serializedAction - json encoded action\n   * @param {boolean} [autofill=true] - tells if the autofill information should be\n   * loaded\n   * @return {Action}\n   */\n  static createFromJSON(serializedAction, autofill=true){\n    assert(TypeCheck.isString(serializedAction), 'serializedAction needs to be defined as string!');\n\n    const actionContents = JSON.parse(serializedAction);\n    const name = actionContents.metadata.action.name;\n\n    assert(TypeCheck.isString(name), 'Could not find the action information');\n    const action = this.create(name);\n\n    assert(action, `Action not found: ${name}`);\n\n    action._loadContents(actionContents, autofill);\n\n    return action;\n  }\n\n  /**\n   * Associates a {@link Session} with the action. By doing this all inputs that\n   * are flagged with 'autofill' property will be initialized with the\n   * session value. The session assigned to the action is cloned during the assignment\n   * ({@link Session.clone}). A session is always assigned to an action,\n   * during the factoring ({@link Action.create}).\n   *\n   * @param {Session} session - session object\n   */\n  setSession(session){\n    assert(session instanceof Session, 'Invalid session!');\n\n    this[_session] = session.clone();\n\n    // setting the session inputs\n    const autofillKeys = this[_session].autofillKeys();\n    for (const inputName of this.inputNames()){\n\n      const input = this.input(inputName);\n\n      // setting the autofill inputs\n      const autofillName = input.property('autofill');\n      if (autofillName && autofillKeys.includes(autofillName)){\n        input.setValue(this[_session].autofill(autofillName));\n      }\n    }\n  }\n\n  /**\n   * Returns the session object\n   *\n   * @return {Session}\n   */\n  session(){\n\n    // creating session on demanding\n    if (!this[_session]){\n      this[_session] = new Session();\n    }\n\n    return this[_session];\n  }\n\n  /**\n   * Returns a value under the action's metadata.\n   *\n   * @param {string} path - path about where the value is localized (the levels\n   * must be separated by '.'). In case of an empty string it returns the\n   * entire metadata. The path can be defined using `option vars`\n   * ({@link Metadata.optionVar}).\n   * @param {*} [defaultValue] - default value returned in case a value was\n   * not found for the path\n   * @return {*}\n   */\n  meta(path, defaultValue=undefined){\n    assert(TypeCheck.isString(path), 'path needs to be defined as string');\n\n    return this[_metadata].value(path, defaultValue);\n  }\n\n  /**\n   * Sets a value to the action's metadata.\n   *\n   * Detailed information about the metadata support can be found at\n   * {@link Metadata}.\n   *\n   * @param {string} path - path about where the value should be stored under the metadata\n   * (the levels must be separated by '.'). The path can be defined using `option vars`\n   * ({@link Metadata.optionVar}).\n   * @param {*} value - value that is going to be stored under the collection\n   * @param {boolean} [merge=true] - this option is used to decide in case of the\n   * last level is already existing under the collection, if the value should be\n   * either merged (default) or overridden.\n   */\n  setMeta(path, value, merge=true){\n    assert(TypeCheck.isString(path), 'path needs to be defined as string');\n\n    this[_metadata].setValue(path, value, merge);\n  }\n\n  /**\n   * Registers an {@link Action} to the available actions\n   *\n   * In case you want to use a compound name with a prefix common across some group\n   * of actions, you can use '.' as separator.\n   *\n   * @param {Action} actionClass - action implementation that will be registered\n   * @param {string} name - string containing the registration name for the\n   * action, this name is used later to create the action ({@link Action.create}).\n   * In case of an empty string, the registration is done by using the name\n   * of the type.\n   */\n  static register(actionClass, name){\n\n    assert(TypeCheck.isSubClassOf(actionClass, Action), 'Invalid action type');\n    assert(TypeCheck.isString(name), 'name needs to defined as string');\n    assert(name.length, 'name cannot be empty');\n\n    const nameFinal = name.toLowerCase();\n\n    // validating name\n    assert(nameFinal.length, 'action name cannot be empty');\n    assert((/^([\\w_\\.\\-])+$/gi).test(nameFinal), `Illegal action name: ${nameFinal}`); // eslint-disable-line no-useless-escape\n\n    this._registeredActions.set(nameFinal, actionClass);\n  }\n\n  /**\n   * Returns the action based on the registration name\n   *\n   * @param {string} name - name of the registered action\n   * @return {Action}\n   */\n  static registeredAction(name){\n    assert(TypeCheck.isString(name), 'Invalid name!');\n\n    const normalizedName = name.toLowerCase();\n\n    if (this._registeredActions.has(normalizedName)){\n      return this._registeredActions.get(normalizedName);\n    }\n\n    throw new Error(`Action ${name} is not registered!`);\n  }\n\n  /**\n   * Returns the registered action name based on the action class\n   *\n   * @param {Action} actionClass - action that should be used to query the\n   * registered name\n   * @return {string}\n   */\n  static registeredActionName(actionClass){\n    assert(TypeCheck.isSubClassOf(actionClass, Action), 'Invalid action!');\n\n    for (const [registeredName, registeredActionClass] of this._registeredActions.entries()){\n      if (registeredActionClass === actionClass){\n        return registeredName;\n      }\n    }\n\n    throw new InvalidActionError(`There is no action registered for the class ${actionClass.name}!`);\n  }\n\n  /**\n   * Returns a list containing the names of the registered actions\n   *\n   * @return {Array<string>}\n   */\n  static registeredActionNames(){\n    return [...this._registeredActions.keys()];\n  }\n\n  /**\n   * This method should be used to implement the evaluation of the action. It's called\n   * by {@link Action.run} after all inputs have been validated. It's expected to return\n   * a Promise containing the result of the evaluation.\n   *\n   * During the execution of the action all inputs are assigned as read-only ({@link Input.readOnly}),\n   * this is done to prevent any modification in the input while the execution is happening,\n   * by the end of the execution the inputs are assigned back with the read-only state\n   * that was assigned before of the execution.\n   *\n   * *Result through a {@link Handler}:*\n   *\n   * The {@link Handler.output} is used for the serialization of a result. Therefore,\n   * actions should not serialize the result by themselves; instead it should be\n   * done by a handler. The handlers shipped with Mebo have support for streams\n   * where in case of any readable stream or buffer value they are piped to the\n   * output, otherwise the result is serialized using JSON.\n   *\n   * @param {Object} data - plain object containing the value of the inputs, this is just to\n   * provide a more convenient way to query the value of the inputs inside of the\n   * execution for instance: ```data.myInput``` instead of ```this.input('myInput').value()```.\n   * @return {Promise<*>} value that should be returned by the action\n   *\n   * @abstract\n   * @protected\n   */\n  _perform(data){\n    return Promise.reject(new Error('Not implemented error!'));\n  }\n\n  /**\n   * This method is called after the execution of the action.\n   *\n   * You could re-implement this method to:\n   * - Add custom metadata information that can be used by a {@link Writer}\n   * - Add arbitrary information to a log\n   * - In case of errors to purge temporary files\n   *\n   * @param {Error|null} err - Error exception or null in case the action has\n   * been successfully executed\n   * @param {*} value - value returned by the action\n   * @return {Promise} resolved promise (any result passed to the promise is ignored)\n   *\n   * @protected\n   */\n  _finalize(err, value){\n    return Promise.resolve(null);\n  }\n\n  /**\n   * Executes the action and returns the result through a promise\n   *\n   * @return {Promise<*>}\n   * @private\n   */\n  async _execute(){\n    let result = null;\n\n    const data = Object.create(null);\n    const readOnlyOriginalValues = new Map();\n\n    // making inputs read-only during the execution, otherwise it would be very dangerous\n    // since a modified input would not get validated until the next execution.\n    // The original read-only value is restored in the end of the execution. Also,\n    // this process collects the input values that are stored under 'data' which\n    // is later passed as argument of _perform method, it's used as a more convenient\n    // way to query the value of the inputs\n    for (const name of this.inputNames()){\n\n      const input = this.input(name);\n      readOnlyOriginalValues.set(input, input.readOnly());\n\n      // making input as readOnly\n      input.setReadOnly(true);\n\n      // input value\n      data[name] = input.value();\n    }\n\n    // checking if the inputs are valid (it throws an exception in case an input fails)\n    try{\n      await this.validate();\n    }\n    finally{\n      // restoring the read-only\n      for (const [input, originalReadOnly] of readOnlyOriginalValues){\n        input.setReadOnly(originalReadOnly);\n      }\n    }\n\n    // the action is performed inside of a try/catch block to call the _finalize\n    // no matter what, since that can be used to perform clean-up operations...\n    try{\n      // performing the action\n      result = await this._perform(data);\n    }\n    finally{\n      // restoring the read-only\n      for (const [input, originalReadOnly] of readOnlyOriginalValues){\n        input.setReadOnly(originalReadOnly);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Auxiliary method used to the contents of the action\n   *\n   * @param {Object} actionContents - object created when a serialized action\n   * is parsed\n   * @param {boolean} autofill - tells if the {@link Session.autofill} should\n   * be loaded\n   * @private\n   */\n  _loadContents(actionContents, autofill){\n\n    const session = this.session();\n    if (autofill && session){\n      for (const autofillKey in actionContents.session.autofill){\n        session.setAutofill(autofillKey, actionContents.session.autofill[autofillKey]);\n      }\n    }\n\n    for (const inputName in actionContents.inputs){\n      const input = this.input(inputName);\n      assert(input, `Invalid input ${inputName}`);\n\n      input.parseValue(actionContents.inputs[inputName]);\n    }\n  }\n\n  /**\n   * Returns the value of the action inputs serialized\n   *\n   * @param {boolean} avoidHidden - tells if inputs with the 'hidden' property\n   * should be ignored\n   * @return {Promise<Object>}\n   * @private\n   */\n  async _serializeInputs(avoidHidden){\n    let inputNames = this.inputNames();\n\n    // skipping hidden inputs\n    if (avoidHidden){\n      inputNames = inputNames.filter(x => !this.input(x).property('hidden', false));\n    }\n\n    const serializeValuePromises = inputNames.map(x => this.input(x).serializeValue());\n    const serializedResult = await Promise.all(serializeValuePromises);\n\n    const actionInputs = {};\n    for (let i=0, len=inputNames.length; i < len; ++i){\n      actionInputs[inputNames[i]] = serializedResult[i];\n    }\n\n    return actionInputs;\n  }\n\n  /**\n   * Auxiliary method used to include additional information\n   * to the exception raised during execution of the action\n   *\n   * @param {Error} err - exception that should be processed\n   * @return {Error}\n   * @private\n   */\n  _processError(err){\n\n    // adding a member that tells the origin of the error\n    let topLevel = false;\n    if (!err.origin){\n      err.origin = this.meta('action.origin');\n      topLevel = true;\n\n      // disabling output\n      if (err.disableOutputInNested && err.origin === 'nested'){\n        err.output = false;\n      }\n    }\n\n    // adding the action class name and the registered name as a hint\n    // to the stack (for debugging purposes)\n    if (Object.getOwnPropertyDescriptor(err, 'stack').writable){\n      let actionName = this.constructor.name;\n      const registeredName = this.meta('action.name');\n      if (registeredName){\n        actionName += ` (${registeredName})`;\n      }\n\n      // including the action name information in a way that includes all action levels\n      // aka: `/TopLevelAction (...)/NestedActionA (...)/NestedActionB (...):'\n      if (topLevel){\n        actionName += ':\\n';\n      }\n\n      // including hint to the stack\n      err.stack = `Oops, error on action /${actionName}${err.stack}`;\n    }\n\n    return err;\n  }\n\n  static _registeredActions = new Map();\n}\n\n// Setting the default settings:\n\n// lruCacheSize\n// Sets in bytes the size of the LRU cache available for the execution of actions.\n// (default: `20 mb`)\nSettings.set('action/lruCacheSize', 20 * 1012 * 1024);\n\n// lruCacheLifespan\n// Sets in seconds the amount of time that an item under LRU cache should\n// be kept alive. This cache is defined by {@link Session.resultCache}\n// (default: `10 seconds`)\nSettings.set('action/lruCacheLifespan', 10);\n\nmodule.exports = Action;\n",
    "static": true,
    "longname": "src/Action.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1,
    "kind": "variable",
    "name": "__import_module__assert",
    "memberof": "src/Action.js",
    "static": true,
    "longname": "src/Action.js~__import_module__assert",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Action.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Action.js",
    "static": true,
    "longname": "src/Action.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Action.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 3,
    "kind": "variable",
    "name": "__import_module__Utils",
    "memberof": "src/Action.js",
    "static": true,
    "longname": "src/Action.js~__import_module__Utils",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Action.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 4,
    "kind": "variable",
    "name": "__import_module__Settings",
    "memberof": "src/Action.js",
    "static": true,
    "longname": "src/Action.js~__import_module__Settings",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Action.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 5,
    "kind": "variable",
    "name": "__import_module__Session",
    "memberof": "src/Action.js",
    "static": true,
    "longname": "src/Action.js~__import_module__Session",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Action.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 6,
    "kind": "variable",
    "name": "__import_module__Input",
    "memberof": "src/Action.js",
    "static": true,
    "longname": "src/Action.js~__import_module__Input",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Action.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 7,
    "kind": "variable",
    "name": "__import_module__Metadata",
    "memberof": "src/Action.js",
    "static": true,
    "longname": "src/Action.js~__import_module__Metadata",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Action.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 8,
    "kind": "variable",
    "name": "_inputs",
    "memberof": "src/Action.js",
    "static": true,
    "longname": "src/Action.js~_inputs",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Action.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 9,
    "kind": "variable",
    "name": "_session",
    "memberof": "src/Action.js",
    "static": true,
    "longname": "src/Action.js~_session",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Action.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 10,
    "kind": "variable",
    "name": "_metadata",
    "memberof": "src/Action.js",
    "static": true,
    "longname": "src/Action.js~_metadata",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Action.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 11,
    "kind": "class",
    "name": "InvalidActionError",
    "memberof": "src/Action.js",
    "static": true,
    "longname": "src/Action.js~InvalidActionError",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Action.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 12,
    "kind": "class",
    "name": "Action",
    "memberof": "src/Action.js",
    "static": true,
    "longname": "src/Action.js~Action",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Action.js",
    "importStyle": "Action",
    "description": "An action is used to perform an evaluation.\n\nBy implementing an evaluation through an action, the evaluation is wrapped by an\ninterface that can be triggered from many different forms ({@link Handler}).\n\n```\nclass HelloWorld extends Mebo.Action{\n  _perform(data){\n    return Promise.resolve('Hello World');\n  }\n}\n\nconst action = new HelloWorld();\naction.run().then(...) //  HelloWorld\n```\n\nThe data used to perform an evaluation is held by inputs ({@link Action.createInput}).\nThese inputs can be widely configured to enforce quality control via properties.\nThe available properties can be found under the documentation for each input type.\n\n```\nclass HelloWorld extends Mebo.Action{\n  constructor(){\n    super();\n    this.createInput('repeat: numeric', {max: 100});\n  }\n  _perform(data){\n    const result = 'HelloWorld '.repeat(data.repeat);\n    return Promise.resolve(result);\n  }\n}\n\nconst action = new HelloWorld();\naction.input('repeat').setValue(3);\naction.run().then(...) //  HelloWorld HelloWorld HelloWorld\n```\n\nAn evaluation is triggered through {@link Action.run} which internally calls\n{@link Action._perform}. Use `perform` to implement the evaluation of your action.\nAlso, you can implement {@link Action._finalize} to execute secondary routines.\n\nActions are registered via {@link Action.register}, in case you want\nto use a compound name with a prefix common across some group of\nactions you can use '.' as separator. Also, there are two ways to create actions:\n\n- {@link Action.createAction} - allows actions to be created from inside of another action.\nBy doing that it creates actions that share the same {@link Session}.\n\n- {@link Action.create} - factory an action with custom session when supplied\notherwise it creates a new session.\n\nAlso, actions can take advantage of the caching mechanism designed to improve the performance\nby avoiding re-evaluations in actions that might be executed multiple times. This can enabled\nthrough {@link Action.isCacheable}.",
    "lineNumber": 75,
    "interface": false
  },
  {
    "__docId__": 13,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Action.js~Action#constructor",
    "access": null,
    "description": "creates an action",
    "lineNumber": 80,
    "params": []
  },
  {
    "__docId__": 14,
    "kind": "member",
    "name": "[_inputs]",
    "memberof": "src/Action.js~Action",
    "static": false,
    "longname": "src/Action.js~Action#[_inputs]",
    "access": null,
    "description": null,
    "lineNumber": 81,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 15,
    "kind": "member",
    "name": "[_metadata]",
    "memberof": "src/Action.js~Action",
    "static": false,
    "longname": "src/Action.js~Action#[_metadata]",
    "access": null,
    "description": null,
    "lineNumber": 82,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 16,
    "kind": "method",
    "name": "createInput",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Action.js~Action#createInput",
    "access": null,
    "description": "Creates a new input through {@link Input.create} then adds it\nto the action inputs {@link Action.addInput}",
    "lineNumber": 94,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "inputInterface",
        "description": "string followed by either the pattern `name: type`\nor `name?: type` in case of optional {@link Input}"
      },
      {
        "nullable": null,
        "types": [
          "...*"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "arguments passed to the input's constructor"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Input"
      ],
      "spread": false,
      "description": "Returns the created input instance"
    }
  },
  {
    "__docId__": 17,
    "kind": "method",
    "name": "addInput",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Action.js~Action#addInput",
    "access": null,
    "description": "Adds an {@link Input} instance to the action",
    "lineNumber": 106,
    "params": [
      {
        "nullable": null,
        "types": [
          "Input"
        ],
        "spread": false,
        "optional": false,
        "name": "inputInstance",
        "description": "input that should be added to the action"
      }
    ]
  },
  {
    "__docId__": 18,
    "kind": "method",
    "name": "inputNames",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Action.js~Action#inputNames",
    "access": null,
    "description": "Returns the action input names",
    "lineNumber": 124,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 19,
    "kind": "method",
    "name": "input",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Action.js~Action#input",
    "access": null,
    "description": "Returns the input instance based on the given name",
    "lineNumber": 136,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "inputName",
        "description": "name of the input"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "defaultValue",
        "description": "default value that is returned in case the\ninput does not exist"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Input"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 20,
    "kind": "method",
    "name": "validate",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Action.js~Action#validate",
    "access": null,
    "description": "Runs the validations of all inputs",
    "lineNumber": 151,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 21,
    "kind": "method",
    "name": "isCacheable",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Action.js~Action#isCacheable",
    "access": null,
    "description": "Returns a boolean telling if the action is cacheable (`false` by default).\n\nThis method should be overridden by derived classes to tell if the action\nis cacheable. This information is used by {@link Action.run}.\n\nThe configuration about the LRU cache can be found under the {@link Session}.",
    "lineNumber": 165,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 22,
    "kind": "method",
    "name": "run",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Action.js~Action#run",
    "access": null,
    "description": "Executes the action and returns the result through a promise",
    "lineNumber": 176,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "useCache",
        "description": "tells if the action should try to use the LRU\ncache to avoid the execution. This option is only used when the action is {@link Action.isCacheable}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 23,
    "kind": "method",
    "name": "bakeToJSON",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Action.js~Action#bakeToJSON",
    "access": null,
    "description": "Serializes the current interface of the action into json format. Serialized\nactions can be recreated later through {@link Action.createFromJSON}\nor in case of non-registered actions the baked information can be loaded\ndirectly to an instance through {@link Action.fromJSON}.",
    "lineNumber": 239,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "autofill",
        "description": "tells if the {@link Session.autofill} will be\nincluded in the serialization"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "avoidHidden",
        "description": "tells if inputs with the 'hidden' property\nshould be ignored"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<string>"
      ],
      "spread": false,
      "description": "serialized json version of the action"
    }
  },
  {
    "__docId__": 24,
    "kind": "method",
    "name": "fromJSON",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Action.js~Action#fromJSON",
    "access": null,
    "description": "Loads the interface of the action from json (serialized through {@link Action.bakeToJSON}).",
    "lineNumber": 273,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "serializedAction",
        "description": "serialized json information generated by {@link Action.bakeToJSON}"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "autofill",
        "description": "tells if the {@link Session.autofill} should\nbe loaded"
      }
    ]
  },
  {
    "__docId__": 25,
    "kind": "method",
    "name": "id",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Action.js~Action#id",
    "access": null,
    "description": "Returns an unique signature based on the action's current state. It's based\non the input types, input values and meta data information about the action.\n\nFor a more reliable signature make sure that the action has been created through\nthe factory method ({@link Action.create}).",
    "lineNumber": 289,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 26,
    "kind": "method",
    "name": "createAction",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Action.js~Action#createAction",
    "access": null,
    "description": "Allows the creation of an action based on the current action. By doing this it passes\nthe current {@link Action.session} to the static create method ({@link Action.create}).\nTherefore creating an action that shares the same session.",
    "lineNumber": 324,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "actionName",
        "description": "registered action name (case-insensitive)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Action"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 27,
    "kind": "method",
    "name": "create",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Action.js~Action.create",
    "access": null,
    "description": "Creates an action based on the registered action name, in case the action does\nnot exist `null` is returned instead",
    "lineNumber": 342,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "actionName",
        "description": "registered action name (case-insensitive)"
      },
      {
        "nullable": null,
        "types": [
          "Session"
        ],
        "spread": false,
        "optional": true,
        "name": "session",
        "description": "optional custom session object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Action"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 28,
    "kind": "method",
    "name": "createFromJSON",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Action.js~Action.createFromJSON",
    "access": null,
    "description": "Creates an action based on the serialized input which is generated by\n{@link Action.bakeToJSON}",
    "lineNumber": 375,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "serializedAction",
        "description": "json encoded action"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "autofill",
        "description": "tells if the autofill information should be\nloaded"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Action"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 29,
    "kind": "method",
    "name": "setSession",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Action.js~Action#setSession",
    "access": null,
    "description": "Associates a {@link Session} with the action. By doing this all inputs that\nare flagged with 'autofill' property will be initialized with the\nsession value. The session assigned to the action is cloned during the assignment\n({@link Session.clone}). A session is always assigned to an action,\nduring the factoring ({@link Action.create}).",
    "lineNumber": 400,
    "params": [
      {
        "nullable": null,
        "types": [
          "Session"
        ],
        "spread": false,
        "optional": false,
        "name": "session",
        "description": "session object"
      }
    ]
  },
  {
    "__docId__": 30,
    "kind": "member",
    "name": "[_session]",
    "memberof": "src/Action.js~Action",
    "static": false,
    "longname": "src/Action.js~Action#[_session]",
    "access": null,
    "description": null,
    "lineNumber": 403,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 31,
    "kind": "method",
    "name": "session",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Action.js~Action#session",
    "access": null,
    "description": "Returns the session object",
    "lineNumber": 424,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Session"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 32,
    "kind": "member",
    "name": "[_session]",
    "memberof": "src/Action.js~Action",
    "static": false,
    "longname": "src/Action.js~Action#[_session]",
    "access": null,
    "description": null,
    "lineNumber": 428,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 33,
    "kind": "method",
    "name": "meta",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Action.js~Action#meta",
    "access": null,
    "description": "Returns a value under the action's metadata.",
    "lineNumber": 445,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "path about where the value is localized (the levels\nmust be separated by '.'). In case of an empty string it returns the\nentire metadata. The path can be defined using `option vars`\n({@link Metadata.optionVar})."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "defaultValue",
        "description": "default value returned in case a value was\nnot found for the path"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 34,
    "kind": "method",
    "name": "setMeta",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Action.js~Action#setMeta",
    "access": null,
    "description": "Sets a value to the action's metadata.\n\nDetailed information about the metadata support can be found at\n{@link Metadata}.",
    "lineNumber": 465,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "path about where the value should be stored under the metadata\n(the levels must be separated by '.'). The path can be defined using `option vars`\n({@link Metadata.optionVar})."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value that is going to be stored under the collection"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "merge",
        "description": "this option is used to decide in case of the\nlast level is already existing under the collection, if the value should be\neither merged (default) or overridden."
      }
    ]
  },
  {
    "__docId__": 35,
    "kind": "method",
    "name": "register",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Action.js~Action.register",
    "access": null,
    "description": "Registers an {@link Action} to the available actions\n\nIn case you want to use a compound name with a prefix common across some group\nof actions, you can use '.' as separator.",
    "lineNumber": 483,
    "params": [
      {
        "nullable": null,
        "types": [
          "Action"
        ],
        "spread": false,
        "optional": false,
        "name": "actionClass",
        "description": "action implementation that will be registered"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "string containing the registration name for the\naction, this name is used later to create the action ({@link Action.create}).\nIn case of an empty string, the registration is done by using the name\nof the type."
      }
    ]
  },
  {
    "__docId__": 36,
    "kind": "method",
    "name": "registeredAction",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Action.js~Action.registeredAction",
    "access": null,
    "description": "Returns the action based on the registration name",
    "lineNumber": 504,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "name of the registered action"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Action"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 37,
    "kind": "method",
    "name": "registeredActionName",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Action.js~Action.registeredActionName",
    "access": null,
    "description": "Returns the registered action name based on the action class",
    "lineNumber": 523,
    "params": [
      {
        "nullable": null,
        "types": [
          "Action"
        ],
        "spread": false,
        "optional": false,
        "name": "actionClass",
        "description": "action that should be used to query the\nregistered name"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 38,
    "kind": "method",
    "name": "registeredActionNames",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Action.js~Action.registeredActionNames",
    "access": null,
    "description": "Returns a list containing the names of the registered actions",
    "lineNumber": 540,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 39,
    "kind": "method",
    "name": "_perform",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Action.js~Action#_perform",
    "access": "protected",
    "description": "This method should be used to implement the evaluation of the action. It's called\nby {@link Action.run} after all inputs have been validated. It's expected to return\na Promise containing the result of the evaluation.\n\nDuring the execution of the action all inputs are assigned as read-only ({@link Input.readOnly}),\nthis is done to prevent any modification in the input while the execution is happening,\nby the end of the execution the inputs are assigned back with the read-only state\nthat was assigned before of the execution.\n\n*Result through a {@link Handler}:*\n\nThe {@link Handler.output} is used for the serialization of a result. Therefore,\nactions should not serialize the result by themselves; instead it should be\ndone by a handler. The handlers shipped with Mebo have support for streams\nwhere in case of any readable stream or buffer value they are piped to the\noutput, otherwise the result is serialized using JSON.",
    "lineNumber": 570,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "plain object containing the value of the inputs, this is just to\nprovide a more convenient way to query the value of the inputs inside of the\nexecution for instance: ```data.myInput``` instead of ```this.input('myInput').value()```."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "value that should be returned by the action"
    },
    "abstract": true
  },
  {
    "__docId__": 40,
    "kind": "method",
    "name": "_finalize",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Action.js~Action#_finalize",
    "access": "protected",
    "description": "This method is called after the execution of the action.\n\nYou could re-implement this method to:\n- Add custom metadata information that can be used by a {@link Writer}\n- Add arbitrary information to a log\n- In case of errors to purge temporary files",
    "lineNumber": 589,
    "params": [
      {
        "nullable": null,
        "types": [
          "Error",
          "null"
        ],
        "spread": false,
        "optional": false,
        "name": "err",
        "description": "Error exception or null in case the action has\nbeen successfully executed"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value returned by the action"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "resolved promise (any result passed to the promise is ignored)"
    }
  },
  {
    "__docId__": 41,
    "kind": "method",
    "name": "_execute",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Action.js~Action#_execute",
    "access": "private",
    "description": "Executes the action and returns the result through a promise",
    "lineNumber": 599,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 42,
    "kind": "method",
    "name": "_loadContents",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Action.js~Action#_loadContents",
    "access": "private",
    "description": "Auxiliary method used to the contents of the action",
    "lineNumber": 659,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "actionContents",
        "description": "object created when a serialized action\nis parsed"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "autofill",
        "description": "tells if the {@link Session.autofill} should\nbe loaded"
      }
    ]
  },
  {
    "__docId__": 43,
    "kind": "method",
    "name": "_serializeInputs",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Action.js~Action#_serializeInputs",
    "access": "private",
    "description": "Returns the value of the action inputs serialized",
    "lineNumber": 684,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "avoidHidden",
        "description": "tells if inputs with the 'hidden' property\nshould be ignored"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Object>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 44,
    "kind": "method",
    "name": "_processError",
    "memberof": "src/Action.js~Action",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Action.js~Action#_processError",
    "access": "private",
    "description": "Auxiliary method used to include additional information\nto the exception raised during execution of the action",
    "lineNumber": 711,
    "params": [
      {
        "nullable": null,
        "types": [
          "Error"
        ],
        "spread": false,
        "optional": false,
        "name": "err",
        "description": "exception that should be processed"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Error"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 45,
    "kind": "member",
    "name": "_registeredActions",
    "memberof": "src/Action.js~Action",
    "static": true,
    "longname": "src/Action.js~Action._registeredActions",
    "access": null,
    "description": null,
    "lineNumber": 747,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 46,
    "kind": "file",
    "name": "src/Errors/Conflict.js",
    "content": "const Settings = require('../Settings');\n\n\n/**\n * Exception raised when a resource already exists.\n *\n * This error is provided by Mebo to complement the rest support ({@link Web.restful}),\n * although the main purpose is to provide a status code which is used when reporting\n * it through requests, it can still be used when an action is executed\n * through a different handler since it defines a custom exception type that can be\n * used to identify the error.\n *\n * @see {@link Writer._errorOutput}\n */\nclass Conflict extends Error{\n\n  constructor(message='Conflict'){\n    super(message);\n\n    /**\n     * Status code used by the {@link Handler} when this error is raised from inside of a top\n     * level action (an action that has not been created from another action).\n     *\n     * Value driven by:\n     * `Settings.get('error/conflict/status')`\n     * (default: `409`)\n     *\n     * @type {number}\n     */\n    this.status = Settings.get('error/conflict/status');\n\n    /**\n     * Boolean telling if this error is not allowed as output ({@link Handler.output})\n     * when it has been raised from a nested action (an action created from another\n     * action ({@link Action.createAction})). When output is disabled the error\n     * will not be handled by the {@link Writer}, therefore the error will be\n     * emitted by the signal {@link Handler.onErrorDuringOutput}.\n     *\n     * Value driven by:\n     * `Settings.get('error/conflict/disableOutputInNested')`\n     * (default: `false`)\n     *\n     * @type {boolean}\n     */\n    this.disableOutputInNested = Settings.get('error/conflict/disableOutputInNested');\n  }\n}\n\n// default settings\nSettings.set('error/conflict/status', 409);\nSettings.set('error/conflict/disableOutputInNested', false);\n\nmodule.exports = Conflict;\n",
    "static": true,
    "longname": "src/Errors/Conflict.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 47,
    "kind": "variable",
    "name": "__import_module__Settings",
    "memberof": "src/Errors/Conflict.js",
    "static": true,
    "longname": "src/Errors/Conflict.js~__import_module__Settings",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Errors/Conflict.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 48,
    "kind": "class",
    "name": "Conflict",
    "memberof": "src/Errors/Conflict.js",
    "static": true,
    "longname": "src/Errors/Conflict.js~Conflict",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Errors/Conflict.js",
    "importStyle": "Conflict",
    "description": "Exception raised when a resource already exists.\n\nThis error is provided by Mebo to complement the rest support ({@link Web.restful}),\nalthough the main purpose is to provide a status code which is used when reporting\nit through requests, it can still be used when an action is executed\nthrough a different handler since it defines a custom exception type that can be\nused to identify the error.",
    "see": [
      "{@link Writer._errorOutput}"
    ],
    "lineNumber": 15,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 49,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Errors/Conflict.js~Conflict",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Errors/Conflict.js~Conflict#constructor",
    "access": null,
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "Conflict",
        "defaultValue": "Conflict"
      }
    ]
  },
  {
    "__docId__": 50,
    "kind": "member",
    "name": "status",
    "memberof": "src/Errors/Conflict.js~Conflict",
    "static": false,
    "longname": "src/Errors/Conflict.js~Conflict#status",
    "access": null,
    "description": "Status code used by the {@link Handler} when this error is raised from inside of a top\nlevel action (an action that has not been created from another action).\n\nValue driven by:\n`Settings.get('error/conflict/status')`\n(default: `409`)",
    "lineNumber": 30,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "disableOutputInNested",
    "memberof": "src/Errors/Conflict.js~Conflict",
    "static": false,
    "longname": "src/Errors/Conflict.js~Conflict#disableOutputInNested",
    "access": null,
    "description": "Boolean telling if this error is not allowed as output ({@link Handler.output})\nwhen it has been raised from a nested action (an action created from another\naction ({@link Action.createAction})). When output is disabled the error\nwill not be handled by the {@link Writer}, therefore the error will be\nemitted by the signal {@link Handler.onErrorDuringOutput}.\n\nValue driven by:\n`Settings.get('error/conflict/disableOutputInNested')`\n(default: `false`)",
    "lineNumber": 45,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 52,
    "kind": "file",
    "name": "src/Errors/NoContent.js",
    "content": "const Settings = require('../Settings');\n\n\n/**\n * Exception raised when the required resource that should be updated does not exist.\n *\n * This error is provided by Mebo to complement the rest support ({@link Web.restful}),\n * although the main purpose is to provide a status code which is used when reporting\n * it through requests, it can still be used when an action is executed\n * through a different handler since it defines a custom exception type that can be\n * used to identify the error.\n *\n * @see {@link Writer._errorOutput}\n */\nclass NoContent extends Error{\n\n  constructor(message='No Content'){\n    super(message);\n\n    /**\n     * Status code used by the {@link Handler} when this error is raised from inside of a top\n     * level action (an action that has not been created from another action).\n     *\n     * Value driven by:\n     * `Settings.get('error/noContent/status')`\n     * (default: `204`)\n     *\n     * @type {number}\n     */\n    this.status = Settings.get('error/noContent/status');\n\n    /**\n     * Boolean telling if this error is not allowed as output ({@link Handler.output})\n     * when it has been raised from a nested action (an action created from another\n     * action ({@link Action.createAction})). When output is disabled the error\n     * will not be handled by the {@link Writer}, therefore the error will be\n     * emitted by the signal {@link Handler.onErrorDuringOutput}.\n     *\n     * Value driven by:\n     * `Settings.get('error/noContent/disableOutputInNested')`\n     * (default: `false`)\n     *\n     * @type {boolean}\n     */\n    this.disableOutputInNested = Settings.get('error/noContent/disableOutputInNested');\n  }\n}\n\n// default settings\nSettings.set('error/noContent/status', 204);\nSettings.set('error/noContent/disableOutputInNested', false);\n\nmodule.exports = NoContent;\n",
    "static": true,
    "longname": "src/Errors/NoContent.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 53,
    "kind": "variable",
    "name": "__import_module__Settings",
    "memberof": "src/Errors/NoContent.js",
    "static": true,
    "longname": "src/Errors/NoContent.js~__import_module__Settings",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Errors/NoContent.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 54,
    "kind": "class",
    "name": "NoContent",
    "memberof": "src/Errors/NoContent.js",
    "static": true,
    "longname": "src/Errors/NoContent.js~NoContent",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Errors/NoContent.js",
    "importStyle": "NoContent",
    "description": "Exception raised when the required resource that should be updated does not exist.\n\nThis error is provided by Mebo to complement the rest support ({@link Web.restful}),\nalthough the main purpose is to provide a status code which is used when reporting\nit through requests, it can still be used when an action is executed\nthrough a different handler since it defines a custom exception type that can be\nused to identify the error.",
    "see": [
      "{@link Writer._errorOutput}"
    ],
    "lineNumber": 15,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 55,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Errors/NoContent.js~NoContent",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Errors/NoContent.js~NoContent#constructor",
    "access": null,
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "No Content",
        "defaultValue": "No Content"
      }
    ]
  },
  {
    "__docId__": 56,
    "kind": "member",
    "name": "status",
    "memberof": "src/Errors/NoContent.js~NoContent",
    "static": false,
    "longname": "src/Errors/NoContent.js~NoContent#status",
    "access": null,
    "description": "Status code used by the {@link Handler} when this error is raised from inside of a top\nlevel action (an action that has not been created from another action).\n\nValue driven by:\n`Settings.get('error/noContent/status')`\n(default: `204`)",
    "lineNumber": 30,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 57,
    "kind": "member",
    "name": "disableOutputInNested",
    "memberof": "src/Errors/NoContent.js~NoContent",
    "static": false,
    "longname": "src/Errors/NoContent.js~NoContent#disableOutputInNested",
    "access": null,
    "description": "Boolean telling if this error is not allowed as output ({@link Handler.output})\nwhen it has been raised from a nested action (an action created from another\naction ({@link Action.createAction})). When output is disabled the error\nwill not be handled by the {@link Writer}, therefore the error will be\nemitted by the signal {@link Handler.onErrorDuringOutput}.\n\nValue driven by:\n`Settings.get('error/noContent/disableOutputInNested')`\n(default: `false`)",
    "lineNumber": 45,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 58,
    "kind": "file",
    "name": "src/Errors/NotFound.js",
    "content": "const Settings = require('../Settings');\n\n\n/**\n * Exception raised when querying a resource that does not exist.\n *\n * This error is provided by Mebo to complement the rest support ({@link Web.restful}),\n * although the main purpose is to provide a status code which is used when reporting\n * it through requests, it can still be used when an action is executed\n * through a different handler since it defines a custom exception type that can be\n * used to identify the error.\n *\n * @see {@link Writer._errorOutput}\n */\nclass NotFound extends Error{\n\n  constructor(message='Not Found'){\n    super(message);\n\n    /**\n     * Status code used by the {@link Handler} when this error is raised from inside of a top\n     * level action (an action that has not been created from another action).\n     *\n     * Value driven by:\n     * `Settings.get('error/notFound/status')`\n     * (default: `404`)\n     *\n     * @type {number}\n     */\n    this.status = Settings.get('error/notFound/status');\n\n    /**\n     * Boolean telling if this error is not allowed as output ({@link Handler.output})\n     * when it has been raised from a nested action (an action created from another\n     * action ({@link Action.createAction})). When output is disabled the error\n     * will not be handled by the {@link Writer}, therefore the error will be\n     * emitted by the signal {@link Handler.onErrorDuringOutput}.\n     *\n     * Value driven by:\n     * `Settings.get('error/notFound/disableOutputInNested')`\n     * (default: `false`)\n     *\n     * @type {boolean}\n     */\n    this.disableOutputInNested = Settings.get('error/notFound/disableOutputInNested');\n  }\n}\n\n// default settings\nSettings.set('error/notFound/status', 404);\nSettings.set('error/notFound/disableOutputInNested', false);\n\nmodule.exports = NotFound;\n",
    "static": true,
    "longname": "src/Errors/NotFound.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 59,
    "kind": "variable",
    "name": "__import_module__Settings",
    "memberof": "src/Errors/NotFound.js",
    "static": true,
    "longname": "src/Errors/NotFound.js~__import_module__Settings",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Errors/NotFound.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 60,
    "kind": "class",
    "name": "NotFound",
    "memberof": "src/Errors/NotFound.js",
    "static": true,
    "longname": "src/Errors/NotFound.js~NotFound",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Errors/NotFound.js",
    "importStyle": "NotFound",
    "description": "Exception raised when querying a resource that does not exist.\n\nThis error is provided by Mebo to complement the rest support ({@link Web.restful}),\nalthough the main purpose is to provide a status code which is used when reporting\nit through requests, it can still be used when an action is executed\nthrough a different handler since it defines a custom exception type that can be\nused to identify the error.",
    "see": [
      "{@link Writer._errorOutput}"
    ],
    "lineNumber": 15,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 61,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Errors/NotFound.js~NotFound",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Errors/NotFound.js~NotFound#constructor",
    "access": null,
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "Not Found",
        "defaultValue": "Not Found"
      }
    ]
  },
  {
    "__docId__": 62,
    "kind": "member",
    "name": "status",
    "memberof": "src/Errors/NotFound.js~NotFound",
    "static": false,
    "longname": "src/Errors/NotFound.js~NotFound#status",
    "access": null,
    "description": "Status code used by the {@link Handler} when this error is raised from inside of a top\nlevel action (an action that has not been created from another action).\n\nValue driven by:\n`Settings.get('error/notFound/status')`\n(default: `404`)",
    "lineNumber": 30,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 63,
    "kind": "member",
    "name": "disableOutputInNested",
    "memberof": "src/Errors/NotFound.js~NotFound",
    "static": false,
    "longname": "src/Errors/NotFound.js~NotFound#disableOutputInNested",
    "access": null,
    "description": "Boolean telling if this error is not allowed as output ({@link Handler.output})\nwhen it has been raised from a nested action (an action created from another\naction ({@link Action.createAction})). When output is disabled the error\nwill not be handled by the {@link Writer}, therefore the error will be\nemitted by the signal {@link Handler.onErrorDuringOutput}.\n\nValue driven by:\n`Settings.get('error/notFound/disableOutputInNested')`\n(default: `false`)",
    "lineNumber": 45,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 64,
    "kind": "file",
    "name": "src/Errors/ValidationFail.js",
    "content": "const assert = require('assert');\nconst TypeCheck = require('js-typecheck');\nconst Settings = require('../Settings');\n\n// symbols used for private instance variables to avoid any potential clashing\n// caused by re-implementations\nconst _inputName = Symbol('inputName');\nconst _code = Symbol('code');\nconst _message = Symbol('message');\n\n\n/**\n * Exception raised by {@link Input} validations.\n *\n * It carries additional information about the context of the error that can be used when\n * reporting/handling it. For this reason when this exception handled by a {@link Handler}\n * it gets encoded into json {@link ValidationFail.toJSON}.\n *\n * ```javascript\n * throw new ValidationFail('File does not exit!')\n * ```\n * @see {@link Writer._errorOutput}\n */\nclass ValidationFail extends Error{\n\n  /**\n   * Initialize the exception\n   *\n   * @param {string} message - error message\n   * @param {string} [code] - unique code based on uuid v4 that can be used to identify the error\n   * @param {string} [inputName] - name of the input about where the exception was generated\n   * type\n   */\n  constructor(message, code=null, inputName=null){\n    assert(TypeCheck.isString(message) && message.length, 'message needs to defined as valid string (cannot be empty)');\n\n    super(message);\n\n    this.code = code;\n    this.inputName = inputName;\n\n    /**\n     * Status code used by the {@link Handler} when this error is raised from inside of a top\n     * level action (an action that has not been created from another action).\n     *\n     * Value driven by:\n     * `Settings.get('error/validationFail/status')`\n     * (default: `400`)\n     *\n     * @type {number}\n     */\n    this.status = Settings.get('error/validationFail/status');\n\n    /**\n     * Boolean telling if this error is not allowed as output ({@link Handler.output})\n     * when it has been raised from a nested action (an action created from another\n     * action ({@link Action.createAction})). When output is disabled the error\n     * will not be handled by the {@link Writer}, therefore the error will be\n     * emitted by the signal {@link Handler.onErrorDuringOutput}.\n     *\n     * Value driven by:\n     * `Settings.get('error/validationFail/disableOutputInNested')`\n     * (default: `true`)\n     *\n     * @type {boolean}\n     */\n    this.disableOutputInNested = Settings.get('error/validationFail/disableOutputInNested');\n\n    // storing the original message\n    this[_message] = message;\n\n    this._updateMessage();\n  }\n\n  /**\n   * Sets the input name related with the validation\n   *\n   * @param {string} [inputName] - name of the input\n   */\n  set inputName(inputName){\n    assert(inputName === null || (TypeCheck.isString(inputName) && inputName.length), 'inputName needs to defined as valid string');\n\n    this[_inputName] = inputName;\n\n    this._updateMessage();\n  }\n\n  /**\n   * Returns the input name related with the validation\n   *\n   * @type {string}\n   */\n  get inputName(){\n    return this[_inputName];\n  }\n\n  /**\n   * Sets an unique error code specifically related with that has failed validation, this\n   * information can be used later to identify the origin of the error, instead of trying\n   * to parse the message to figure out that information.\n   *\n   * @param {string} [errorCode] - unique code based on uuid v4 that can be used to identify the error\n   */\n  set code(errorCode){\n    assert(errorCode === null || /^\\w{8}-\\w{4}-\\w{4}-\\w{4}-\\w{12}$/.test(errorCode), 'errorCode needs to defined as uuid or null');\n\n    this[_code] = errorCode;\n  }\n\n  /**\n   * Returns the code related with the validation itself\n   *\n   * @type {string}\n   */\n  get code(){\n    return this[_code];\n  }\n\n  /**\n   * Bakes the exception into a json string\n   *\n   * @return {string} json string containing the serialized version of the exception\n   */\n  toJSON(){\n    return JSON.stringify({\n      message: this[_message],\n      code: this.code,\n      inputName: this.inputName,\n    });\n  }\n\n  /**\n   * Creates a ValidationFail instance based on the input json string\n   *\n   * @param {string} json - string containing the serialized json version of the exception\n   * @return {ValidationFail}\n   */\n  static fromJSON(json){\n    assert(TypeCheck.isString(json) && json.length, 'json needs to be defined as valid string');\n\n    const data = JSON.parse(json);\n    return new ValidationFail(data.message, data.code, data.inputName);\n  }\n\n  /**\n   * Auxiliary method that updates the validation fail message\n   * @private\n   */\n  _updateMessage(){\n\n    if (this.inputName){\n      this.message = `${this.inputName}: ${this[_message]}`;\n    }\n    else{\n      this.message = this[_message];\n    }\n  }\n}\n\n// default settings\nSettings.set('error/validationFail/status', 400);\nSettings.set('error/validationFail/disableOutputInNested', true);\n\nmodule.exports = ValidationFail;\n",
    "static": true,
    "longname": "src/Errors/ValidationFail.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 65,
    "kind": "variable",
    "name": "__import_module__assert",
    "memberof": "src/Errors/ValidationFail.js",
    "static": true,
    "longname": "src/Errors/ValidationFail.js~__import_module__assert",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Errors/ValidationFail.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 66,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Errors/ValidationFail.js",
    "static": true,
    "longname": "src/Errors/ValidationFail.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Errors/ValidationFail.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 67,
    "kind": "variable",
    "name": "__import_module__Settings",
    "memberof": "src/Errors/ValidationFail.js",
    "static": true,
    "longname": "src/Errors/ValidationFail.js~__import_module__Settings",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Errors/ValidationFail.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 68,
    "kind": "variable",
    "name": "_inputName",
    "memberof": "src/Errors/ValidationFail.js",
    "static": true,
    "longname": "src/Errors/ValidationFail.js~_inputName",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Errors/ValidationFail.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 69,
    "kind": "variable",
    "name": "_code",
    "memberof": "src/Errors/ValidationFail.js",
    "static": true,
    "longname": "src/Errors/ValidationFail.js~_code",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Errors/ValidationFail.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 70,
    "kind": "variable",
    "name": "_message",
    "memberof": "src/Errors/ValidationFail.js",
    "static": true,
    "longname": "src/Errors/ValidationFail.js~_message",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Errors/ValidationFail.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 71,
    "kind": "class",
    "name": "ValidationFail",
    "memberof": "src/Errors/ValidationFail.js",
    "static": true,
    "longname": "src/Errors/ValidationFail.js~ValidationFail",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Errors/ValidationFail.js",
    "importStyle": "ValidationFail",
    "description": "Exception raised by {@link Input} validations.\n\nIt carries additional information about the context of the error that can be used when\nreporting/handling it. For this reason when this exception handled by a {@link Handler}\nit gets encoded into json {@link ValidationFail.toJSON}.\n\n```javascript\nthrow new ValidationFail('File does not exit!')\n```",
    "see": [
      "{@link Writer._errorOutput}"
    ],
    "lineNumber": 24,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 72,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Errors/ValidationFail.js~ValidationFail",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Errors/ValidationFail.js~ValidationFail#constructor",
    "access": null,
    "description": "Initialize the exception",
    "lineNumber": 34,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": "error message"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "code",
        "description": "unique code based on uuid v4 that can be used to identify the error"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "inputName",
        "description": "name of the input about where the exception was generated\ntype"
      }
    ]
  },
  {
    "__docId__": 73,
    "kind": "member",
    "name": "code",
    "memberof": "src/Errors/ValidationFail.js~ValidationFail",
    "static": false,
    "longname": "src/Errors/ValidationFail.js~ValidationFail#code",
    "access": null,
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 74,
    "kind": "member",
    "name": "inputName",
    "memberof": "src/Errors/ValidationFail.js~ValidationFail",
    "static": false,
    "longname": "src/Errors/ValidationFail.js~ValidationFail#inputName",
    "access": null,
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 75,
    "kind": "member",
    "name": "status",
    "memberof": "src/Errors/ValidationFail.js~ValidationFail",
    "static": false,
    "longname": "src/Errors/ValidationFail.js~ValidationFail#status",
    "access": null,
    "description": "Status code used by the {@link Handler} when this error is raised from inside of a top\nlevel action (an action that has not been created from another action).\n\nValue driven by:\n`Settings.get('error/validationFail/status')`\n(default: `400`)",
    "lineNumber": 52,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 76,
    "kind": "member",
    "name": "disableOutputInNested",
    "memberof": "src/Errors/ValidationFail.js~ValidationFail",
    "static": false,
    "longname": "src/Errors/ValidationFail.js~ValidationFail#disableOutputInNested",
    "access": null,
    "description": "Boolean telling if this error is not allowed as output ({@link Handler.output})\nwhen it has been raised from a nested action (an action created from another\naction ({@link Action.createAction})). When output is disabled the error\nwill not be handled by the {@link Writer}, therefore the error will be\nemitted by the signal {@link Handler.onErrorDuringOutput}.\n\nValue driven by:\n`Settings.get('error/validationFail/disableOutputInNested')`\n(default: `true`)",
    "lineNumber": 67,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 77,
    "kind": "member",
    "name": "[_message]",
    "memberof": "src/Errors/ValidationFail.js~ValidationFail",
    "static": false,
    "longname": "src/Errors/ValidationFail.js~ValidationFail#[_message]",
    "access": null,
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 78,
    "kind": "set",
    "name": "inputName",
    "memberof": "src/Errors/ValidationFail.js~ValidationFail",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Errors/ValidationFail.js~ValidationFail#inputName",
    "access": null,
    "description": "Sets the input name related with the validation",
    "lineNumber": 80,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "inputName",
        "description": "name of the input"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 79,
    "kind": "member",
    "name": "[_inputName]",
    "memberof": "src/Errors/ValidationFail.js~ValidationFail",
    "static": false,
    "longname": "src/Errors/ValidationFail.js~ValidationFail#[_inputName]",
    "access": null,
    "description": null,
    "lineNumber": 83,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 80,
    "kind": "get",
    "name": "inputName",
    "memberof": "src/Errors/ValidationFail.js~ValidationFail",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Errors/ValidationFail.js~ValidationFail#inputName",
    "access": null,
    "description": "Returns the input name related with the validation",
    "lineNumber": 93,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 81,
    "kind": "set",
    "name": "code",
    "memberof": "src/Errors/ValidationFail.js~ValidationFail",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Errors/ValidationFail.js~ValidationFail#code",
    "access": null,
    "description": "Sets an unique error code specifically related with that has failed validation, this\ninformation can be used later to identify the origin of the error, instead of trying\nto parse the message to figure out that information.",
    "lineNumber": 104,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "errorCode",
        "description": "unique code based on uuid v4 that can be used to identify the error"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 82,
    "kind": "member",
    "name": "[_code]",
    "memberof": "src/Errors/ValidationFail.js~ValidationFail",
    "static": false,
    "longname": "src/Errors/ValidationFail.js~ValidationFail#[_code]",
    "access": null,
    "description": null,
    "lineNumber": 107,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 83,
    "kind": "get",
    "name": "code",
    "memberof": "src/Errors/ValidationFail.js~ValidationFail",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Errors/ValidationFail.js~ValidationFail#code",
    "access": null,
    "description": "Returns the code related with the validation itself",
    "lineNumber": 115,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 84,
    "kind": "method",
    "name": "toJSON",
    "memberof": "src/Errors/ValidationFail.js~ValidationFail",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Errors/ValidationFail.js~ValidationFail#toJSON",
    "access": null,
    "description": "Bakes the exception into a json string",
    "lineNumber": 124,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "json string containing the serialized version of the exception"
    }
  },
  {
    "__docId__": 85,
    "kind": "method",
    "name": "fromJSON",
    "memberof": "src/Errors/ValidationFail.js~ValidationFail",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Errors/ValidationFail.js~ValidationFail.fromJSON",
    "access": null,
    "description": "Creates a ValidationFail instance based on the input json string",
    "lineNumber": 138,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "json",
        "description": "string containing the serialized json version of the exception"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValidationFail"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 86,
    "kind": "method",
    "name": "_updateMessage",
    "memberof": "src/Errors/ValidationFail.js~ValidationFail",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Errors/ValidationFail.js~ValidationFail#_updateMessage",
    "access": "private",
    "description": "Auxiliary method that updates the validation fail message",
    "lineNumber": 149,
    "params": []
  },
  {
    "__docId__": 87,
    "kind": "member",
    "name": "message",
    "memberof": "src/Errors/ValidationFail.js~ValidationFail",
    "static": false,
    "longname": "src/Errors/ValidationFail.js~ValidationFail#message",
    "access": null,
    "description": null,
    "lineNumber": 152,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 88,
    "kind": "member",
    "name": "message",
    "memberof": "src/Errors/ValidationFail.js~ValidationFail",
    "static": false,
    "longname": "src/Errors/ValidationFail.js~ValidationFail#message",
    "access": null,
    "description": null,
    "lineNumber": 155,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 89,
    "kind": "file",
    "name": "src/Errors/index.js",
    "content": "module.exports.ValidationFail = require('./ValidationFail');\nmodule.exports.Conflict = require('./Conflict');\nmodule.exports.NoContent = require('./NoContent');\nmodule.exports.NotFound = require('./NotFound');\n",
    "static": true,
    "longname": "src/Errors/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 90,
    "kind": "file",
    "name": "src/Handler.js",
    "content": "const assert = require('assert');\nconst EventEmitter = require('events');\nconst TypeCheck = require('js-typecheck');\nconst minimatch = require('minimatch');\nconst Session = require('./Session');\nconst Action = require('./Action');\nconst Metadata = require('./Metadata');\nconst Reader = require('./Reader');\nconst Writer = require('./Writer');\nconst Utils = require('./Utils');\n\n// symbols used for private instance variables to avoid any potential clashing\n// caused by re-implementations\nconst _session = Symbol('session');\nconst _metadata = Symbol('metadata');\n\n\n/**\n * A handler is used to bridge an execution method to Mebo.\n *\n * The data used to perform the execution of action through a handler\n * ({@link Handler.runAction}) is parsed using a reader {@link Reader}.\n *\n * The result of a handler is done through a {@link Writer}. Writers are designed\n * to support reporting a success output and an error output as well. The way the\n * result is serialized is determined by the writer implementation\n * ({@link Writer._successOutput}, {@link Writer._errorOutput}). All writers\n * shipped with Mebo have support for streams where in case of any readable stream\n * or buffer value they are piped to the output, otherwise the result is encoded\n * using JSON.\n *\n * Both reader and writer can be customized through options that can be either\n * defined through the action's metadata or directly through the handler. If you would\n * like to know more about the available options check out the respective\n * {@link Reader} & {@link Writer} documentation for the handler implementation\n * you are interested.\n *\n * Defining options through actions (detailed information can be found at\n * {@link Metadata}):\n * ```\n * @Mebo.register('myAction')\n * class MyAction extends Mebo.Action{\n *    constructor(){\n *      super();\n *\n *      // change 'name' for the registration name of the handler you\n *      // want to define the read & write options\n *      this.setMeta('handler.name', {\n *        readOptions: {\n *          someReadOption: true,\n *        },\n *        writeOptions: {\n *          someWriteOption: 10,\n *        },\n *      });\n *    }\n * }\n * ```\n *\n * Defining options directly through the handler:\n * ```\n * // read options\n * myHandler.runAction('myAction', {\n *  someReadOption: true,\n * })\n *\n * // write options\n * myHandler.output(value, {\n *  someWriteOption: 10,\n * })\n * ```\n *\n * Handlers are created by their registration name ({@link Handler.register}),\n * the creation is done by {@link Handler.create}:\n *\n * ```\n * // creating a handle based on the handler registration name\n * const handler = Mebo.Handler.create('myHandler');\n *\n * // loading the parsed information to the action\n * handler.runAction('actionName').then((result) => {\n *\n *    // success output\n *    handler.output(result);\n *\n * // error output\n * }).catch((err) => {\n *    handler.output(err);\n * });\n * ```\n *\n * **Tip:** You can set the env variable `NODE_ENV=development` to get the\n * traceback information included in the error output.\n */\nclass Handler{\n\n  /**\n   * Creates a Handler\n   */\n  constructor(){\n    this[_metadata] = new Metadata();\n  }\n\n  /**\n   * Associates a {@link Session} with the handler. The session assigned to\n   * the handler is cloned during the assignment ({@link Session.clone}).\n   *\n   * @param {Session} session - session object\n   */\n  setSession(session){\n    assert(session instanceof Session, 'Invalid session!');\n\n    this[_session] = session.clone();\n  }\n\n  /**\n   * Returns the session\n   *\n   * @return {Session}\n   */\n  session(){\n\n    // creating session on demanding\n    if (!this[_session]){\n      this[_session] = new Session();\n    }\n\n    return this[_session];\n  }\n\n  /**\n   * Returns a value under the handler's metadata.\n   *\n   * @param {string} path - path about where the value is localized (the levels\n   * must be separated by '.'). In case of an empty string it returns the\n   * entire metadata. The path can be defined using `option vars`\n   * ({@link Metadata.optionVar}).\n   * @param {*} [defaultValue] - default value returned in case a value was\n   * not found for the path\n   * @return {*}\n   */\n  meta(path, defaultValue=undefined){\n    assert(TypeCheck.isString(path), 'path needs to be defined as string');\n\n    return this[_metadata].value(path, defaultValue);\n  }\n\n  /**\n   * Sets a value to the handler's metadata.\n   *\n   * Detailed information about the metadata support can be found at\n   * {@link Metadata}.\n   *\n   * @param {string} path - path about where the value should be stored under the metadata\n   * (the levels must be separated by '.'). The path can be defined using `option vars`\n   * ({@link Metadata.optionVar}).\n   * @param {*} value - value that is going to be stored under the collection\n   * @param {boolean} [merge=true] - this option is used to decide in case of the\n   * last level is already existing under the collection, if the value should be\n   * either merged (default) or overridden.\n   */\n  setMeta(path, value, merge=true){\n    assert(TypeCheck.isString(path), 'path needs to be defined as string');\n\n    this[_metadata].setValue(path, value, merge);\n  }\n\n  /**\n   * Executes an action through the handler.\n   *\n   * This process is done by creating an action that loads the information\n   * parsed by the {@link Reader}.\n   *\n   * After the construction of the action it looks for reading options that can\n   * be defined as part of the action's metadata ({@link Action.metadata}) and\n   * when found they are passed to the reader. After the execution of the action\n   * it looks again inside of the action's metadata for writing options, which\n   * are later used during the output ({@link Handler.output}). To know how\n   * to define action's metadata for the handler take a look at the initial\n   * documentation about the {@link Handler}.\n   *\n   * @param {string} actionName - registered action name that should be executed\n   * @param {Object} options - plain object containing the options that is passed\n   * to the {@link Reader}.\n   * for the handler should be fetched.\n   * @return {*} result of the action\n   */\n  async runAction(actionName, options={}){\n\n    const action = Action.create(actionName, this.session());\n\n    // collecting read options from the action\n    let actionHandlerName = this._actionHandlerName(action);\n\n    if (actionHandlerName.length){\n      this.setMeta(\n        'readOptions',\n        action.meta(`handler.${actionHandlerName}.readOptions`, {}),\n      );\n    }\n\n    // executing action\n    let result;\n    await this._load(action, options);\n    try{\n      result = await action.run();\n    }\n    finally{\n\n      // handler metadata can be defined later during\n      // for this reason querying it again if it was not defined previously\n      if (!actionHandlerName.length){\n        actionHandlerName = this._actionHandlerName(action);\n      }\n\n      // collecting write options from the action\n      if (actionHandlerName.length){\n        this.setMeta(\n          'writeOptions',\n          action.meta(`handler.${actionHandlerName}.writeOptions`, {}),\n        );\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Results a value through the handler.\n   *\n   * In case the value is an exception then it's treated as {@link Writer._errorOutput}\n   * otherwise the value is treated as {@link Writer._successOutput}.\n   *\n   * When an action is executed through the handler ({@link Handler.runAction})\n   * it can define writing options that are used by the output. These\n   * options are stored under the {@link Handler.metadata} where any options passed\n   * directly to the output method override them.\n   *\n   * If `finalizeSession` is enabled (default) the {@link Handler.session} gets finalized\n   * at the end of the output process.\n   *\n   * By default the {@link Writer._errorOutput} tries to handle the error as output.\n   * However you can tell a writer to do not handle specific errors, by doing that the writer\n   * will raise the errors instead of trying to handle them. This can be achieved\n   * by having `output` defined as member of the error (`error.output = false`),\n   * further information can be found at the error output documentation\n   * ({@link Writer._errorOutput}).\n   *\n   * In case of any error raised during the output process the handler emits the signal\n   * {@link Handler.onErrorDuringOutput}.\n   *\n   * @param {*} value - raw value that should be resulted by the handler\n   * @param {Object} [options] - plain object containing options that should be used\n   * by the output where each handler implementation contains their own set of options.\n   * @param {boolean} [finalizeSession=true] - tells if it should finalize the session\n   * ({@link Session.finalize})\n   */\n  output(value, options={}, finalizeSession=true){\n\n    const writeOptions = Utils.deepMerge(this.meta('writeOptions', {}), options);\n    const writer = this._createWriter(value, writeOptions);\n    try{\n      writer.serialize();\n    }\n    catch(err){\n      this._emitOutputError(err);\n    }\n\n    // the session finalization runs in parallel, since it does secondary tasks\n    // (such as clean-up, logging, etc...) there is no need to await for that\n    if (finalizeSession){\n      this.session().finalize().then(() => {\n        // runaway promise\n        return null;\n      }).catch((err) => {\n        this._emitOutputError(err);\n      });\n    }\n  }\n\n  /**\n   * Creates a handler based on the registered name\n   *\n   * Alternatively this method can be called directly from Mebo as `Mebo.Handler.create(...)`\n   *\n   * Also, the handler name gets included in the session as arbitrary data, it can be\n   * retrieved through 'handler'. This name follows the registration pattern where this\n   * value is represented in lowercase internally:\n   * ```\n   * Session.get('handler');\n   * ```\n   * @param {string} handlerName - registered handler name\n   * @param {string} [mask='*'] - optional mask that supports a glob syntax used\n   * to match a custom registered handler (it allows to have\n   * custom handler implementations for specific masks)\n   * @param {...args} args - custom args passed to the constructor during factoring\n   * @return {Handler}\n   */\n  static create(handlerName, mask='*', ...args){\n    const HandlerClass = this.registeredHandler(handlerName, mask);\n\n    // creates a new instance\n    const handler = new HandlerClass(...args);\n\n    // adding the handler name used to factory the handler under the metadata\n    const normalizedHandlerName = handlerName.toLowerCase();\n    handler.setMeta('handler.name', normalizedHandlerName);\n    handler.setMeta('handler.mask', mask.toLowerCase());\n\n    // also, adding the handler name under the session arbitrary data\n    handler.session().set('handler', normalizedHandlerName);\n\n    return handler;\n  }\n\n  /**\n   * Register an {@link Handler} type to the available handlers\n   *\n   * @param {Handler} handlerClass - handler implementation that will be registered\n   * @param {string} [handlerName] - string containing the registration name for the\n   * handler. In case of an empty string, the registration is done by using the name\n   * of the type (this information is stored in lowercase)\n   * @param {string} [handlerMask='*'] - optional mask that supports a glob syntax used\n   * to match a custom registered handler (it allows to have\n   * custom handler implementations for specific masks)\n   */\n  static register(handlerClass, handlerName='', handlerMask='*'){\n    assert(TypeCheck.isSubClassOf(handlerClass, Handler), 'Invalid handler type!');\n    const handlerNameFinal = ((handlerName === '') ? handlerClass.name : handlerName);\n\n    this._register(this._registeredHandlers, handlerClass, handlerNameFinal, handlerMask);\n  }\n\n  /**\n   * Register a {@link Reader} for the handler\n   *\n   * @param {Reader} readerClass - reader class\n   * @param {string} handlerName - registered handler name\n   * @param {string} [handlerMask='*'] - optional mask that supports a glob syntax used\n   * to match a custom registered handler (it allows to have\n   * custom handler implementations for specific masks)\n   */\n  static registerReader(readerClass, handlerName, handlerMask='*'){\n    assert(TypeCheck.isSubClassOf(readerClass, Reader), 'Invalid reader type');\n\n    this._register(this._registeredReaders, readerClass, handlerName, handlerMask);\n  }\n\n  /**\n   * Register a {@link Writer} for the handler\n   *\n   * @param {Writer} writerClass - writer class\n   * @param {string} handlerName - registered handler name\n   * @param {string} [handlerMask='*'] - optional mask that supports a glob syntax used\n   * to match a custom registered handler (it allows to have\n   * custom handler implementations for specific masks)\n   */\n  static registerWriter(writerClass, handlerName, handlerMask='*'){\n    assert(TypeCheck.isSubClassOf(writerClass, Writer), 'Invalid writer type');\n\n    this._register(this._registeredWriters, writerClass, handlerName, handlerMask);\n  }\n\n  /**\n   * Returns the registered handler\n   *\n   * (it can be also done via {@link Handler.registeredHandler}).\n   *\n   * @param {string} handlerName - registered handler name\n   * @param {string} [handlerMask] - optional handler mask\n   * @return {Handler}\n   */\n  static get(handlerName, handlerMask='*'){\n    return this.registeredHandler(handlerName, handlerMask);\n  }\n\n  /**\n   * Returns the registered handler\n   *\n   * (it can be also done via {@link Handler.get})\n   *\n   * @param {string} handlerName - name of the registered handler type\n   * @param {string} [handlerMask='*'] - optional mask that supports a glob syntax used\n   * to match a custom registered handler\n   * @return {Handler}\n   */\n  static registeredHandler(handlerName, handlerMask='*'){\n    const result = this._registered(this._registeredHandlers, handlerName, handlerMask);\n\n    if (result){\n      return result;\n    }\n\n    throw new Error(`Handler ${handlerName} is not registered!`);\n  }\n\n  /**\n   * Returns the reader registered for the handler\n   *\n   * @param {string} handlerName - name of the registered handler type\n   * @param {string} [handlerMask='*'] - optional mask that supports a glob syntax used\n   * to match a custom registered handler\n   * @return {Reader}\n   */\n  static registeredReader(handlerName, handlerMask='*'){\n    const result = this._registered(this._registeredReaders, handlerName, handlerMask);\n\n    if (result){\n      return result;\n    }\n\n    throw new Error(`Reader is not registered for handler ${handlerName}!`);\n  }\n\n  /**\n   * Returns the writer registered for the handler\n   *\n   * @param {string} handlerName - name of the registered handler type\n   * @param {string} [handlerMask='*'] - optional mask that supports a glob syntax used\n   * to match a custom registered handler\n   * @return {Writer}\n   */\n  static registeredWriter(handlerName, handlerMask='*'){\n    const result = this._registered(this._registeredWriters, handlerName, handlerMask);\n\n    if (result){\n      return result;\n    }\n\n    throw new Error(`Writer is not registered for handler ${handlerName}!`);\n  }\n\n  /**\n   * Returns a list containing the names of the registered handler types\n   *\n   * @return {Array<string>}\n   */\n  static registeredHandlerNames(){\n    const result = new Set();\n\n    for (const [registeredHandleName] of this._registeredHandlers.keys()){\n      result.add(registeredHandleName);\n    }\n\n    return [...result];\n  }\n\n  /**\n   * Returns a list of registered handler makers for the input handler name\n   *\n   * @param {string} handlerName - registered handler name\n   * @return {Array<string>}\n   */\n  static registeredHandlerMasks(handlerName){\n    const result = [];\n\n    const normalizedName = handlerName.toLowerCase();\n\n    for (const [registeredHandleName, registeredMask] of this._registeredHandlers.keys()){\n      if (registeredHandleName === normalizedName){\n        result.push(registeredMask);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Grants the execution of the action through the handler\n   *\n   * @param {string} handlerName - registered name of the handler\n   * @param {string} actionName - registered action name\n   * @param {...args} args - custom args passed to {@link Handler._grantingAction}\n   */\n  static grantAction(handlerName, actionName, ...args){\n    assert(TypeCheck.isString(handlerName), 'handlerName needs to be defined as string');\n\n    // making sure the action is registered, otherwise throws an exception\n    Action.registeredAction(actionName);\n\n    const normalizedHandlerName = handlerName.toLowerCase();\n    const handlerMasks = this.registeredHandlerMasks(normalizedHandlerName);\n    for (const handleMask of handlerMasks){\n      const HandlerClass = this.registeredHandler(normalizedHandlerName, handleMask);\n      HandlerClass._grantingAction.call(HandlerClass, normalizedHandlerName, actionName, ...args);\n    }\n\n    assert(handlerMasks.length, `Handler ${handlerName} is not registered`);\n    if (!this._addedActions.has(normalizedHandlerName)){\n      this._addedActions.set(normalizedHandlerName, new Set());\n    }\n\n    this._addedActions.get(normalizedHandlerName).add(actionName.toLowerCase());\n  }\n\n  /**\n   * Returns a list granted actions for the input handler\n   *\n   * @param {string} handlerName - registered handler name\n   * @return {Array<string>}\n   */\n  static grantedActionNames(handlerName){\n    assert(TypeCheck.isString(handlerName), 'handlerName needs to be defined as string');\n\n    const normalizedHandlerName = handlerName.toLowerCase();\n\n    if (this._addedActions.has(normalizedHandlerName)){\n      return [...this._addedActions.get(normalizedHandlerName).values()];\n    }\n\n    return [];\n  }\n\n  /**\n   * Adds a listener to an exception raised during the {@link Handler.output} process.\n   * It can happen either during the serialization process ({@link Writer.serialize})\n   * or during the finalization of the session ({@link Session.finalize}).\n   * This event passes as argument: error, handlerName and handlerMask.\n   *\n   * Currently this event is static to make easy to hook it in your application,\n   * if none listener is registered to it then the error is thrown,\n   * a stack trace is printed, and the Node.js process exits.\n   *\n   * ```\n   * // registering a listener for the error\n   * Mebo.Handler.onErrorDuringOutput((err, handlerName, handlerMask => {\n   *    console.error(err.stack);\n   * }));\n   * ```\n   *\n   * @param {function} listener - listener function\n   */\n  static onErrorDuringOutput(listener){\n    this._outputEventEmitter.on('error', listener);\n  }\n\n  /**\n   * This method can be re-implemented by derived classes to hook when an {@link Action}\n   * is granted for a handler ({@link Handler.grantAction})\n   *\n   * @param {string} handlerName - registered handler name\n   * @param {string} actionName - registered action name\n   * @param {...args} args - custom args passed during {@link Handler.grantAction}\n   * @protected\n   */\n  static _grantingAction(handlerName, actionName, ...args){\n  }\n\n  /**\n   * Creates an instance of a reader for the current handler\n   *\n   * @param {Action} action - action instance used by the reader to parse the values\n   * @param {Object} options - plain object containing the options passed to the reader\n   * @param {...additionalArgs} additionalArgs - additional args passed to the\n   * constructor during factoring of the reader (should be used by derived classes)\n   * @return {Reader}\n   * @protected\n   */\n  _createReader(action, options, ...additionalArgs){\n    const ReaderClass = Handler.registeredReader(\n      this.meta('handler.name'),\n      this.meta('handler.mask'),\n    );\n\n    const reader = new ReaderClass(action, ...additionalArgs);\n\n    // passing options to the reader\n    for (const option in options){\n      reader.setOption(option, options[option]);\n    }\n\n    return reader;\n  }\n\n  /**\n   * Creates an instance of a writer for the current handler\n   *\n   * @param {*} value - arbitrary value passed to the writer\n   * @param {Object} options - plain object containing the options passed to the writer\n   * @param {...additionalArgs} additionalArgs - additional args passed to the\n   * constructor during factoring of the reader (should be used by derived classes)\n   * @return {Writer}\n   * @protected\n   */\n  _createWriter(value, options, ...additionalArgs){\n    const WriterClass = Handler.registeredWriter(\n      this.meta('handler.name'),\n      this.meta('handler.mask'),\n    );\n\n    const writer = new WriterClass(value, ...additionalArgs);\n\n    // passing options to the writer\n    for (const option in options){\n      writer.setOption(option, options[option]);\n    }\n\n    return writer;\n  }\n\n  /**\n   * Loads the {@link Reader} information to the {@link Action} and {@link Session}. This\n   * process is called during the execution ({@link Handler.runAction}).\n   *\n   * Changes done by this method to the action:\n   * - Assigns the {@link Handler.session} to the action ({@link Action.session})\n   * - Modifies the action input values based on the information collected by the reader\n   *\n   * Changes done by this method to the session:\n   * - Modifies the {@link Session.autofill} based on the information collected by the reader\n   * ({@link Reader.autofillValues})\n   *\n   * @param {Action} action - action that should be used\n   * @param {Object} options - options passed to the reader\n   * @private\n   */\n  async _load(action, options){\n\n    assert(action instanceof Action, 'Invalid action');\n\n    const readOptions = Utils.deepMerge(this.meta('readOptions', {}), options);\n    const reader = this._createReader(action, readOptions);\n\n    // collecting the reader values\n    const inputValues = await reader.inputValues();\n    const autofillValues = await reader.autofillValues();\n\n    // setting inputs\n    for (const inputName in inputValues){\n      action.input(inputName).setValue(inputValues[inputName]);\n    }\n\n    // setting autofill\n    const session = action.session();\n    for (const autofillName in autofillValues){\n      session.setAutofill(autofillName, autofillValues[autofillName]);\n    }\n  }\n\n  /**\n   * Auxiliary method used to get the registration of writers, readers and handlers.\n   *\n   * @param {Map} where - map used to find the registration\n   * @param {string} handlerName - name of the registered handler type\n   * @param {string} handlerMask - mask that supports a glob syntax used\n   * to match a custom registered handler\n   * @return {Handler|function}\n   *\n   * @private\n   */\n  static _registered(where, handlerName, handlerMask){\n    assert(TypeCheck.isString(handlerName), 'handlerName needs to be defined as string');\n    assert(TypeCheck.isString(handlerMask), 'mask needs to be defined as string');\n\n    let result = null;\n    const normalizedHandlerName = handlerName.toLowerCase();\n    const normalizedHandlerMask = handlerMask.toLowerCase();\n\n    for (const key of where.keys()){\n      if (key[0] === normalizedHandlerName && (key[1] === '*' || minimatch(normalizedHandlerMask, key[1]))){\n        result = where.get(key);\n        break;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n  * Auxiliary method that returns the handler name defined as metadata inside\n  * of the action, if not defined returns an empty string\n  *\n  * @param {Action} action - action that should be used\n  * @return {string}\n  * @private\n  */\n  _actionHandlerName(action){\n    let result = '';\n\n    const registeredHandlerName = this.meta('handler.name');\n    for (const handlerName in action.meta('handler', {})){\n\n      // the searching for the handler name (case insensitive)\n      if (handlerName.toLowerCase() === registeredHandlerName){\n        result = handlerName;\n        break;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Auxiliary method used for the registration of writers, readers and handlers\n   *\n   * @param {Map} where - map used to store the registration\n   * @param {Handler|function} what - data that should be stored\n   * @param {string} handlerName - name of the registered handler type\n   * @param {string} handlerMask - mask that supports a glob syntax used\n   * to match a custom registered handler\n   *\n   * @private\n   */\n  static _register(where, what, handlerName, handlerMask){\n    assert(TypeCheck.isString(handlerName), 'Invalid handler registration name!');\n    assert(TypeCheck.isString(handlerMask), 'handlerMask needs to be defined as string');\n    assert(handlerName.length, 'handlerName cannot be empty');\n    assert(handlerMask.length, 'handlerMask cannot be empty');\n\n    const normalilzeHandlerName = handlerName.toLowerCase();\n    const normalizedHandlerMask = handlerMask.toLowerCase();\n\n    // validating handler name\n    assert(normalilzeHandlerName.length, 'handler name cannot be empty');\n    assert((/^([\\w_\\.\\-])+$/gi).test(normalilzeHandlerName), `Invalid handler name: ${normalilzeHandlerName}`); // eslint-disable-line no-useless-escape\n\n    // since when querying registrations the new ones precede to the old ones,\n    // therefore the new ones are stored on the top of the pile, for this reason creating\n    // a temporary reversed map that will be used to include the new one\n    const currentData = new Map();\n    for (const key of Array.from(where.keys()).reverse()){\n\n      // if there is already an existing registration for it, skipping it\n      if (key[0] === normalilzeHandlerName && key[1] === normalizedHandlerMask){\n        continue;\n      }\n\n      currentData.set(key, where.get(key));\n    }\n\n    // including the new registration\n    currentData.set([normalilzeHandlerName, normalizedHandlerMask], what);\n\n    // reversing back the final order\n    where.clear();\n    for (const key of Array.from(currentData.keys()).reverse()){\n      where.set(key, currentData.get(key));\n    }\n  }\n\n  /**\n   * Emits the output error signal, it passes as argument: error, handler name\n   * and handler mask.\n   *\n   * @param {Error} err - exception used as critical error\n   */\n  _emitOutputError(err){\n    process.nextTick(() => {\n      this.constructor._outputEventEmitter.emit(\n        'error',\n        err,\n        this.meta('handler.name'),\n        this.meta('handler.mask'),\n      );\n    });\n  }\n\n  static _outputEventEmitter = new EventEmitter();\n\n  static _registeredHandlers = new Map();\n\n  static _registeredWriters = new Map();\n\n  static _registeredReaders = new Map();\n\n  static _addedActions = new Map();\n}\n\nmodule.exports = Handler;\n",
    "static": true,
    "longname": "src/Handler.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 91,
    "kind": "variable",
    "name": "__import_module__assert",
    "memberof": "src/Handler.js",
    "static": true,
    "longname": "src/Handler.js~__import_module__assert",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handler.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 92,
    "kind": "variable",
    "name": "__import_module__EventEmitter",
    "memberof": "src/Handler.js",
    "static": true,
    "longname": "src/Handler.js~__import_module__EventEmitter",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handler.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 93,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Handler.js",
    "static": true,
    "longname": "src/Handler.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handler.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 94,
    "kind": "variable",
    "name": "__import_module__minimatch",
    "memberof": "src/Handler.js",
    "static": true,
    "longname": "src/Handler.js~__import_module__minimatch",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handler.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 95,
    "kind": "variable",
    "name": "__import_module__Session",
    "memberof": "src/Handler.js",
    "static": true,
    "longname": "src/Handler.js~__import_module__Session",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handler.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 96,
    "kind": "variable",
    "name": "__import_module__Action",
    "memberof": "src/Handler.js",
    "static": true,
    "longname": "src/Handler.js~__import_module__Action",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handler.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 97,
    "kind": "variable",
    "name": "__import_module__Metadata",
    "memberof": "src/Handler.js",
    "static": true,
    "longname": "src/Handler.js~__import_module__Metadata",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handler.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 98,
    "kind": "variable",
    "name": "__import_module__Reader",
    "memberof": "src/Handler.js",
    "static": true,
    "longname": "src/Handler.js~__import_module__Reader",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handler.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 99,
    "kind": "variable",
    "name": "__import_module__Writer",
    "memberof": "src/Handler.js",
    "static": true,
    "longname": "src/Handler.js~__import_module__Writer",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handler.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 100,
    "kind": "variable",
    "name": "__import_module__Utils",
    "memberof": "src/Handler.js",
    "static": true,
    "longname": "src/Handler.js~__import_module__Utils",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handler.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 101,
    "kind": "variable",
    "name": "_session",
    "memberof": "src/Handler.js",
    "static": true,
    "longname": "src/Handler.js~_session",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handler.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 102,
    "kind": "variable",
    "name": "_metadata",
    "memberof": "src/Handler.js",
    "static": true,
    "longname": "src/Handler.js~_metadata",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handler.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 103,
    "kind": "class",
    "name": "Handler",
    "memberof": "src/Handler.js",
    "static": true,
    "longname": "src/Handler.js~Handler",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Handler.js",
    "importStyle": "Handler",
    "description": "A handler is used to bridge an execution method to Mebo.\n\nThe data used to perform the execution of action through a handler\n({@link Handler.runAction}) is parsed using a reader {@link Reader}.\n\nThe result of a handler is done through a {@link Writer}. Writers are designed\nto support reporting a success output and an error output as well. The way the\nresult is serialized is determined by the writer implementation\n({@link Writer._successOutput}, {@link Writer._errorOutput}). All writers\nshipped with Mebo have support for streams where in case of any readable stream\nor buffer value they are piped to the output, otherwise the result is encoded\nusing JSON.\n\nBoth reader and writer can be customized through options that can be either\ndefined through the action's metadata or directly through the handler. If you would\nlike to know more about the available options check out the respective\n{@link Reader} & {@link Writer} documentation for the handler implementation\nyou are interested.\n\nDefining options through actions (detailed information can be found at\n{@link Metadata}):\n```\n@Mebo.register('myAction')\nclass MyAction extends Mebo.Action{\n   constructor(){\n     super();\n\n     // change 'name' for the registration name of the handler you\n     // want to define the read & write options\n     this.setMeta('handler.name', {\n       readOptions: {\n         someReadOption: true,\n       },\n       writeOptions: {\n         someWriteOption: 10,\n       },\n     });\n   }\n}\n```\n\nDefining options directly through the handler:\n```\n// read options\nmyHandler.runAction('myAction', {\n someReadOption: true,\n})\n\n// write options\nmyHandler.output(value, {\n someWriteOption: 10,\n})\n```\n\nHandlers are created by their registration name ({@link Handler.register}),\nthe creation is done by {@link Handler.create}:\n\n```\n// creating a handle based on the handler registration name\nconst handler = Mebo.Handler.create('myHandler');\n\n// loading the parsed information to the action\nhandler.runAction('actionName').then((result) => {\n\n   // success output\n   handler.output(result);\n\n// error output\n}).catch((err) => {\n   handler.output(err);\n});\n```\n\n**Tip:** You can set the env variable `NODE_ENV=development` to get the\ntraceback information included in the error output.",
    "lineNumber": 95,
    "interface": false
  },
  {
    "__docId__": 104,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Handler.js~Handler#constructor",
    "access": null,
    "description": "Creates a Handler",
    "lineNumber": 100,
    "params": []
  },
  {
    "__docId__": 105,
    "kind": "member",
    "name": "[_metadata]",
    "memberof": "src/Handler.js~Handler",
    "static": false,
    "longname": "src/Handler.js~Handler#[_metadata]",
    "access": null,
    "description": null,
    "lineNumber": 101,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 106,
    "kind": "method",
    "name": "setSession",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Handler.js~Handler#setSession",
    "access": null,
    "description": "Associates a {@link Session} with the handler. The session assigned to\nthe handler is cloned during the assignment ({@link Session.clone}).",
    "lineNumber": 110,
    "params": [
      {
        "nullable": null,
        "types": [
          "Session"
        ],
        "spread": false,
        "optional": false,
        "name": "session",
        "description": "session object"
      }
    ]
  },
  {
    "__docId__": 107,
    "kind": "member",
    "name": "[_session]",
    "memberof": "src/Handler.js~Handler",
    "static": false,
    "longname": "src/Handler.js~Handler#[_session]",
    "access": null,
    "description": null,
    "lineNumber": 113,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 108,
    "kind": "method",
    "name": "session",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Handler.js~Handler#session",
    "access": null,
    "description": "Returns the session",
    "lineNumber": 121,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Session"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 109,
    "kind": "member",
    "name": "[_session]",
    "memberof": "src/Handler.js~Handler",
    "static": false,
    "longname": "src/Handler.js~Handler#[_session]",
    "access": null,
    "description": null,
    "lineNumber": 125,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 110,
    "kind": "method",
    "name": "meta",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Handler.js~Handler#meta",
    "access": null,
    "description": "Returns a value under the handler's metadata.",
    "lineNumber": 142,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "path about where the value is localized (the levels\nmust be separated by '.'). In case of an empty string it returns the\nentire metadata. The path can be defined using `option vars`\n({@link Metadata.optionVar})."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "defaultValue",
        "description": "default value returned in case a value was\nnot found for the path"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 111,
    "kind": "method",
    "name": "setMeta",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Handler.js~Handler#setMeta",
    "access": null,
    "description": "Sets a value to the handler's metadata.\n\nDetailed information about the metadata support can be found at\n{@link Metadata}.",
    "lineNumber": 162,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "path about where the value should be stored under the metadata\n(the levels must be separated by '.'). The path can be defined using `option vars`\n({@link Metadata.optionVar})."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value that is going to be stored under the collection"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "merge",
        "description": "this option is used to decide in case of the\nlast level is already existing under the collection, if the value should be\neither merged (default) or overridden."
      }
    ]
  },
  {
    "__docId__": 112,
    "kind": "method",
    "name": "runAction",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Handler.js~Handler#runAction",
    "access": null,
    "description": "Executes an action through the handler.\n\nThis process is done by creating an action that loads the information\nparsed by the {@link Reader}.\n\nAfter the construction of the action it looks for reading options that can\nbe defined as part of the action's metadata ({@link Action.metadata}) and\nwhen found they are passed to the reader. After the execution of the action\nit looks again inside of the action's metadata for writing options, which\nare later used during the output ({@link Handler.output}). To know how\nto define action's metadata for the handler take a look at the initial\ndocumentation about the {@link Handler}.",
    "lineNumber": 188,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "actionName",
        "description": "registered action name that should be executed"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "plain object containing the options that is passed\nto the {@link Reader}.\nfor the handler should be fetched."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "result of the action"
    }
  },
  {
    "__docId__": 113,
    "kind": "method",
    "name": "output",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Handler.js~Handler#output",
    "access": null,
    "description": "Results a value through the handler.\n\nIn case the value is an exception then it's treated as {@link Writer._errorOutput}\notherwise the value is treated as {@link Writer._successOutput}.\n\nWhen an action is executed through the handler ({@link Handler.runAction})\nit can define writing options that are used by the output. These\noptions are stored under the {@link Handler.metadata} where any options passed\ndirectly to the output method override them.\n\nIf `finalizeSession` is enabled (default) the {@link Handler.session} gets finalized\nat the end of the output process.\n\nBy default the {@link Writer._errorOutput} tries to handle the error as output.\nHowever you can tell a writer to do not handle specific errors, by doing that the writer\nwill raise the errors instead of trying to handle them. This can be achieved\nby having `output` defined as member of the error (`error.output = false`),\nfurther information can be found at the error output documentation\n({@link Writer._errorOutput}).\n\nIn case of any error raised during the output process the handler emits the signal\n{@link Handler.onErrorDuringOutput}.",
    "lineNumber": 258,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "raw value that should be resulted by the handler"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "plain object containing options that should be used\nby the output where each handler implementation contains their own set of options."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "finalizeSession",
        "description": "tells if it should finalize the session\n({@link Session.finalize})"
      }
    ]
  },
  {
    "__docId__": 114,
    "kind": "method",
    "name": "create",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handler.js~Handler.create",
    "access": null,
    "description": "Creates a handler based on the registered name\n\nAlternatively this method can be called directly from Mebo as `Mebo.Handler.create(...)`\n\nAlso, the handler name gets included in the session as arbitrary data, it can be\nretrieved through 'handler'. This name follows the registration pattern where this\nvalue is represented in lowercase internally:\n```\nSession.get('handler');\n```",
    "lineNumber": 299,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "handlerName",
        "description": "registered handler name"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'*'",
        "defaultRaw": "'*'",
        "name": "mask",
        "description": "optional mask that supports a glob syntax used\nto match a custom registered handler (it allows to have\ncustom handler implementations for specific masks)"
      },
      {
        "nullable": null,
        "types": [
          "...args"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "custom args passed to the constructor during factoring"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Handler"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 115,
    "kind": "method",
    "name": "register",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handler.js~Handler.register",
    "access": null,
    "description": "Register an {@link Handler} type to the available handlers",
    "lineNumber": 327,
    "params": [
      {
        "nullable": null,
        "types": [
          "Handler"
        ],
        "spread": false,
        "optional": false,
        "name": "handlerClass",
        "description": "handler implementation that will be registered"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "handlerName",
        "description": "string containing the registration name for the\nhandler. In case of an empty string, the registration is done by using the name\nof the type (this information is stored in lowercase)"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'*'",
        "defaultRaw": "'*'",
        "name": "handlerMask",
        "description": "optional mask that supports a glob syntax used\nto match a custom registered handler (it allows to have\ncustom handler implementations for specific masks)"
      }
    ]
  },
  {
    "__docId__": 116,
    "kind": "method",
    "name": "registerReader",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handler.js~Handler.registerReader",
    "access": null,
    "description": "Register a {@link Reader} for the handler",
    "lineNumber": 343,
    "params": [
      {
        "nullable": null,
        "types": [
          "Reader"
        ],
        "spread": false,
        "optional": false,
        "name": "readerClass",
        "description": "reader class"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "handlerName",
        "description": "registered handler name"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'*'",
        "defaultRaw": "'*'",
        "name": "handlerMask",
        "description": "optional mask that supports a glob syntax used\nto match a custom registered handler (it allows to have\ncustom handler implementations for specific masks)"
      }
    ]
  },
  {
    "__docId__": 117,
    "kind": "method",
    "name": "registerWriter",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handler.js~Handler.registerWriter",
    "access": null,
    "description": "Register a {@link Writer} for the handler",
    "lineNumber": 358,
    "params": [
      {
        "nullable": null,
        "types": [
          "Writer"
        ],
        "spread": false,
        "optional": false,
        "name": "writerClass",
        "description": "writer class"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "handlerName",
        "description": "registered handler name"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'*'",
        "defaultRaw": "'*'",
        "name": "handlerMask",
        "description": "optional mask that supports a glob syntax used\nto match a custom registered handler (it allows to have\ncustom handler implementations for specific masks)"
      }
    ]
  },
  {
    "__docId__": 118,
    "kind": "method",
    "name": "get",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handler.js~Handler.get",
    "access": null,
    "description": "Returns the registered handler\n\n(it can be also done via {@link Handler.registeredHandler}).",
    "lineNumber": 373,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "handlerName",
        "description": "registered handler name"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "handlerMask",
        "description": "optional handler mask"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Handler"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 119,
    "kind": "method",
    "name": "registeredHandler",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handler.js~Handler.registeredHandler",
    "access": null,
    "description": "Returns the registered handler\n\n(it can be also done via {@link Handler.get})",
    "lineNumber": 387,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "handlerName",
        "description": "name of the registered handler type"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'*'",
        "defaultRaw": "'*'",
        "name": "handlerMask",
        "description": "optional mask that supports a glob syntax used\nto match a custom registered handler"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Handler"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 120,
    "kind": "method",
    "name": "registeredReader",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handler.js~Handler.registeredReader",
    "access": null,
    "description": "Returns the reader registered for the handler",
    "lineNumber": 405,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "handlerName",
        "description": "name of the registered handler type"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'*'",
        "defaultRaw": "'*'",
        "name": "handlerMask",
        "description": "optional mask that supports a glob syntax used\nto match a custom registered handler"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Reader"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 121,
    "kind": "method",
    "name": "registeredWriter",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handler.js~Handler.registeredWriter",
    "access": null,
    "description": "Returns the writer registered for the handler",
    "lineNumber": 423,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "handlerName",
        "description": "name of the registered handler type"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'*'",
        "defaultRaw": "'*'",
        "name": "handlerMask",
        "description": "optional mask that supports a glob syntax used\nto match a custom registered handler"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Writer"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 122,
    "kind": "method",
    "name": "registeredHandlerNames",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handler.js~Handler.registeredHandlerNames",
    "access": null,
    "description": "Returns a list containing the names of the registered handler types",
    "lineNumber": 438,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 123,
    "kind": "method",
    "name": "registeredHandlerMasks",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handler.js~Handler.registeredHandlerMasks",
    "access": null,
    "description": "Returns a list of registered handler makers for the input handler name",
    "lineNumber": 454,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "handlerName",
        "description": "registered handler name"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 124,
    "kind": "method",
    "name": "grantAction",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handler.js~Handler.grantAction",
    "access": null,
    "description": "Grants the execution of the action through the handler",
    "lineNumber": 475,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "handlerName",
        "description": "registered name of the handler"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "actionName",
        "description": "registered action name"
      },
      {
        "nullable": null,
        "types": [
          "...args"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "custom args passed to {@link Handler._grantingAction}"
      }
    ]
  },
  {
    "__docId__": 125,
    "kind": "method",
    "name": "grantedActionNames",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handler.js~Handler.grantedActionNames",
    "access": null,
    "description": "Returns a list granted actions for the input handler",
    "lineNumber": 502,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "handlerName",
        "description": "registered handler name"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 126,
    "kind": "method",
    "name": "onErrorDuringOutput",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handler.js~Handler.onErrorDuringOutput",
    "access": null,
    "description": "Adds a listener to an exception raised during the {@link Handler.output} process.\nIt can happen either during the serialization process ({@link Writer.serialize})\nor during the finalization of the session ({@link Session.finalize}).\nThis event passes as argument: error, handlerName and handlerMask.\n\nCurrently this event is static to make easy to hook it in your application,\nif none listener is registered to it then the error is thrown,\na stack trace is printed, and the Node.js process exits.\n\n```\n// registering a listener for the error\nMebo.Handler.onErrorDuringOutput((err, handlerName, handlerMask => {\n   console.error(err.stack);\n}));\n```",
    "lineNumber": 533,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "listener",
        "description": "listener function"
      }
    ]
  },
  {
    "__docId__": 127,
    "kind": "method",
    "name": "_grantingAction",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handler.js~Handler._grantingAction",
    "access": "protected",
    "description": "This method can be re-implemented by derived classes to hook when an {@link Action}\nis granted for a handler ({@link Handler.grantAction})",
    "lineNumber": 546,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "handlerName",
        "description": "registered handler name"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "actionName",
        "description": "registered action name"
      },
      {
        "nullable": null,
        "types": [
          "...args"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "custom args passed during {@link Handler.grantAction}"
      }
    ]
  },
  {
    "__docId__": 128,
    "kind": "method",
    "name": "_createReader",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Handler.js~Handler#_createReader",
    "access": "protected",
    "description": "Creates an instance of a reader for the current handler",
    "lineNumber": 559,
    "params": [
      {
        "nullable": null,
        "types": [
          "Action"
        ],
        "spread": false,
        "optional": false,
        "name": "action",
        "description": "action instance used by the reader to parse the values"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "plain object containing the options passed to the reader"
      },
      {
        "nullable": null,
        "types": [
          "...additionalArgs"
        ],
        "spread": true,
        "optional": false,
        "name": "additionalArgs",
        "description": "additional args passed to the\nconstructor during factoring of the reader (should be used by derived classes)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Reader"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 129,
    "kind": "method",
    "name": "_createWriter",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Handler.js~Handler#_createWriter",
    "access": "protected",
    "description": "Creates an instance of a writer for the current handler",
    "lineNumber": 585,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "arbitrary value passed to the writer"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "plain object containing the options passed to the writer"
      },
      {
        "nullable": null,
        "types": [
          "...additionalArgs"
        ],
        "spread": true,
        "optional": false,
        "name": "additionalArgs",
        "description": "additional args passed to the\nconstructor during factoring of the reader (should be used by derived classes)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Writer"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 130,
    "kind": "method",
    "name": "_load",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Handler.js~Handler#_load",
    "access": "private",
    "description": "Loads the {@link Reader} information to the {@link Action} and {@link Session}. This\nprocess is called during the execution ({@link Handler.runAction}).\n\nChanges done by this method to the action:\n- Assigns the {@link Handler.session} to the action ({@link Action.session})\n- Modifies the action input values based on the information collected by the reader\n\nChanges done by this method to the session:\n- Modifies the {@link Session.autofill} based on the information collected by the reader\n({@link Reader.autofillValues})",
    "lineNumber": 617,
    "params": [
      {
        "nullable": null,
        "types": [
          "Action"
        ],
        "spread": false,
        "optional": false,
        "name": "action",
        "description": "action that should be used"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "options passed to the reader"
      }
    ]
  },
  {
    "__docId__": 131,
    "kind": "method",
    "name": "_registered",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handler.js~Handler._registered",
    "access": "private",
    "description": "Auxiliary method used to get the registration of writers, readers and handlers.",
    "lineNumber": 651,
    "params": [
      {
        "nullable": null,
        "types": [
          "Map"
        ],
        "spread": false,
        "optional": false,
        "name": "where",
        "description": "map used to find the registration"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "handlerName",
        "description": "name of the registered handler type"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "handlerMask",
        "description": "mask that supports a glob syntax used\nto match a custom registered handler"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Handler",
        "function"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 132,
    "kind": "method",
    "name": "_actionHandlerName",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Handler.js~Handler#_actionHandlerName",
    "access": "private",
    "description": "Auxiliary method that returns the handler name defined as metadata inside\nof the action, if not defined returns an empty string",
    "lineNumber": 677,
    "params": [
      {
        "nullable": null,
        "types": [
          "Action"
        ],
        "spread": false,
        "optional": false,
        "name": "action",
        "description": "action that should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 133,
    "kind": "method",
    "name": "_register",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handler.js~Handler._register",
    "access": "private",
    "description": "Auxiliary method used for the registration of writers, readers and handlers",
    "lineNumber": 704,
    "params": [
      {
        "nullable": null,
        "types": [
          "Map"
        ],
        "spread": false,
        "optional": false,
        "name": "where",
        "description": "map used to store the registration"
      },
      {
        "nullable": null,
        "types": [
          "Handler",
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "what",
        "description": "data that should be stored"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "handlerName",
        "description": "name of the registered handler type"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "handlerMask",
        "description": "mask that supports a glob syntax used\nto match a custom registered handler"
      }
    ]
  },
  {
    "__docId__": 134,
    "kind": "method",
    "name": "_emitOutputError",
    "memberof": "src/Handler.js~Handler",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Handler.js~Handler#_emitOutputError",
    "access": null,
    "description": "Emits the output error signal, it passes as argument: error, handler name\nand handler mask.",
    "lineNumber": 747,
    "params": [
      {
        "nullable": null,
        "types": [
          "Error"
        ],
        "spread": false,
        "optional": false,
        "name": "err",
        "description": "exception used as critical error"
      }
    ]
  },
  {
    "__docId__": 135,
    "kind": "member",
    "name": "_outputEventEmitter",
    "memberof": "src/Handler.js~Handler",
    "static": true,
    "longname": "src/Handler.js~Handler._outputEventEmitter",
    "access": null,
    "description": null,
    "lineNumber": 758,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 136,
    "kind": "member",
    "name": "_registeredHandlers",
    "memberof": "src/Handler.js~Handler",
    "static": true,
    "longname": "src/Handler.js~Handler._registeredHandlers",
    "access": null,
    "description": null,
    "lineNumber": 760,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 137,
    "kind": "member",
    "name": "_registeredWriters",
    "memberof": "src/Handler.js~Handler",
    "static": true,
    "longname": "src/Handler.js~Handler._registeredWriters",
    "access": null,
    "description": null,
    "lineNumber": 762,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 138,
    "kind": "member",
    "name": "_registeredReaders",
    "memberof": "src/Handler.js~Handler",
    "static": true,
    "longname": "src/Handler.js~Handler._registeredReaders",
    "access": null,
    "description": null,
    "lineNumber": 764,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 139,
    "kind": "member",
    "name": "_addedActions",
    "memberof": "src/Handler.js~Handler",
    "static": true,
    "longname": "src/Handler.js~Handler._addedActions",
    "access": null,
    "description": null,
    "lineNumber": 766,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 140,
    "kind": "file",
    "name": "src/Handlers/Cli.js",
    "content": "const stream = require('stream');\nconst assert = require('assert');\nconst TypeCheck = require('js-typecheck');\nconst Input = require('../Input');\nconst Metadata = require('../Metadata');\nconst Handler = require('../Handler');\n\n// symbols used for private instance variables to avoid any potential clashing\n// caused by re-implementations\nconst _args = Symbol('args');\nconst _stdout = Symbol('stdout');\nconst _stderr = Symbol('stderr');\n\n// handler name (used for registration)\nconst _handlerName = 'cli';\n\n\n/**\n* Handles the command line integration based on docopt specification.\n*\n* It enables the execution of actions triggered as command line applications\n* by reading ({@link CliArgs}) the arguments which are passed to the action\n* during the execution ({@link Cli.run}).\n* The result of this handler ({@link Cli.output}) is done through\n* the {@link CliOutput} writer.\n*\n* Using cli handler:\n*\n* **Creating an action that is going be executed through the cli handler**\n* ```\n* @Mebo.grant('cli')\n* @Mebo.register('myAction')\n* class MyAction extends Mebo.Action{\n*   constructor(){\n*     super();\n*     this.createInput('myArgument: text', {elementType: 'argument', description: 'my argument'});\n*     this.createInput('myOption: bool', {description: 'my option'});\n*   }\n*\n*   _perform(data){\n*     const result = {\n*       myArgument: data.myArgument,\n*       myOption: data.myOption,\n*     };\n*     return Promise.resolve(result);\n*   }\n* }\n*\n* ```\n*\n* **Executing the action through the handler**\n* ```\n* // making sure the script is called directly\n* if (require.main === module) {\n*\n*   // creating an cli handler which is used to load the arguments\n*   // arguments to the action and to output the result back to the stream\n*   const cli = Mebo.Handler.create('cli');\n*\n*   // loading the parsed information to the action\n*   cli.runAction('myAction', {description: 'Welcome'}).then((result) => {\n*\n*   // success output\n*   cli.output(result);\n*\n*   // error output\n*   }).catch((err) => {\n*     cli.output(err);\n*   });\n* }\n* ```\n* You can list the cli help by invoking `-h` or `--help` where a help interface\n* is generated automatically for the action, for instance:\n*\n* `node mycli.js --help`\n* ```\n* Welcome.\n*\n* Usage: mycli.js [options] <my-argument>\n*\n* Arguments:\n*   my-argument  my argument (text type).\n*\n* Options:\n*   --my-option    my option (bool type).\n* ```\n*\n* In case you want to provide multiple actions through cli, take\n* a look at the example: https://github.com/meboHQ/example-cli\n*\n* @see http://docopt.org\n*/\nclass Cli extends Handler{\n\n  /**\n   * Creates an cli handler\n   *\n   * @param {Array<string>} argv - argument list\n   * @param {stream} stdout - stream used as stdout\n   * @param {stream} stderr - stream used as stderr\n   */\n  constructor(argv=process.argv, stdout=process.stdout, stderr=process.stderr){\n    super();\n\n    this.setArgs(argv);\n    this.setStdout(stdout);\n    this.setStderr(stderr);\n  }\n\n  /**\n   * Sets a list of argument values used by the reader. It must follow\n   * the same pattern found at `process.argv`\n   *\n   * @param {Array<string>} value - argument list\n   */\n  setArgs(value){\n    assert(TypeCheck.isList(value), 'value needs to be a list');\n    assert(value.length >= 2, 'missing first argument process.execPath and second argument javaScript file being executed');\n\n    this[_args] = value.slice(0);\n  }\n\n  /**\n   * Returns a list of argument values used by the reader, by default it uses\n   * `process.argv`.\n   *\n   * @return {Array<string>}\n   */\n  args(){\n    return this[_args];\n  }\n\n  /**\n   * Sets the stdout stream\n   *\n   * @param {stream} value - stream used as stdout\n   */\n  setStdout(value){\n    assert(value instanceof stream, 'Invalid stream type');\n\n    this[_stdout] = value;\n  }\n\n  /**\n   * Returns the stream used as stdout\n   *\n   * @return {stream}\n   */\n  stdout(){\n    return this[_stdout];\n  }\n\n  /**\n   * Sets the stderr stream\n   *\n   * @param {stream} value - stream used as stderr\n   */\n  setStderr(value){\n    assert(value instanceof stream, 'Invalid stream type');\n\n    this[_stderr] = value;\n  }\n\n  /**\n   * Returns the stream used as stderr\n   *\n   * @return {stream}\n   */\n  stderr(){\n    return this[_stderr];\n  }\n\n  /**\n   * Initializes a registered action as cli.\n   *\n   * *`CliActions/Default.js`: defining an action as cli:*\n   * ```\n   * const Mebo = require('mebo');\n   *\n   * class Default extends Mebo.Action{\n   *\n   *  constructor(){\n   *   super();\n   *     this.createInput('name: text');\n   *     this.createInput('myOtherInput?: numeric');\n   *  }\n   *  _perform(data){\n   *    // ...\n   *  }\n   * }\n   *\n   * Mebo.Action.register(Default, 'cli.default');\n   * Mebo.Handler.grantAction('cli', 'cli.default', {initName: 'default'});\n   * ```\n   *\n   * *`index.js`:*\n   * ```\n   * const Mebo = require('mebo');\n   * require('Clis/Default.js');\n   *\n   * // ...\n   *\n   * Mebo.Handler.get('cli').init('default');\n   * ```\n   *\n   * *Listing available actions:*\n   * ```\n   * node myFile.js --cli\n   * // or\n   * node myFile.js --cli --help\n   * ```\n   *\n   * *Showing help from the app:*\n   * ```\n   * node myFile.js --cli myCli --help\n   * ```\n   *\n   * *Executing an cli by specifying custom args:*\n   * ```\n   * node myFile.js --cli myCli --arg-a=1 --arg-b=2\n   * ```\n   *\n   * @param {string} defaultCliName - default name used when none\n   * cli is specified through `--cli <name>`\n   * @param {Object} options - plain object containing custom options\n   * @param {Array<string>} [options.argv] - custom list of arguments, if not specified\n   * it uses the `process.argv` (this information is passed to the creation of cli handler)\n   * @param {stream} [options.stdout] - custom writable stream, if not specified it uses\n   * `process.stdout` (this information is passed to the creation of cli handler)\n   * @param {stream} [options.stderr] - custom writable stream, if not specified it uses\n   * `process.stderr` (this information is passed to the creation of cli handler)\n   * @param {function} [options.initializedCallback] - callback executed when the\n   * initialization is done, it passes the value used by the output\n   */\n  static init(\n    defaultCliName,\n    {\n      argv=process.argv,\n      stdout=process.stdout,\n      stderr=process.stderr,\n      initializedCallback=null,\n    }={},\n  ){\n\n    assert(TypeCheck.isString(defaultCliName), 'defaultCliName needs to be defined as string');\n\n    const cliIndex = argv.indexOf('--cli');\n    const parsedArgs = [...argv.slice(0, 2), ...((cliIndex !== -1) ? argv.slice(cliIndex + 2) : [])];\n    const handler = Handler.create(_handlerName, '*', parsedArgs, stdout, stderr);\n\n    const _handlerOutput = (value) => {\n      try{\n        handler.output(value);\n      }\n      finally{\n        if (initializedCallback){\n          initializedCallback(value);\n        }\n      }\n    };\n\n    let useCliName = (cliIndex !== -1) ? argv[cliIndex + 1] : defaultCliName;\n    if (useCliName){\n      useCliName = useCliName.toLowerCase();\n    }\n\n    // list the available action names grated for cli\n    const availableClis = this._initNames[_handlerName] || {};\n    if (['-h', '--help', undefined].includes(useCliName)){\n      const result = [];\n      result.push('Available actions granted for command-line:');\n      const initNames = Object.keys(availableClis);\n\n      for (const initName of initNames.sort()){\n        const defaultCli = (initName === defaultCliName) ? '(Default)' : '';\n\n        const item = (defaultCli.length) ? '' : '';\n        result.push(`  ${item} ${initName} ${defaultCli}`);\n      }\n\n      const error = new Error(result.join('\\n'));\n      error.status = 700;\n      _handlerOutput(error);\n    }\n    // cli not found\n    else if (!(useCliName in availableClis)){\n\n      const error = new Error(`Could not initialize '${useCliName}', cli not found!`);\n      error.status = 700;\n      _handlerOutput(error);\n    }\n    // found cli, initializing from it\n    else{\n      handler.runAction(availableClis[useCliName]).then((result) => {\n        _handlerOutput(result);\n      }).catch(/* istanbul ignore next */ (err) => {\n        _handlerOutput(err);\n      });\n    }\n  }\n\n  /**\n   * This method can be re-implemented by derived classes to hook when an {@link Action}\n   * is granted for a handler ({@link Handler.grantAction})\n   *\n   * @param {string} handlerName - registered handler name\n   * @param {string} actionName - registered action name\n   * @param {object} options - custom options passed during {@link Handler.grantAction}\n   * @param {string} [options.initName] - custom name used to initialize the cli, otherwise\n   * if not defined the actionName is used instead\n   * @protected\n   */\n  static _grantingAction(handlerName, actionName, {initName=null}={}){\n\n    const useInitName = (initName || actionName);\n    assert(TypeCheck.isString(useInitName), 'initName needs to be defined as string');\n\n    if (!(handlerName in this._initNames)){\n      this._initNames[handlerName] = {};\n    }\n\n    this._initNames[handlerName][useInitName] = actionName;\n  }\n\n  /**\n   * Creates an instance of a reader for the current handler.\n   * This passes the {@link Cli.args} to the reader.\n   *\n   * @param {Action} action - action instance used by the reader to parse the values\n   * @param {Object} options - plain object containing the options passed to the reader\n   * @return {Reader}\n   * @protected\n   */\n  _createReader(action, options){\n\n    return super._createReader(\n      action,\n      options,\n      this.args(),\n    );\n  }\n\n  /**\n   * Creates an instance of a writer for the current handler\n   *\n   * This passes the {@link Cli.stdout} and {@link Cli.stderr}\n   * to the writer.\n   *\n   * @param {*} value - arbitrary value passed to the writer\n   * @param {Object} options - plain object containing the options passed to the writer\n   * @return {Writer}\n   * @protected\n   */\n  _createWriter(value, options){\n\n    return super._createWriter(\n      value,\n      options,\n      this.stdout(),\n      this.stderr(),\n    );\n  }\n\n  static _initNames = {};\n}\n\n// registering properties\nInput.registerProperty(Input, 'elementType', 'option');\nInput.registerProperty(Input, 'shortOption');\n\n// registering option vars\nMetadata.registerOptionVar('$cli', `handler.${_handlerName}`);\nMetadata.registerOptionVar('$cliDescription', '$cli.readOptions.description');\nMetadata.registerOptionVar('$cliResult', '$cli.writeOptions.result');\n\n// registering handler\nHandler.register(Cli, _handlerName);\n\nmodule.exports = Cli;\n",
    "static": true,
    "longname": "src/Handlers/Cli.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 141,
    "kind": "variable",
    "name": "__import_module__stream",
    "memberof": "src/Handlers/Cli.js",
    "static": true,
    "longname": "src/Handlers/Cli.js~__import_module__stream",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handlers/Cli.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 142,
    "kind": "variable",
    "name": "__import_module__assert",
    "memberof": "src/Handlers/Cli.js",
    "static": true,
    "longname": "src/Handlers/Cli.js~__import_module__assert",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handlers/Cli.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 143,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Handlers/Cli.js",
    "static": true,
    "longname": "src/Handlers/Cli.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handlers/Cli.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 144,
    "kind": "variable",
    "name": "__import_module__Input",
    "memberof": "src/Handlers/Cli.js",
    "static": true,
    "longname": "src/Handlers/Cli.js~__import_module__Input",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handlers/Cli.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 145,
    "kind": "variable",
    "name": "__import_module__Metadata",
    "memberof": "src/Handlers/Cli.js",
    "static": true,
    "longname": "src/Handlers/Cli.js~__import_module__Metadata",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handlers/Cli.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 146,
    "kind": "variable",
    "name": "__import_module__Handler",
    "memberof": "src/Handlers/Cli.js",
    "static": true,
    "longname": "src/Handlers/Cli.js~__import_module__Handler",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handlers/Cli.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 147,
    "kind": "variable",
    "name": "_args",
    "memberof": "src/Handlers/Cli.js",
    "static": true,
    "longname": "src/Handlers/Cli.js~_args",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handlers/Cli.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 148,
    "kind": "variable",
    "name": "_stdout",
    "memberof": "src/Handlers/Cli.js",
    "static": true,
    "longname": "src/Handlers/Cli.js~_stdout",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handlers/Cli.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 149,
    "kind": "variable",
    "name": "_stderr",
    "memberof": "src/Handlers/Cli.js",
    "static": true,
    "longname": "src/Handlers/Cli.js~_stderr",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handlers/Cli.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 150,
    "kind": "variable",
    "name": "_handlerName",
    "memberof": "src/Handlers/Cli.js",
    "static": true,
    "longname": "src/Handlers/Cli.js~_handlerName",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handlers/Cli.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 151,
    "kind": "class",
    "name": "Cli",
    "memberof": "src/Handlers/Cli.js",
    "static": true,
    "longname": "src/Handlers/Cli.js~Cli",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Handlers/Cli.js",
    "importStyle": "Cli",
    "description": "Handles the command line integration based on docopt specification.\n\nIt enables the execution of actions triggered as command line applications\nby reading ({@link CliArgs}) the arguments which are passed to the action\nduring the execution ({@link Cli.run}).\nThe result of this handler ({@link Cli.output}) is done through\nthe {@link CliOutput} writer.\n\nUsing cli handler:\n\n**Creating an action that is going be executed through the cli handler**\n```\n@Mebo.grant('cli')\n@Mebo.register('myAction')\nclass MyAction extends Mebo.Action{\n  constructor(){\n    super();\n    this.createInput('myArgument: text', {elementType: 'argument', description: 'my argument'});\n    this.createInput('myOption: bool', {description: 'my option'});\n  }\n\n  _perform(data){\n    const result = {\n      myArgument: data.myArgument,\n      myOption: data.myOption,\n    };\n    return Promise.resolve(result);\n  }\n}\n\n```\n\n**Executing the action through the handler**\n```\n// making sure the script is called directly\nif (require.main === module) {\n\n  // creating an cli handler which is used to load the arguments\n  // arguments to the action and to output the result back to the stream\n  const cli = Mebo.Handler.create('cli');\n\n  // loading the parsed information to the action\n  cli.runAction('myAction', {description: 'Welcome'}).then((result) => {\n\n  // success output\n  cli.output(result);\n\n  // error output\n  }).catch((err) => {\n    cli.output(err);\n  });\n}\n```\nYou can list the cli help by invoking `-h` or `--help` where a help interface\nis generated automatically for the action, for instance:\n\n`node mycli.js --help`\n```\nWelcome.\n\nUsage: mycli.js [options] <my-argument>\n\nArguments:\n  my-argument  my argument (text type).\n\nOptions:\n  --my-option    my option (bool type).\n```\n\nIn case you want to provide multiple actions through cli, take\na look at the example: https://github.com/meboHQ/example-cli",
    "see": [
      "http://docopt.org"
    ],
    "lineNumber": 93,
    "interface": false,
    "extends": [
      "Handler"
    ]
  },
  {
    "__docId__": 152,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Handlers/Cli.js~Cli",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Handlers/Cli.js~Cli#constructor",
    "access": null,
    "description": "Creates an cli handler",
    "lineNumber": 102,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "argv",
        "description": "argument list"
      },
      {
        "nullable": null,
        "types": [
          "stream"
        ],
        "spread": false,
        "optional": false,
        "name": "stdout",
        "description": "stream used as stdout"
      },
      {
        "nullable": null,
        "types": [
          "stream"
        ],
        "spread": false,
        "optional": false,
        "name": "stderr",
        "description": "stream used as stderr"
      }
    ]
  },
  {
    "__docId__": 153,
    "kind": "method",
    "name": "setArgs",
    "memberof": "src/Handlers/Cli.js~Cli",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Handlers/Cli.js~Cli#setArgs",
    "access": null,
    "description": "Sets a list of argument values used by the reader. It must follow\nthe same pattern found at `process.argv`",
    "lineNumber": 116,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "argument list"
      }
    ]
  },
  {
    "__docId__": 154,
    "kind": "member",
    "name": "[_args]",
    "memberof": "src/Handlers/Cli.js~Cli",
    "static": false,
    "longname": "src/Handlers/Cli.js~Cli#[_args]",
    "access": null,
    "description": null,
    "lineNumber": 120,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 155,
    "kind": "method",
    "name": "args",
    "memberof": "src/Handlers/Cli.js~Cli",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Handlers/Cli.js~Cli#args",
    "access": null,
    "description": "Returns a list of argument values used by the reader, by default it uses\n`process.argv`.",
    "lineNumber": 129,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 156,
    "kind": "method",
    "name": "setStdout",
    "memberof": "src/Handlers/Cli.js~Cli",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Handlers/Cli.js~Cli#setStdout",
    "access": null,
    "description": "Sets the stdout stream",
    "lineNumber": 138,
    "params": [
      {
        "nullable": null,
        "types": [
          "stream"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "stream used as stdout"
      }
    ]
  },
  {
    "__docId__": 157,
    "kind": "member",
    "name": "[_stdout]",
    "memberof": "src/Handlers/Cli.js~Cli",
    "static": false,
    "longname": "src/Handlers/Cli.js~Cli#[_stdout]",
    "access": null,
    "description": null,
    "lineNumber": 141,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 158,
    "kind": "method",
    "name": "stdout",
    "memberof": "src/Handlers/Cli.js~Cli",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Handlers/Cli.js~Cli#stdout",
    "access": null,
    "description": "Returns the stream used as stdout",
    "lineNumber": 149,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "stream"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 159,
    "kind": "method",
    "name": "setStderr",
    "memberof": "src/Handlers/Cli.js~Cli",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Handlers/Cli.js~Cli#setStderr",
    "access": null,
    "description": "Sets the stderr stream",
    "lineNumber": 158,
    "params": [
      {
        "nullable": null,
        "types": [
          "stream"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "stream used as stderr"
      }
    ]
  },
  {
    "__docId__": 160,
    "kind": "member",
    "name": "[_stderr]",
    "memberof": "src/Handlers/Cli.js~Cli",
    "static": false,
    "longname": "src/Handlers/Cli.js~Cli#[_stderr]",
    "access": null,
    "description": null,
    "lineNumber": 161,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 161,
    "kind": "method",
    "name": "stderr",
    "memberof": "src/Handlers/Cli.js~Cli",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Handlers/Cli.js~Cli#stderr",
    "access": null,
    "description": "Returns the stream used as stderr",
    "lineNumber": 169,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "stream"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 162,
    "kind": "method",
    "name": "init",
    "memberof": "src/Handlers/Cli.js~Cli",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handlers/Cli.js~Cli.init",
    "access": null,
    "description": "Initializes a registered action as cli.\n\n*`CliActions/Default.js`: defining an action as cli:*\n```\nconst __import_module__Mebo = require('mebo');\n\nclass Default extends Mebo.Action{\n\n constructor(){\n  super();\n    this.createInput('name: text');\n    this.createInput('myOtherInput?: numeric');\n }\n _perform(data){\n   // ...\n }\n}\n\nMebo.Action.register(Default, 'cli.default');\nMebo.Handler.grantAction('cli', 'cli.default', {initName: 'default'});\n```\n\n*`index.js`:*\n```\nconst __import_module__Mebo = require('mebo');\nrequire('Clis/Default.js');\n\n// ...\n\nMebo.Handler.get('cli').init('default');\n```\n\n*Listing available actions:*\n```\nnode myFile.js --cli\n// or\nnode myFile.js --cli --help\n```\n\n*Showing help from the app:*\n```\nnode myFile.js --cli myCli --help\n```\n\n*Executing an cli by specifying custom args:*\n```\nnode myFile.js --cli myCli --arg-a=1 --arg-b=2\n```",
    "lineNumber": 235,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "defaultCliName",
        "description": "default name used when none\ncli is specified through `--cli <name>`"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "plain object containing custom options"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": true,
        "name": "options.argv",
        "description": "custom list of arguments, if not specified\nit uses the `process.argv` (this information is passed to the creation of cli handler)"
      },
      {
        "nullable": null,
        "types": [
          "stream"
        ],
        "spread": false,
        "optional": true,
        "name": "options.stdout",
        "description": "custom writable stream, if not specified it uses\n`process.stdout` (this information is passed to the creation of cli handler)"
      },
      {
        "nullable": null,
        "types": [
          "stream"
        ],
        "spread": false,
        "optional": true,
        "name": "options.stderr",
        "description": "custom writable stream, if not specified it uses\n`process.stderr` (this information is passed to the creation of cli handler)"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "options.initializedCallback",
        "description": "callback executed when the\ninitialization is done, it passes the value used by the output"
      }
    ]
  },
  {
    "__docId__": 163,
    "kind": "method",
    "name": "_grantingAction",
    "memberof": "src/Handlers/Cli.js~Cli",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handlers/Cli.js~Cli._grantingAction",
    "access": "protected",
    "description": "This method can be re-implemented by derived classes to hook when an {@link Action}\nis granted for a handler ({@link Handler.grantAction})",
    "lineNumber": 313,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "handlerName",
        "description": "registered handler name"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "actionName",
        "description": "registered action name"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "custom options passed during {@link Handler.grantAction}"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.initName",
        "description": "custom name used to initialize the cli, otherwise\nif not defined the actionName is used instead"
      }
    ]
  },
  {
    "__docId__": 164,
    "kind": "method",
    "name": "_createReader",
    "memberof": "src/Handlers/Cli.js~Cli",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Handlers/Cli.js~Cli#_createReader",
    "access": "protected",
    "description": "Creates an instance of a reader for the current handler.\nThis passes the {@link Cli.args} to the reader.",
    "lineNumber": 334,
    "params": [
      {
        "nullable": null,
        "types": [
          "Action"
        ],
        "spread": false,
        "optional": false,
        "name": "action",
        "description": "action instance used by the reader to parse the values"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "plain object containing the options passed to the reader"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Reader"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 165,
    "kind": "method",
    "name": "_createWriter",
    "memberof": "src/Handlers/Cli.js~Cli",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Handlers/Cli.js~Cli#_createWriter",
    "access": "protected",
    "description": "Creates an instance of a writer for the current handler\n\nThis passes the {@link Cli.stdout} and {@link Cli.stderr}\nto the writer.",
    "lineNumber": 354,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "arbitrary value passed to the writer"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "plain object containing the options passed to the writer"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Writer"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 166,
    "kind": "member",
    "name": "_initNames",
    "memberof": "src/Handlers/Cli.js~Cli",
    "static": true,
    "longname": "src/Handlers/Cli.js~Cli._initNames",
    "access": null,
    "description": null,
    "lineNumber": 364,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 167,
    "kind": "file",
    "name": "src/Handlers/Web.js",
    "content": "const assert = require('assert');\nconst TypeCheck = require('js-typecheck');\nconst Settings = require('../Settings');\nconst Metadata = require('../Metadata');\nconst Input = require('../Input');\nconst Handler = require('../Handler');\n\n// symbols used for private instance variables to avoid any potential clashing\n// caused by re-implementations\nconst _request = Symbol('request');\nconst _response = Symbol('response');\n\n\n/**\n * Handles the web integration through expressjs and passportjs.\n *\n * It enables the execution of actions triggered by web requests.\n * The request information is read by {@link WebRequest}, this information\n * is passed to the action during the execution of the web handler\n * ({@link Web.run}). The output of this handler ({@link Web.output}) is done\n * through the {@link WebResponse} writer.\n *\n * In order to tell which actions are visible by this handler, they are required to\n * be registered beforehand via a webfication process that describes their\n * request method, rest route and if it requires authentication.\n *\n * Through decorator support:\n * ```\n * @Mebo.grant('web', {restRoute: '/myApi/action', auth: true})\n * @Mebo.register('myAction')\n * class MyAction extends Mebo.Action{\n *   // ...\n * }\n * ```\n *\n * Through registration api:\n * ```\n * Mebo.Handler.grantAction('web', 'myRegisteredAction', {restRoute: '/myApi/action', auth: true});\n * ```\n *\n * In case of actions that require authentication (`auth: true`) Mebo checks if\n * the authentication has been executed before executing the action. Therefore,\n * a passport authentication is required to be defined beforehand which can\n * be done through {@link addBeforeAuthAction}:\n *\n * ```\n * Mebo.Handler.get('web').addBeforeAuthAction(passport);\n * ```\n *\n * Also, custom middlewares can be added before the execution of any action through\n * {@link addBeforeAction}:\n *\n * ```\n * Mebo.Handler.get('web').addBeforeAction((req, res, next) => {...});\n * ```\n *\n * After the webfication process, actions can be triggered in two ways:\n *\n * - *Rest support* ({@link Web.restful}):\n * Executes an action through a rest route, it happens when an action is webfied\n * with `restRoute` where it becomes automatically visible as part of the\n * restful support. In order to activated the restful support you need to tel\n * Mebo what is the expressjs app you want to register the rest routes:\n * ```javascript\n * const app = express();\n * // this process registers the rest route for the webfied actions\n * Mebo.Handler.get('web').restful(app);\n * ```\n * The result of webfied actions is done through the restful support is automatically\n * by using google's json style guide. The only exceptions are readable stream\n * and buffer that are piped to the response\n * ({@link Web._successOutput}, {@link Web._errorOutput}).\n *\n * - *Middleware support* ({@link Web.middleware}):\n * Executes an action through an arbitrary route. Actions can be executed as\n * expressjs middlewares.\n * It's done by using `Mebo.Handler.get('web').middleware` where you tell what is the action's\n * registration name that should be executed for the express route\n * (make sure the action has been webfied before hand). By using this feature\n * you control the response of the request, since the result of the action\n * is passed to the middleware:\n * ```javascript\n * const app = express();\n * app.get(\n *    '/foo',\n *    Mebo.Handler.get('web').middleware('myRegisteredAction', (err, result, req, res) => {\n *      // some sauce...\n *    })\n * );\n * ```\n *\n * **Express req and res**\n *\n * The request and the response used by this handler are available\n * under the {@link Session} as: `session.get('req')` and `session.get('res')`.\n *\n * @see http://expressjs.com\n * @see http://passportjs.org\n */\nclass Web extends Handler{\n\n  /**\n   * Creates a web handler\n   *\n   * @param {Object} req - request object\n   * @param {Object} res - response object\n   */\n  constructor(req, res){\n    super();\n\n    this.setRequest(req);\n    this.setResponse(res);\n  }\n\n  /**\n   * Returns the request object created by the express server\n   *\n   * @see http://expressjs.com/en/api.html#req\n   * @return {Object}\n   */\n  request(){\n    return this[_request];\n  }\n\n  /**\n   * Sets the request object created by the express server.\n   *\n   * It also includes the request as part of the session: `session.get('request')`\n   *\n   * @see http://expressjs.com/en/api.html#req\n   * @param {Object} req - request object\n   */\n  setRequest(req){\n    assert(TypeCheck.isObject(req) && req.method, 'Invalid request object');\n\n    this[_request] = req;\n    this.session().set('req', req);\n\n    // adding the remote ip address to the autofill as remoteAddress\n    this.session().setAutofill(\n      'remoteAddress',\n      req.headers['x-forwarded-for'] || req.connection.remoteAddress,\n    );\n  }\n\n  /**\n   * Returns the response object created by the express server\n   *\n   * @see http://expressjs.com/en/api.html#res\n   * @return {Object}\n   */\n  response(){\n    return this[_response];\n  }\n\n  /**\n   * Sets the response object created by the express server\n   *\n   * It also includes the response as part of the session: `session.get('response')`\n   *\n   * @see http://expressjs.com/en/api.html#res\n   * @param {Object} res - response object\n   */\n  setResponse(res){\n    assert(TypeCheck.isObject(res) && TypeCheck.isObject(res.locals), 'Invalid response object');\n\n    this[_response] = res;\n    this.session().set('res', res);\n  }\n\n  /**\n   * Returns a middleware designed to execute a webfied {@link Web.webfyAction}\n   * based on an arbitrary express route. Differently from {@link Web.restful} this method\n   * does not response the request, instead it's done through the responseCallback\n   * which passes the action `error`, `result` and the default middleware express\n   * arguments, for instance:\n   *\n   * ```javascript\n   * const app = express();\n   * app.get(\n   *    '/foo',\n   *    Mebo.Handler.get('web').middleware('myRegisteredAction', (err, result, req, res) => {\n   *      // ...\n   *    })\n   * );\n   * ```\n   *\n   * @param {string} actionName - registered action name\n   * @param {function} [responseCallback] - optional response callback that overrides\n   * the default json response. The callback carries the express:\n   * function(err, result, req, res, next){...}\n   * @return {function}\n   */\n  static middleware(actionName, responseCallback){\n    return this._createMiddleware(actionName, responseCallback);\n  }\n\n  /**\n   * Adds a middleware that is executed before an action.\n   *\n   * Use this feature when you want to execute a custom middleware before the\n   * execution of an action. If you want to add a middleware for a specific\n   * web handler implementation then take a look at {@link Web.beforeAction}. All middlewares\n   * registered by this method are executed after {@link addBeforeAuthAction}.\n   *\n   * Alternatively this method can be called directly from Mebo as `Mebo.Handler.get('web').addBeforeAction(...)`\n   *\n   * In order to pass a values computed by a \"before middleware\" to the action you need to\n   * add the values to the handler session, so the action can read them later. The\n   * web handler is available under `res.locals.web`, for instance:\n   * ```\n   * const web = res.locals.web;\n   * web.session().setAutofill('customValue', 'myValue');\n   * ```\n   *\n   * Where any input assigned with the autofill property 'someCustom' is going to be\n   * assigned with the 'something' value:\n   *\n   * ```\n   * class MyAction extends Mebo.action{\n   *   constructor(){\n   *      super();\n   *      // gets assigned with `something` value\n   *      this.createInput('a: text', {autofill: 'customValue'});\n   *   }\n   * }\n   * ```\n   *\n   * @param {function} middleware - expressjs middleware that should be executed\n   * before the action\n   *\n   * @see http://expressjs.com/en/guide/using-middleware.html\n   */\n  static addBeforeAction(middleware){\n    assert(TypeCheck.isCallable(middleware), 'middleware needs to defined as a callable');\n\n    this._beforeActionMiddlewares.push(middleware);\n  }\n\n  /**\n   * Adds a middleware that is executed before an action that requires authentication.\n   *\n   * Use this feature when you want to execute a custom middleware before the\n   * execution of an action that requires authentication. If you want to add a\n   * middleware for a specific web handler implementation then take a look at\n   * {@link Web.beforeAuthAction}. All middlewares registered by this method are\n   * executed before {@link addBeforeAction}.\n   *\n   * Use this feature to define the passportjs authentication middleware.\n   *\n   * In order to pass a values computed by a \"before middleware\" to the action you need to\n   * add the values to the handler session, so the action can read them later. The\n   * web handler is available under `res.locals.web`, for instance:\n   * ```\n   * const web = res.locals.web;\n   * web.session().setAutofill('customValue', 'value');\n   * ```\n   *\n   * Where any input assigned with the autofill property 'customValue' is going to be\n   * assigned with 'value':\n   *\n   * ```\n   * class MyAction extends Mebo.action{\n   *   constructor(){\n   *      super();\n   *      // gets assigned with `something`\n   *      this.createInput('a: text', {autofill: 'customValue'});\n   *   }\n   * }\n   * ```\n   *\n   * @param {function} middleware - expressjs middleware that should be executed\n   * before an action that requires authentication\n   *\n   * @see http://expressjs.com/en/guide/using-middleware.html\n   */\n  static addBeforeAuthAction(middleware){\n    assert(TypeCheck.isCallable(middleware), 'middleware needs to defined as a callable');\n\n    this._beforeAuthActionMiddlewares.push(middleware);\n  }\n\n  /**\n   * Returns a list middlewares that are executed before an action.\n   *\n   * This method can be re-implemented by subclasses to include custom middlewares\n   * that are tied with a specific web handler implementation. By default it returns\n   * the middlewares added through {@link Web.addBeforeAction}\n   *\n   * @return {Array<function>}\n   */\n  static beforeAction(){\n    return this._beforeActionMiddlewares.slice(0);\n  }\n\n  /**\n   * Returns a list middlewares that are executed before an action that requires auth\n   *\n   * This method can be re-implemented by subclasses to include custom middlewares\n   * that are tied with a specific web handler implementation. By default it returns\n   * the middlewares added through {@link Web.addBeforeAuthAction}\n   *\n   * @return {Array<function>}\n   */\n  static beforeAuthAction(){\n    return this._beforeAuthActionMiddlewares.slice(0);\n  }\n\n  /**\n   * Adds the restful support to the express app.\n   *\n   * It works by registering the rest routes for the webfied visible actions\n   * ({@link Web.webfyAction}) to the express app. The response of actions\n   * executed through the rest support is done via the output method.\n   *\n   * ```javascript\n   * const app = express();\n   * Mebo.Handler.get('web').restful(app);\n   * ```\n   * or\n   * ```javascript\n   * const app = express();\n   * Mebo.Handler.get('web').restful(app, '/api'); // adding a prefix for the rest routes\n   * ```\n   *\n   * @param {Object} expressApp - expressjs application instance\n   * @param {string} [prefix] - optional prefix that gets included in the\n   * registration of the rest routes\n   */\n  static restful(expressApp, prefix=''){\n\n    assert(TypeCheck.isCallable(expressApp.use), 'Invalid express instance!');\n    assert(TypeCheck.isString(prefix), 'prefix must be defined as string');\n\n    // registering the routes\n    for (const webfiedAction of this._webActions){\n      if (webfiedAction.restRoute !== null){\n\n        // building the final route path\n        let finalRoute = prefix;\n        if (prefix.length && !webfiedAction.restRoute.startsWith('/')){\n          finalRoute += '/';\n        }\n        finalRoute += webfiedAction.restRoute;\n\n        // registering route\n        expressApp[webfiedAction.method](\n          finalRoute,\n          this._createMiddleware(webfiedAction.actionName),\n        );\n      }\n    }\n  }\n\n  /**\n   * Makes an action available for requests.\n   *\n   * By doing that the action gets visible for the {@link restful} and {@link middleware} support.\n   *\n   * This method is called during `Mebo.Handler.grantAction('web', ...)`\n   *\n   * @param {string} handlerName - registered handler name\n   * @param {string} actionName - registered action name\n   * @param {Object} options - custom options\n   * @param {string|Array<string>} [method='get'] - tells the request method about how the action should\n   * be available, for instance: `get`, `post`, `put`, `delete` (...). Multiples methods\n   * can be defined through an array of method names\n   * @param {boolean} [options.auth=null] - boolean telling if the action requires authentication\n   * when set to `null` (default) this information is driven by the setting\n   *  `handler/web/requireAuthByDefault` (default: `false`).\n   * @param {string} [options.restRoute] - the rest route from which the action should be executed from\n   * the {@link restful} support. You can use route parameters as well that later are translated to\n   * input values to further information take a look at ({@link WebRequest}).\n   * @protected\n   */\n  static _grantingAction(handlerName, actionName, {method='get', auth=null, restRoute=null}={}){\n\n    // registering action\n    let methods = (TypeCheck.isString(method)) ? [method] : method;\n    methods = methods.map(x => x.toLowerCase());\n    const actionNameFinal = actionName.toLowerCase();\n\n    // finding duplicated items\n    const removeIndexes = [];\n    for (let i=0, len=this._webActions.length; i < len; ++i){\n      const webfiedAction = this._webActions[i];\n      const action = webfiedAction.actionName;\n      const actionMethod = webfiedAction.method;\n\n      if (methods.includes(actionMethod) && restRoute === webfiedAction.restRoute){\n\n        // when the method and route is already being used by another action then removing\n        // that from the registration, since the method and route will be registered\n        // for a different action\n        if (action in this._actionMethodToWebfiedIndex && actionMethod in this._actionMethodToWebfiedIndex[action]){\n          delete this._actionMethodToWebfiedIndex[action][actionMethod];\n        }\n\n        removeIndexes.push(i);\n      }\n    }\n\n    // removing duplicated items\n    if (removeIndexes.length){\n      for (let i=0, len=removeIndexes.length; i < len; ++i){\n        this._webActions.splice(removeIndexes[i]-i, 1);\n      }\n    }\n\n    // storing the action under the auxiliary data struct 'action method to webfied index'\n    if (!(actionNameFinal in this._actionMethodToWebfiedIndex)){\n      this._actionMethodToWebfiedIndex[actionNameFinal] = Object.create(null);\n    }\n\n    // adding the routes\n    for (const addMethod of methods){\n      const webfiedAction = Object.create(null);\n      webfiedAction.actionName = actionNameFinal;\n      webfiedAction.method = addMethod;\n      webfiedAction.auth = auth;\n      webfiedAction.restRoute = restRoute;\n\n      // adding the index about where the webfied action is localized\n      // under the 'action method to webfied index'\n      this._actionMethodToWebfiedIndex[actionNameFinal][addMethod] = this._webActions.length;\n\n      // adding the webfied action information\n      this._webActions.push(webfiedAction);\n    }\n  }\n\n  /**\n   * Creates an instance of a reader for the current handler\n   *\n   * This passes the {@link Web.request} to the reader.\n   *\n   * @param {Action} action - action instance used by the reader to parse the values\n   * @param {Object} options - plain object containing the options passed to the reader\n   * @return {Reader}\n   * @protected\n   */\n  _createReader(action, options){\n\n    return super._createReader(\n      action,\n      options,\n      this.request(),\n    );\n  }\n\n  /**\n   * Creates an instance of a writer for the current handler.\n   *\n   * This passes the {@link Web.response} to the reader and\n   * the request.query.context as an option to the writer.\n   *\n   * @param {*} value - arbitrary value passed to the writer\n   * @param {Object} options - plain object containing the options passed to the writer\n   * @return {Writer}\n   * @protected\n   */\n  _createWriter(value, options){\n    const writer = super._createWriter(value, options, this.response());\n\n    // adding context as part of the result\n    const query = this.request().query;\n    if ('context' in query && writer.option('root')){\n      writer.setOption('root.context', query.context);\n    }\n\n    return writer;\n  }\n\n  /**\n   * Returns a wrapped middleware which makes sure that actions requiring auth\n   * use the middleware otherwise the middleware is skipped\n   *\n   * @param {function} middleware - auth middleware\n   * @return {function}\n   * @private\n   */\n  static _wrapAuthMiddleware(middleware){\n    return (req, res, next) => {\n      if (res.locals.web.requireAuth){\n        middleware(req, res, next);\n      }\n      else{\n        next();\n      }\n    };\n  }\n\n  /**\n   * Auxiliary method that creates a middleware containing an action\n   *\n   * @param {string} actionName - registered action name which should be executed by the middleware\n   * @param {function} [responseCallback] - optional response callback that overrides\n   * the default json response. The callback carries the express:\n   * function(err, result, req, res, next){...}\n   * @return {function}\n   * @private\n   */\n  static _createMiddleware(actionName, responseCallback=null){\n\n    const checkActionMiddleware = (req, res, next) => {\n      const method = req.method.toLowerCase();\n\n      // checking if the action is webfied for the current request method\n      const normalizedName = actionName.toLowerCase();\n      if (!(method in this._actionMethodToWebfiedIndex[normalizedName])){\n        return res.sendStatus(404);\n      }\n\n      // storing the request handler inside of the res.locals, so this object\n      // can be accessed later by the action\n      res.locals.web = Handler.create(\n        'web',\n        normalizedName,\n        // passed to the handler\n        req,\n        res,\n      );\n\n      const actionDataIndex = this._actionMethodToWebfiedIndex[normalizedName][method];\n      res.locals.web.requireAuth = this._webActions[actionDataIndex].auth;\n\n      next();\n    };\n\n    // creating the middleware that executes the action\n    const actionMiddleware = (req, res, next) => {\n\n      // assuring the authentication has been done\n      assert(res.locals.web.requireAuth !== undefined);\n      assert(!res.locals.web.requireAuth || req.user !== undefined, \"Can't execute an auth action without authentication!\");\n\n      // creates the action\n      const web = res.locals.web;\n      const render = (!TypeCheck.isCallable(responseCallback));\n\n      // executing the action middleware\n      web.runAction(actionName).then((result) => {\n        if (render){\n          web.output(result);\n        }\n        // callback that handles the response (Mebo.Handler.get('web').middleware)\n        else{\n          responseCallback(null, result, req, res, next);\n        }\n        // runaway promise\n        return null;\n      }).catch((err) => {\n        if (render){\n          web.output(err);\n        }\n        // callback that handles the response (Mebo.Handler.get('web').middleware)\n        else{\n          responseCallback(err, null, req, res, next);\n        }\n      });\n    };\n\n    const WebHandlerClass = this.registeredHandler('web', actionName);\n\n    // final middleware list\n    const result = [checkActionMiddleware,\n      ...WebHandlerClass.beforeAuthAction().map(this._wrapAuthMiddleware),\n      ...WebHandlerClass.beforeAction(),\n      actionMiddleware,\n    ];\n\n    return result;\n  }\n\n  static _beforeAuthActionMiddlewares = [];\n\n  static _beforeActionMiddlewares = [];\n\n  static _webActions = [];\n\n  static _actionMethodToWebfiedIndex = {};\n}\n\n// default settings\nSettings.set('handler/web/requireAuthByDefault', false); //  BE CAREFUL\n\n// registering input properties\nInput.registerProperty('filePath', 'restrictWebAccess', true);\n\n// registering option vars\nMetadata.registerOptionVar('$web', 'handler.web');\nMetadata.registerOptionVar('$webUploadDirectory', '$web.readOptions.uploadDirectory');\nMetadata.registerOptionVar('$webUploadPreserveName', '$web.readOptions.uploadPreserveName');\nMetadata.registerOptionVar('$webUploadMaxFileSize', '$web.readOptions.uploadMaxFileSize');\nMetadata.registerOptionVar('$webMaxFields', '$web.readOptions.maxFields');\nMetadata.registerOptionVar('$webMaxFieldsSize', '$web.readOptions.maxFieldsSize');\nMetadata.registerOptionVar('$webHeaders', '$web.writeOptions.headers');\nMetadata.registerOptionVar('$webHeadersOnly', '$web.writeOptions.headersOnly');\nMetadata.registerOptionVar('$webResult', '$web.writeOptions.result');\nMetadata.registerOptionVar('$webRoot', '$web.writeOptions.root');\nMetadata.registerOptionVar('$webStatus', '$web.writeOptions.status');\nMetadata.registerOptionVar('$webResultLabel', '$web.writeOptions.resultLabel');\n\n// registering handler\nHandler.register(Web);\n\n// exporting module\nmodule.exports = Web;\n",
    "static": true,
    "longname": "src/Handlers/Web.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 168,
    "kind": "variable",
    "name": "__import_module__assert",
    "memberof": "src/Handlers/Web.js",
    "static": true,
    "longname": "src/Handlers/Web.js~__import_module__assert",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handlers/Web.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 169,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Handlers/Web.js",
    "static": true,
    "longname": "src/Handlers/Web.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handlers/Web.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 170,
    "kind": "variable",
    "name": "__import_module__Settings",
    "memberof": "src/Handlers/Web.js",
    "static": true,
    "longname": "src/Handlers/Web.js~__import_module__Settings",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handlers/Web.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 171,
    "kind": "variable",
    "name": "__import_module__Metadata",
    "memberof": "src/Handlers/Web.js",
    "static": true,
    "longname": "src/Handlers/Web.js~__import_module__Metadata",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handlers/Web.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 172,
    "kind": "variable",
    "name": "__import_module__Input",
    "memberof": "src/Handlers/Web.js",
    "static": true,
    "longname": "src/Handlers/Web.js~__import_module__Input",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handlers/Web.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 173,
    "kind": "variable",
    "name": "__import_module__Handler",
    "memberof": "src/Handlers/Web.js",
    "static": true,
    "longname": "src/Handlers/Web.js~__import_module__Handler",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handlers/Web.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 174,
    "kind": "variable",
    "name": "_request",
    "memberof": "src/Handlers/Web.js",
    "static": true,
    "longname": "src/Handlers/Web.js~_request",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handlers/Web.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 175,
    "kind": "variable",
    "name": "_response",
    "memberof": "src/Handlers/Web.js",
    "static": true,
    "longname": "src/Handlers/Web.js~_response",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Handlers/Web.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 176,
    "kind": "class",
    "name": "Web",
    "memberof": "src/Handlers/Web.js",
    "static": true,
    "longname": "src/Handlers/Web.js~Web",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Handlers/Web.js",
    "importStyle": "Web",
    "description": "Handles the web integration through expressjs and passportjs.\n\nIt enables the execution of actions triggered by web requests.\nThe request information is read by {@link WebRequest}, this information\nis passed to the action during the execution of the web handler\n({@link Web.run}). The output of this handler ({@link Web.output}) is done\nthrough the {@link WebResponse} writer.\n\nIn order to tell which actions are visible by this handler, they are required to\nbe registered beforehand via a webfication process that describes their\nrequest method, rest route and if it requires authentication.\n\nThrough decorator support:\n```\n@Mebo.grant('web', {restRoute: '/myApi/action', auth: true})\n@Mebo.register('myAction')\nclass MyAction extends Mebo.Action{\n  // ...\n}\n```\n\nThrough registration api:\n```\nMebo.Handler.grantAction('web', 'myRegisteredAction', {restRoute: '/myApi/action', auth: true});\n```\n\nIn case of actions that require authentication (`auth: true`) Mebo checks if\nthe authentication has been executed before executing the action. Therefore,\na passport authentication is required to be defined beforehand which can\nbe done through {@link addBeforeAuthAction}:\n\n```\nMebo.Handler.get('web').addBeforeAuthAction(passport);\n```\n\nAlso, custom middlewares can be added before the execution of any action through\n{@link addBeforeAction}:\n\n```\nMebo.Handler.get('web').addBeforeAction((req, res, next) => {...});\n```\n\nAfter the webfication process, actions can be triggered in two ways:\n\n- *Rest support* ({@link Web.restful}):\nExecutes an action through a rest route, it happens when an action is webfied\nwith `restRoute` where it becomes automatically visible as part of the\nrestful support. In order to activated the restful support you need to tel\nMebo what is the expressjs app you want to register the rest routes:\n```javascript\nconst app = express();\n// this process registers the rest route for the webfied actions\nMebo.Handler.get('web').restful(app);\n```\nThe result of webfied actions is done through the restful support is automatically\nby using google's json style guide. The only exceptions are readable stream\nand buffer that are piped to the response\n({@link Web._successOutput}, {@link Web._errorOutput}).\n\n- *Middleware support* ({@link Web.middleware}):\nExecutes an action through an arbitrary route. Actions can be executed as\nexpressjs middlewares.\nIt's done by using `Mebo.Handler.get('web').middleware` where you tell what is the action's\nregistration name that should be executed for the express route\n(make sure the action has been webfied before hand). By using this feature\nyou control the response of the request, since the result of the action\nis passed to the middleware:\n```javascript\nconst app = express();\napp.get(\n   '/foo',\n   Mebo.Handler.get('web').middleware('myRegisteredAction', (err, result, req, res) => {\n     // some sauce...\n   })\n);\n```\n\n**Express req and res**\n\nThe request and the response used by this handler are available\nunder the {@link Session} as: `session.get('req')` and `session.get('res')`.",
    "see": [
      "http://expressjs.com",
      "http://passportjs.org"
    ],
    "lineNumber": 100,
    "interface": false,
    "extends": [
      "Handler"
    ]
  },
  {
    "__docId__": 177,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Handlers/Web.js~Web",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Handlers/Web.js~Web#constructor",
    "access": null,
    "description": "Creates a web handler",
    "lineNumber": 108,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "req",
        "description": "request object"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "res",
        "description": "response object"
      }
    ]
  },
  {
    "__docId__": 178,
    "kind": "method",
    "name": "request",
    "memberof": "src/Handlers/Web.js~Web",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Handlers/Web.js~Web#request",
    "access": null,
    "description": "Returns the request object created by the express server",
    "see": [
      "http://expressjs.com/en/api.html#req"
    ],
    "lineNumber": 121,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 179,
    "kind": "method",
    "name": "setRequest",
    "memberof": "src/Handlers/Web.js~Web",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Handlers/Web.js~Web#setRequest",
    "access": null,
    "description": "Sets the request object created by the express server.\n\nIt also includes the request as part of the session: `session.get('request')`",
    "see": [
      "http://expressjs.com/en/api.html#req"
    ],
    "lineNumber": 133,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "req",
        "description": "request object"
      }
    ]
  },
  {
    "__docId__": 180,
    "kind": "member",
    "name": "[_request]",
    "memberof": "src/Handlers/Web.js~Web",
    "static": false,
    "longname": "src/Handlers/Web.js~Web#[_request]",
    "access": null,
    "description": null,
    "lineNumber": 136,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 181,
    "kind": "method",
    "name": "response",
    "memberof": "src/Handlers/Web.js~Web",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Handlers/Web.js~Web#response",
    "access": null,
    "description": "Returns the response object created by the express server",
    "see": [
      "http://expressjs.com/en/api.html#res"
    ],
    "lineNumber": 152,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 182,
    "kind": "method",
    "name": "setResponse",
    "memberof": "src/Handlers/Web.js~Web",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Handlers/Web.js~Web#setResponse",
    "access": null,
    "description": "Sets the response object created by the express server\n\nIt also includes the response as part of the session: `session.get('response')`",
    "see": [
      "http://expressjs.com/en/api.html#res"
    ],
    "lineNumber": 164,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "res",
        "description": "response object"
      }
    ]
  },
  {
    "__docId__": 183,
    "kind": "member",
    "name": "[_response]",
    "memberof": "src/Handlers/Web.js~Web",
    "static": false,
    "longname": "src/Handlers/Web.js~Web#[_response]",
    "access": null,
    "description": null,
    "lineNumber": 167,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 184,
    "kind": "method",
    "name": "middleware",
    "memberof": "src/Handlers/Web.js~Web",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handlers/Web.js~Web.middleware",
    "access": null,
    "description": "Returns a middleware designed to execute a webfied {@link Web.webfyAction}\nbased on an arbitrary express route. Differently from {@link Web.restful} this method\ndoes not response the request, instead it's done through the responseCallback\nwhich passes the action `error`, `result` and the default middleware express\narguments, for instance:\n\n```javascript\nconst app = express();\napp.get(\n   '/foo',\n   Mebo.Handler.get('web').middleware('myRegisteredAction', (err, result, req, res) => {\n     // ...\n   })\n);\n```",
    "lineNumber": 194,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "actionName",
        "description": "registered action name"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "responseCallback",
        "description": "optional response callback that overrides\nthe default json response. The callback carries the express:\nfunction(err, result, req, res, next){...}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 185,
    "kind": "method",
    "name": "addBeforeAction",
    "memberof": "src/Handlers/Web.js~Web",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handlers/Web.js~Web.addBeforeAction",
    "access": null,
    "description": "Adds a middleware that is executed before an action.\n\nUse this feature when you want to execute a custom middleware before the\nexecution of an action. If you want to add a middleware for a specific\nweb handler implementation then take a look at {@link Web.beforeAction}. All middlewares\nregistered by this method are executed after {@link addBeforeAuthAction}.\n\nAlternatively this method can be called directly from Mebo as `Mebo.Handler.get('web').addBeforeAction(...)`\n\nIn order to pass a values computed by a \"before middleware\" to the action you need to\nadd the values to the handler session, so the action can read them later. The\nweb handler is available under `res.locals.web`, for instance:\n```\nconst web = res.locals.web;\nweb.session().setAutofill('customValue', 'myValue');\n```\n\nWhere any input assigned with the autofill property 'someCustom' is going to be\nassigned with the 'something' value:\n\n```\nclass MyAction extends Mebo.action{\n  constructor(){\n     super();\n     // gets assigned with `something` value\n     this.createInput('a: text', {autofill: 'customValue'});\n  }\n}\n```",
    "see": [
      "http://expressjs.com/en/guide/using-middleware.html"
    ],
    "lineNumber": 234,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "middleware",
        "description": "expressjs middleware that should be executed\nbefore the action"
      }
    ]
  },
  {
    "__docId__": 186,
    "kind": "method",
    "name": "addBeforeAuthAction",
    "memberof": "src/Handlers/Web.js~Web",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handlers/Web.js~Web.addBeforeAuthAction",
    "access": null,
    "description": "Adds a middleware that is executed before an action that requires authentication.\n\nUse this feature when you want to execute a custom middleware before the\nexecution of an action that requires authentication. If you want to add a\nmiddleware for a specific web handler implementation then take a look at\n{@link Web.beforeAuthAction}. All middlewares registered by this method are\nexecuted before {@link addBeforeAction}.\n\nUse this feature to define the passportjs authentication middleware.\n\nIn order to pass a values computed by a \"before middleware\" to the action you need to\nadd the values to the handler session, so the action can read them later. The\nweb handler is available under `res.locals.web`, for instance:\n```\nconst web = res.locals.web;\nweb.session().setAutofill('customValue', 'value');\n```\n\nWhere any input assigned with the autofill property 'customValue' is going to be\nassigned with 'value':\n\n```\nclass MyAction extends Mebo.action{\n  constructor(){\n     super();\n     // gets assigned with `something`\n     this.createInput('a: text', {autofill: 'customValue'});\n  }\n}\n```",
    "see": [
      "http://expressjs.com/en/guide/using-middleware.html"
    ],
    "lineNumber": 277,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "middleware",
        "description": "expressjs middleware that should be executed\nbefore an action that requires authentication"
      }
    ]
  },
  {
    "__docId__": 187,
    "kind": "method",
    "name": "beforeAction",
    "memberof": "src/Handlers/Web.js~Web",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handlers/Web.js~Web.beforeAction",
    "access": null,
    "description": "Returns a list middlewares that are executed before an action.\n\nThis method can be re-implemented by subclasses to include custom middlewares\nthat are tied with a specific web handler implementation. By default it returns\nthe middlewares added through {@link Web.addBeforeAction}",
    "lineNumber": 292,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Array<function>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 188,
    "kind": "method",
    "name": "beforeAuthAction",
    "memberof": "src/Handlers/Web.js~Web",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handlers/Web.js~Web.beforeAuthAction",
    "access": null,
    "description": "Returns a list middlewares that are executed before an action that requires auth\n\nThis method can be re-implemented by subclasses to include custom middlewares\nthat are tied with a specific web handler implementation. By default it returns\nthe middlewares added through {@link Web.addBeforeAuthAction}",
    "lineNumber": 305,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Array<function>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 189,
    "kind": "method",
    "name": "restful",
    "memberof": "src/Handlers/Web.js~Web",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handlers/Web.js~Web.restful",
    "access": null,
    "description": "Adds the restful support to the express app.\n\nIt works by registering the rest routes for the webfied visible actions\n({@link Web.webfyAction}) to the express app. The response of actions\nexecuted through the rest support is done via the output method.\n\n```javascript\nconst app = express();\nMebo.Handler.get('web').restful(app);\n```\nor\n```javascript\nconst app = express();\nMebo.Handler.get('web').restful(app, '/api'); // adding a prefix for the rest routes\n```",
    "lineNumber": 330,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "expressApp",
        "description": "expressjs application instance"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "prefix",
        "description": "optional prefix that gets included in the\nregistration of the rest routes"
      }
    ]
  },
  {
    "__docId__": 190,
    "kind": "method",
    "name": "_grantingAction",
    "memberof": "src/Handlers/Web.js~Web",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handlers/Web.js~Web._grantingAction",
    "access": "protected",
    "description": "Makes an action available for requests.\n\nBy doing that the action gets visible for the {@link restful} and {@link middleware} support.\n\nThis method is called during `Mebo.Handler.grantAction('web', ...)`",
    "lineNumber": 376,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "handlerName",
        "description": "registered handler name"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "actionName",
        "description": "registered action name"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "custom options"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Array<string>"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'get'",
        "defaultRaw": "'get'",
        "name": "method",
        "description": "tells the request method about how the action should\nbe available, for instance: `get`, `post`, `put`, `delete` (...). Multiples methods\ncan be defined through an array of method names"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "options.auth",
        "description": "boolean telling if the action requires authentication\nwhen set to `null` (default) this information is driven by the setting\n `handler/web/requireAuthByDefault` (default: `false`)."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.restRoute",
        "description": "the rest route from which the action should be executed from\nthe {@link restful} support. You can use route parameters as well that later are translated to\ninput values to further information take a look at ({@link WebRequest})."
      }
    ]
  },
  {
    "__docId__": 191,
    "kind": "method",
    "name": "_createReader",
    "memberof": "src/Handlers/Web.js~Web",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Handlers/Web.js~Web#_createReader",
    "access": "protected",
    "description": "Creates an instance of a reader for the current handler\n\nThis passes the {@link Web.request} to the reader.",
    "lineNumber": 442,
    "params": [
      {
        "nullable": null,
        "types": [
          "Action"
        ],
        "spread": false,
        "optional": false,
        "name": "action",
        "description": "action instance used by the reader to parse the values"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "plain object containing the options passed to the reader"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Reader"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 192,
    "kind": "method",
    "name": "_createWriter",
    "memberof": "src/Handlers/Web.js~Web",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Handlers/Web.js~Web#_createWriter",
    "access": "protected",
    "description": "Creates an instance of a writer for the current handler.\n\nThis passes the {@link Web.response} to the reader and\nthe request.query.context as an option to the writer.",
    "lineNumber": 462,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "arbitrary value passed to the writer"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "plain object containing the options passed to the writer"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Writer"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 193,
    "kind": "method",
    "name": "_wrapAuthMiddleware",
    "memberof": "src/Handlers/Web.js~Web",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handlers/Web.js~Web._wrapAuthMiddleware",
    "access": "private",
    "description": "Returns a wrapped middleware which makes sure that actions requiring auth\nuse the middleware otherwise the middleware is skipped",
    "lineNumber": 482,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "middleware",
        "description": "auth middleware"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 194,
    "kind": "method",
    "name": "_createMiddleware",
    "memberof": "src/Handlers/Web.js~Web",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Handlers/Web.js~Web._createMiddleware",
    "access": "private",
    "description": "Auxiliary method that creates a middleware containing an action",
    "lineNumber": 503,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "actionName",
        "description": "registered action name which should be executed by the middleware"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "responseCallback",
        "description": "optional response callback that overrides\nthe default json response. The callback carries the express:\nfunction(err, result, req, res, next){...}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 195,
    "kind": "member",
    "name": "_beforeAuthActionMiddlewares",
    "memberof": "src/Handlers/Web.js~Web",
    "static": true,
    "longname": "src/Handlers/Web.js~Web._beforeAuthActionMiddlewares",
    "access": null,
    "description": null,
    "lineNumber": 575,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 196,
    "kind": "member",
    "name": "_beforeActionMiddlewares",
    "memberof": "src/Handlers/Web.js~Web",
    "static": true,
    "longname": "src/Handlers/Web.js~Web._beforeActionMiddlewares",
    "access": null,
    "description": null,
    "lineNumber": 577,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 197,
    "kind": "member",
    "name": "_webActions",
    "memberof": "src/Handlers/Web.js~Web",
    "static": true,
    "longname": "src/Handlers/Web.js~Web._webActions",
    "access": null,
    "description": null,
    "lineNumber": 579,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 198,
    "kind": "member",
    "name": "_actionMethodToWebfiedIndex",
    "memberof": "src/Handlers/Web.js~Web",
    "static": true,
    "longname": "src/Handlers/Web.js~Web._actionMethodToWebfiedIndex",
    "access": null,
    "description": null,
    "lineNumber": 581,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 199,
    "kind": "file",
    "name": "src/Handlers/index.js",
    "content": "module.exports.Cli = require('./Cli');\nmodule.exports.Web = require('./Web');\n",
    "static": true,
    "longname": "src/Handlers/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 200,
    "kind": "file",
    "name": "src/Input.js",
    "content": "const assert = require('assert');\nconst TypeCheck = require('js-typecheck');\nconst ValidationFail = require('./Errors/ValidationFail');\nconst Utils = require('./Utils');\n\n// symbols used for private instance variables to avoid any potential clashing\n// caused by re-implementations\nconst _name = Symbol('name');\nconst _readOnly = Symbol('readOnly');\nconst _properties = Symbol('properties');\nconst _lockedProperties = Symbol('lockedProperties');\nconst _cache = Symbol('cache');\n\n\n/**\n * An input holds a value that is used for the execution of the {@link Action}.\n *\n * The value carried by the input gets checked through a wide range of validations\n * that make sure the value meets the necessary requirements for  the execution\n * of the {@link Action}.\n *\n * The validations are performed asynchronously which enables an implementation\n * that can go far beyond checking the data type or matching the value through\n * a regex. In most cases these validations are driven by `properties`. Properties are\n * usually defined at construction time. Also, non-generic validations can be\n * implemented through `extendedValidation`, making possible to define validations\n * that are tied with an action itself.\n *\n * Inputs are created through {@link Input.create} using a\n * [syntactic sugar](https://en.wikipedia.org/wiki/Syntactic_sugar) that describes\n * their name and type (aka [TypeScript](https://www.typescriptlang.org/)), for instance:\n *\n * ```javascript\n * Input.create('myInput: bool')\n * ```\n *\n * Any input can be defined as a vector by using the short array syntax `[]`:\n *\n * ```javascript\n * Input.create('myInput: bool[]')\n * ```\n *\n * Additionally, you can specify if an input is optional (not required) by adding\n * `?` beside of the input name:\n *\n * ```javascript\n * Input.create('myInput?: bool[]')\n * ```\n *\n * You can also create inputs through a verbose (boilerplate) interface where each\n * of the options described above can be defined at construction time via properties:\n * ```javascript\n * Input.create('myInput', {type: 'bool', vector: true, required: false})\n * ```\n *\n * Since inputs are used by actions they can be created directly inside of an {@link Action} via\n * {@link Action.createInput} that internally triggers {@link Input.create} factory method:\n *\n * ```\n * class HelloWorld extends Mebo.Action{\n *   constructor(){\n *     super();\n *     //  compact version\n *     this.createInput('myInputA?: bool[]');\n *\n *     // same as effect as above, but not so friendly to read\n *     this.addInput(Input.create('myInputB?: bool[]'));\n *   }\n * }\n * ```\n *\n * To register a new input type, take a look at {@link Input.register}\n *\n * <h2>Property Summary</h2>\n *\n * Property Name | Description | Defined&nbsp;by Default | Default Value\n * --- | --- | :---: | :---:\n * required | boolean telling if the value is required (defined at the construction time) \\\n * | ::on:: | ::true::\n * immutable | boolean telling if the data of the value cannot be altered \\\n * overtime, however the value of the input can still be replaced by \\\n * the input value setter, in order to prevent it you can set an input as \\\n * {@link readOnly} | ::on:: | ::true::\n * defaultValue | default value of the input | ::on:: | ::null::\n * elementType | tells how the input should be presented via {@link Cli}: \\\n * `'option'` or `'argument'` ({@link http://docopt.org}) | ::on:: | `'option'`\n * vector | boolean telling if the input holds a vector value (defined \\\n * at the construction time) | ::on:: | ::auto::\n * hidden | boolean telling if the input is hidden from the {@link Reader}, \\\n * therefore it should only be used internally | ::off:: | ::none::\n * autofill | key name about a value that may be under the {@link Session.autofill}. This \\\n * value is used to initialize the input. It occurs when a session is assigned \\\n * to an action ({@link Action.setSession}) | ::off:: | ::none::\n * description | description about the input, currently this information is displayed \\\n * when an action is running through {@link Cli} | ::off:: | ::none::\n * shortOption | short version of the input name used to speficy when running \\\n * through the {@link Cli} | ::off:: | ::none::\n *\n * <br/>The assignment of a property value can be done at construction time or through\n * the setter {@link Input.assignProperty}. A property value can be queried by the\n * getter {@link Input.property}. To add new properties to an input type, please take\n * a look at {@link Input.registerProperty}.\n */\nclass Input{\n\n  /**\n   * Creates an input\n   *\n   * @param {string} name - name of the input\n   * @param {Object} [properties={}] - plain object containing the properties which\n   * will be assigned to the {@link Input}\n   * @param {function} [extendedValidation] - callback that can be defined to supply\n   * custom validations to the {@link Input}\n   */\n  constructor(name, properties={}, extendedValidation=null){\n    assert(TypeCheck.isString(name) && name.length, 'name cannot be empty!');\n    assert(TypeCheck.isPlainObject(properties), \"properties need to be defined as dict {'key': value}\");\n    assert(extendedValidation === null || TypeCheck.isCallback(extendedValidation),\n      'extendedValidation needs to be defined as function(contextValue) or null');\n\n    // validating reserved names\n    assert(!(['help'].includes(name)), `Input name '${name}' is reserved, it cannot be used!`);\n\n    // validating input name\n    assert(name.length, 'input name cannot be empty!');\n    assert((/^([\\w_.-])+$/gi).test(name), `Illegal input name: ${name}`);\n\n    this[_name] = name;\n    this[_readOnly] = false;\n    this[_properties] = new Map();\n    this[_lockedProperties] = new Set();\n    this[_cache] = new Utils.ImmutableMap();\n\n    // defining custom properties that may override the default ones\n    for (const propertyKey in properties){\n      this.assignProperty(propertyKey, properties[propertyKey]);\n    }\n\n    // locking properties\n    this.lockProperty('type');\n    this.lockProperty('vector');\n    this.lockProperty('defaultValue');\n\n    this.setValue(this.property('defaultValue'));\n    this._extendedValidation = extendedValidation;\n  }\n\n  /**\n   * Creates an input instance.\n   *\n   * @param {string} inputInterface - string followed by either the pattern `name: type`\n   * or `name?: type` in case of optional {@link Input}. The type is case-insensitive\n   * @param {Object} [properties={}] - plain object containing the properties which\n   * will be assigned to the {@link Input}\n   * @param {function} [extendedValidation] - callback that can be defined to supply\n   * custom validations to the {@link Input}\n   * @return {Input}\n   *\n   *\n   * @example\n   * // minimal\n   * Input.create('inputName: numeric');\n   *\n   * @example\n   * // full\n   * Input.create('inputName: numeric', {min: 1, max: 5}, function(at){\n   *  return new Promise((resolve, reject) => {\n   *    if (this.valueAt(at) === 3)\n   *      reject(new ValidationFail('Failed for some reason'));\n   *    else\n   *      resolve(this.value());\n   *  });\n   * })\n   */\n  static create(inputInterface, properties={}, extendedValidation=null){\n    const inputInterfaceParts = inputInterface.split(':');\n    const propertiesFinal = Object.assign({}, properties);\n\n    if (inputInterfaceParts.length === 2){\n      for (let i=0, len=inputInterfaceParts.length; i < len; ++i){\n        inputInterfaceParts[i] = inputInterfaceParts[i].trim();\n      }\n\n      // not required syntax\n      if (inputInterfaceParts[0].endsWith('?')){\n        inputInterfaceParts[0] = inputInterfaceParts[0].slice(0, -1);\n        propertiesFinal.required = false;\n      }\n\n      // vector syntax\n      if (inputInterfaceParts[1].endsWith('[]')){\n        inputInterfaceParts[1] = inputInterfaceParts[1].slice(0, -2);\n        propertiesFinal.vector = true;\n      }\n\n      propertiesFinal.type = inputInterfaceParts[1];\n    }\n    else if (inputInterfaceParts.length > 2){\n      throw new Error(\"Invalid input interface, it should follow the pattern: 'name: type'\");\n    }\n\n    const InputTypeClass = this.registeredInput(propertiesFinal.type);\n\n    // storing the input type in lower-case to keep the same convention\n    // found in the registration\n    propertiesFinal.type = propertiesFinal.type.toLowerCase();\n\n    return new InputTypeClass(inputInterfaceParts[0], propertiesFinal, extendedValidation);\n  }\n\n  /**\n   * Returns if the value of the input is empty. This is used mainly by\n   * the property `required=false` to know if the input does not have a value\n   * assigned to it.\n   *\n   * @return {boolean} If the input is empty\n   */\n  isEmpty(){\n    return TypeCheck.isNone(this.value()) || (this.property('vector')\n      && TypeCheck.isList(this.value()) && this.value().length === 0);\n  }\n\n  /**\n   * Returns if the value of the input is a vector. This information is defined\n   * by the property `vector=true`\n   *\n   * @return {boolean} if the input is a vector\n   */\n  isVector(){\n    return this.property('vector') === true;\n  }\n\n  /**\n   * Returns if the value of the input is required. This information is defined\n   * by the property `required=true`\n   *\n   * @return {boolean} if the input is required\n   */\n  isRequired(){\n    return this.property('required') === true;\n  }\n\n  /**\n   * Sets the input value by avoiding the overhead that may occur when the\n   * same value is used across actions that have the input type, therefore\n   * this method avoids the re-computation by copying the caches and value\n   * associated with the source input to the current input. The cache will be\n   * only copied if both source and target inputs have the `immutable` property\n   * enabled (default true).\n   *\n   * @param {Input} sourceInput - input used as source to setup the current input\n   * @param {null|number} [at] - index used when the target input is defined as vector to\n   * tells which value should be used\n   * @param {boolean} [cache=true] - tells if the cache will be copied as well\n   */\n  setupFrom(sourceInput, at=null, cache=true){\n    assert(TypeCheck.isSameType(sourceInput, this), 'Inputs are not the same type!');\n\n    if (at !== null && !sourceInput.isVector()){\n      throw new Error(`Can't use at, since the source input is not a vector`);\n    }\n    else if (at !== null && this.isVector()){\n      throw new Error(`Can't use at, from a source vector input to a target vector input`);\n    }\n    else if (at === null && sourceInput.isVector() && !this.isVector()){\n      throw new Error(`Target input is not a vector, can't setup from a vector target input without supplying 'at'`);\n    }\n\n    // transferring value:\n    // when the source is not a vector, but the target is\n    if (this.isVector() && !sourceInput.isVector()){\n      this.setValue([sourceInput.value()]);\n    }\n    // when source and target are the same either scalar or vector\n    else if (at === null){\n      this.setValue(sourceInput.value());\n    }\n    // when an index is specific from a source vector to a scalar input\n    else{\n      this.setValue(sourceInput.value()[at]);\n    }\n\n    // transferring cache to the current input:\n    if (cache && sourceInput.property('immutable') && this.property('immutable')){\n      assert(sourceInput.cache() instanceof Utils.ImmutableMap);\n\n      const sourceCache = sourceInput.cache();\n\n      // when the source is not a vector, but the target is\n      if (this.isVector() && !sourceInput.isVector()){\n        for (const key of sourceCache.keys()){\n          this._setToCache(key.slice(0, -2), sourceCache.get(key), 0);\n        }\n      }\n\n      // when source and target are the same either scalar or vector\n      else if (at === null){\n        for (const key of sourceCache.keys()){\n          this.cache().set(key, sourceCache.get(key));\n        }\n      }\n\n      // when an index is specific from a source vector to a scalar input\n      else{\n        const indexToken = `(${at})`;\n        for (const key of sourceCache.keys()){\n          if (key.endsWith(indexToken)){\n            this._setToCache(key.slice(0, -indexToken.length), sourceCache.get(key));\n          }\n        }\n      }\n    }\n  }\n\n  /**\n  * Returns the cache used by the input\n  *\n  * This method is called by ({@link setupFrom}) to setup the input based on an\n  * already existing input\n  *\n  * @return {ImmutableMap}\n  */\n  cache(){\n    return this[_cache];\n  }\n\n  /**\n   * Forces to flush the internal input cache\n   */\n  clearCache(){\n    this.cache().clear();\n  }\n\n  /**\n   * Executes the input validations ({@link _validation}), in case of a failed\n   * validation then an exception of type {@link ValidationFail} is raised\n   *\n   * @return {Promise<*>} Returns the value of the input\n   */\n  async validate(){\n\n    try{\n      // required check\n      if (this.isEmpty()){\n        if (this.isRequired() !== false){\n          throw new ValidationFail(\n            'Input is required, it cannot be empty!',\n            '28a03a60-a405-4737-b94d-2b695b6ce156',\n          );\n        }\n      }\n\n      // vector check\n      else if (this.isVector() && !TypeCheck.isList(this.value())){\n        throw new ValidationFail(\n          'Input needs to be a vector!',\n          'e03709a0-6c31-4a33-9f63-fa751948a6cb',\n        );\n      }\n\n      // otherwise perform the asynchronous validations\n      else{\n        const validationPromises = [];\n        const length = this.isVector() ? this.value().length : 1;\n        for (let i=0; i < length; ++i){\n          // setting the context index\n          const at = this.isVector() ? i : null;\n          validationPromises.push(this._validation(at));\n\n          // running extended validations\n          if (TypeCheck.isCallback(this._extendedValidation)){\n            validationPromises.push(this._extendedValidation.call(this, at));\n          }\n        }\n\n        // running generic validations\n        await Promise.all(validationPromises);\n      }\n    }\n    catch(err){\n      // including the input name to the validation fail\n      if (err instanceof ValidationFail){\n        err.inputName = this.name();\n\n        // disabling the output when input is marked as hidden\n        if (this.property('hidden')){\n          err.output = false;\n        }\n      }\n\n      throw err;\n    }\n\n    return true;\n  }\n\n  /**\n   * Returns the property value for the input property name\n   *\n   * @param {string} name - name of the property\n   * @return {Promise<*>} The value of the property (or the defaultValue in case of the\n   * property does not exist)\n   */\n  property(name){\n    assert(TypeCheck.isString(name), 'property name needs to be defined as string');\n\n    if (this[_properties].has(name)){\n      return this[_properties].get(name);\n    }\n\n    // checking if the property is valid\n    const allRegisteredProperties = Input._allRegisteredProperties(this.constructor);\n    if (allRegisteredProperties.has(name)){\n      return allRegisteredProperties.get(name);\n    }\n\n    throw new Error(`Property ${name} is not registered!`);\n  }\n\n  /**\n   * Sets a property to the input. In case the property already exists then the value\n   * is going to be overridden. By default the only properties that can be modified are\n   * the ones found under {@link Input.registeredInputNames}. However you can\n   * assign a non-registered property by enabling `loose` parameter.\n   *\n   * Property values can be locked, therefore preventing modifications\n   * ({@link Input.lockProperty}).\n   *\n   * @param {string} name - name of the property\n   * @param {*} value - value for the property\n   * @param {boolean} [loose=false] - when true lets to assign a property that is not\n   * registered to the input ({@link Input.registeredInputNames})\n   */\n  assignProperty(name, value, loose=false){\n    assert(TypeCheck.isString(name), 'property name needs to be defined as string');\n\n    // checking if input is read-only\n    if (this.readOnly()){\n      throw new Error(`Input ${this.name()} is read only, cannot be modified!`);\n    }\n\n    // checking if property is valid\n    if (!loose && !Input._allRegisteredProperties(this.constructor).has(name)){\n      throw new Error(`Property ${name} is not registered!`);\n    }\n\n    // checking if property has been locked\n    if (this[_lockedProperties].has(name)){\n      throw new Error(`Property ${name} is locked!`);\n    }\n\n    this[_properties].set(name, value);\n\n    this.clearCache();\n  }\n\n  /**\n   * Prevents a property value to be modified by {@link Input.assignProperty}\n   *\n   * @param {string} name - name of the property\n   * @param {boolean} [lock=true] - if true it locks the property otherwise\n   * it removes the lock from the property\n   */\n  lockProperty(name, lock=true){\n\n    // checking if input is read-only\n    if (this.readOnly()){\n      throw new Error(`Input ${this.name()} is read only, cannot be modified!`);\n    }\n\n    if (lock){\n      this[_lockedProperties].add(name);\n    }\n    else{\n      this[_lockedProperties].delete(name);\n    }\n  }\n\n  /**\n   * Returns a boolean telling if the property is locked ({@link Input.lockProperty})\n   *\n   * @param {string} name - name of the property\n   * @return {boolean}\n   */\n  isPropertyLocked(name){\n    return this[_lockedProperties].has(name);\n  }\n\n  /**\n   * Returns a boolean telling if the input property name is assigned to the input\n   *\n   * @param {string} name - name of the property\n   * @return {boolean}\n   */\n  hasProperty(name){\n    assert(TypeCheck.isString(name), 'property name needs to be defined as string');\n\n    return Input._allRegisteredProperties(this.constructor).has(name) || this[_properties].has(name);\n  }\n\n  /**\n   * Returns a list containing the property names assigned to the input\n   *\n   * @return {Array<string>}\n   */\n  propertyNames(){\n    return [...new Set([...this[_properties].keys(),\n      ...Input._allRegisteredProperties(this.constructor).keys(),\n    ])];\n  }\n\n  /**\n   * Sets the value of the input\n   *\n   * @param {*} value - value that should be set to the input\n   */\n  setValue(value){\n\n    // checking if input is read-only\n    if (this.readOnly()){\n      throw new Error(`Input ${this.name()} is read only, cannot be modified!`);\n    }\n\n    // Due the overhead that may occur on going through recursively and freezing\n    // the whole hierarchy of the value, it freezes only value itself. In case\n    // this is not enough consider in changing it to perform a deep-freeze instead\n    this._value = (!this.property('immutable') || TypeCheck.isNone(value))\n      || value instanceof Buffer ? value : Object.freeze(value);\n\n    // flushing the cache when a new value is set\n    this.clearCache();\n  }\n\n  /**\n   * Returns the value of the input\n   *\n   * @return {*}\n   */\n  value(){\n    return this._value;\n  }\n\n  /**\n   * Returns the name of the input which is defined at construction time (inputs cannot\n   * be renamed)\n   *\n   * @return {string}\n   */\n  name(){\n    return this[_name];\n  }\n\n  /**\n   * Returns if the input is serializable\n   *\n   * This method should be re-implemented by derived classes to tell if the input can be\n   * serialized (default true).\n   *\n   * In case of a serializable input, the methods {@link Input._encode} and {@link Input._decode}\n   * are expected to be implemented.\n   *\n   * @return {boolean}\n   */\n  isSerializable(){\n    return true;\n  }\n\n  /**\n   * Changes the read-only state of the input. A read-only input cannot have its\n   * value and properties modified. It's mainly used during the execution of the {@link Action}\n   * where all inputs are assigned as read-only, therefore when the execution is completed\n   * the inputs are restored with the original read-only value assigned before\n   * the execution of the action\n   *\n   * @param {boolean} enable - tells if a input is read-only\n   */\n  setReadOnly(enable){\n    this[_readOnly] = enable;\n  }\n\n  /**\n   * Returns a boolean telling if the input is in read-only mode. A read-only input\n   * cannot have its value and properties modified\n   *\n   * @return {boolean}\n   */\n  readOnly(){\n    return this[_readOnly];\n  }\n\n  /**\n   * Decodes a value represented as string to the type that is compatible with the input.\n   * This method is called by the {@link Handler} or when an action is loaded/created using\n   * {@link Action.fromJSON}/{@link Action.createFromJSON}. In case the input\n   * is defined as vector then the value can be defined using an array encoded in JSON.\n   * The parsed value gets returned and assigned to the input as well (you can control this\n   * by the `assignValue` argument).\n   *\n   * The implementation of the decoding is done by the method {@link Input._decode}.\n   * To know if an input supports decoding checkout the {@link Input.isSerializable}.\n   *\n   * To know how the serialization is done for the inputs bundled with\n   * Mebo take a look at {@link Reader} documentation.\n   *\n   * @param {string} value - string containing the serialized data\n   * @param {boolean} [assignValue=true] - tells if the parsed value should be assigned\n   * to the input\n   * @return {*}\n   */\n  parseValue(value, assignValue=true){\n    assert(this.isSerializable(), 'parsing not supported!');\n    assert(TypeCheck.isString(value), 'value needs to be defined as string or string array');\n\n    let result;\n\n    // empty string is treated as null\n    if (value.length === 0){\n      result = null;\n    }\n    else if (this.isVector()){\n      const decodedValue = [];\n\n      // it may worth to allow passing an Array directly as valid value as well, so it would\n      // avoid the overhead of encoding/decoding JSON when using it internally. Let's keep\n      // an eye on it for now.\n      const parsedValue = JSON.parse(value);\n\n      assert(TypeCheck.isList(parsedValue), 'Could not parse, unexpected data type');\n      for (const parsedItem of parsedValue){\n        let finalParsedItem = parsedItem;\n\n        // casting the parsed value to a string if necessary\n        if (!TypeCheck.isString(parsedItem) && parsedItem !== null){\n          finalParsedItem = String(parsedItem);\n        }\n\n        // empty string is treated as null\n        if (finalParsedItem === ''){\n          finalParsedItem = null;\n        }\n\n        // decoding the value\n        decodedValue.push(finalParsedItem ? this.constructor._decode(finalParsedItem) : null);\n      }\n\n      result = decodedValue;\n    }\n    else{\n      result = this.constructor._decode(value);\n    }\n\n    if (assignValue){\n      this.setValue(result);\n    }\n\n    return result;\n  }\n\n  /**\n   * This method should return a string representation about the current value in a way that\n   * can be recovered later through {@link parseValue}.\n   *\n   * The encode implementation is done by the  method {@link Input._encode}.\n   * To know if an input supports serialization checkout the {@link Input.isSerializable}.\n   *\n   * Also, in case you want to know the serialization form for the inputs bundled with\n   * Mebo checkout {@link Reader}.\n   *\n   * @return {Promise<string>}\n   */\n  async serializeValue(){\n    assert(this.isSerializable(), 'serialization not supported!');\n\n    // making sure the value can be serialized without any issues\n    await this.validate();\n\n    // serializing the value\n    let result;\n\n    if (this.isEmpty()){\n      result = '';\n    }\n    else if (this.isVector()){\n      const encodedValue = [];\n\n      for (const item of this.value()){\n        encodedValue.push(this.constructor._encode(item));\n      }\n\n      return JSON.stringify(encodedValue);\n    }\n    else{\n      result = this.constructor._encode(this.value());\n    }\n\n    return String(result);\n  }\n\n  /**\n   * Decodes the input value from the string representation ({@link Input._encode}) to the\n   * data type of the input. This method is called internally during {@link Input.parseValue}\n   *\n   * @param {string} value - encoded value\n   * @return {*}\n   * @protected\n   */\n  static _decode(value){\n    assert(TypeCheck.isString(value), 'value needs to be defined as string');\n\n    return value;\n  }\n\n  /**\n   * Encodes the input value to a string representation that can be later decoded\n   * through {@link Input._decode}. This method is called internally during the\n   * {@link serializeValue}\n   *\n   * @param {*} value - value that should be encoded to a string\n   * @return {string}\n   * @protected\n   */\n  static _encode(value){\n    return String(value);\n  }\n\n  /**\n   * Registers a new input type to the available inputs\n   *\n   * @param {Input} inputClass - input implementation that will be registered\n   * @param {string} [name] - string containing the registration name for the\n   * input. In case of an empty string, the registration is done by using the name\n   * of the type (this information is stored in lowercase)\n   */\n  static register(inputClass, name=''){\n    assert(TypeCheck.isSubClassOf(inputClass, Input), 'Invalid input type!');\n    assert(TypeCheck.isString(name), 'Invalid optional registration name!');\n\n    const nameFinal = ((name === '') ? inputClass.name : name).toLowerCase();\n\n    // validating name\n    assert((/^([\\w_\\.\\-])+$/gi).test(nameFinal), `Illegal input name: ${nameFinal}`); // eslint-disable-line no-useless-escape\n\n    this._registeredInputs.set(nameFinal, inputClass);\n  }\n\n  /**\n   * Returns the input type based on the registration name\n   *\n   * @param {string} name - name of the registered input type\n   * @return {Input}\n   */\n  static registeredInput(name){\n    assert(TypeCheck.isString(name), 'Invalid name!');\n\n    const normalizedName = name.toLowerCase();\n\n    if (this._registeredInputs.has(normalizedName)){\n      return this._registeredInputs.get(normalizedName);\n    }\n\n    throw new Error(`Input ${name} is not registered!`);\n  }\n\n  /**\n   * Returns a list containing the names of the registered input types\n   *\n   * @return {Array<string>}\n   */\n  static registeredInputNames(){\n    return [...this._registeredInputs.keys()];\n  }\n\n  /**\n   * This method enforces the context of the value being queried.\n   * Since the input can behave as vector it makes sure that when that's\n   * the case the index must be supplied otherwise it raises an exception.\n   * Use this method when you need to query the value through validations where\n   * the index (at) is always passed to them, whether if the input is vector\n   * or scalar\n   *\n   * @param {number} [index] - used when the input is set to a vector to tell the\n   * index of the value\n   * @return {*}\n   */\n  valueAt(index=null){\n    if (this.isVector()){\n      assert(index !== null, 'Could not determine the index of the vector');\n      return this.value()[index];\n    }\n\n    return this.value();\n  }\n\n  /**\n   * Registers a property for the input type (also available as `Mebo.Input.registerProperty`)\n   *\n   * ```\n   * // example of registering a new property\n   * Mebo.Input.registerProperty('text', 'myCustomProperty', 'A initial value if necessary')\n   * ```\n   *\n   * @param {string|Input} inputClassOrRegisteredName - registered input name or input class\n   * in which the property should be registered\n   * @param {string} name - name of the property (in case the property name already\n   * exists than it going to be overridden for the input type)\n   * @param {*} [initialValue] - optional initial value for the property (undefined by default)\n   */\n  static registerProperty(inputClassOrRegisteredName, name, initialValue){\n    assert(TypeCheck.isString(name), 'property name needs to be defined as string');\n    assert(name.length, 'property name cannot be empty');\n\n    const inputType = this._resolveInputType(inputClassOrRegisteredName);\n\n    // appending to the existing registered properties\n    if (!this._registeredProperties.has(inputType)){\n      this._registeredProperties.set(inputType, new Map());\n    }\n\n    this._registeredProperties.get(inputType).set(name, initialValue);\n\n    // resetting the properties caches\n    this._propertiesCache.clear();\n  }\n\n  /**\n   * Returns a list about all registered property names including the inherited ones for\n   * the input type\n   *\n   * ```\n   * // returning all properties for an input type (using 'numeric' as example)\n   * Mebo.Input.registeredPropertyNames('numeric');\n   * ```\n   *\n   * @param {string|Input} inputClassOrRegisteredName - registered input name or input class\n   * @return {Array<string>}\n   */\n  static registeredPropertyNames(inputClassOrRegisteredName){\n    const inputType = this._resolveInputType(inputClassOrRegisteredName);\n\n    return [...this._allRegisteredProperties(inputType).keys()];\n  }\n\n  /**\n   * Use this method to implement generic validations\n   * for your input implementation. In case any validation fails this method\n   * should return a {@link ValidationFail} (This method is called when the\n   * validations are perform through {@link Input.validate})\n   *\n   * @param {null|number} at - index used when input has been created as a vector that\n   * tells which value should be used\n   * @return {Promise<*>} Returns the value of the input\n   * @protected\n   */\n  async _validation(at){\n    return this.valueAt(at);\n  }\n\n  /**\n   * Auxiliary method used internally by input implementations to check if the key\n   * is under the cache\n   *\n   * @param {string} name - name of the key\n   * @param {null|number} [at] - used when the input is set to a vector to tell the\n   * index of the value\n   * @return {boolean}\n   * @protected\n   */\n  _isCached(name, at=null){\n    return this.cache().has(this._cacheEntry(name, at));\n  }\n\n  /**\n   * Auxiliary method used internally by input implementations to set a value to\n   * the cache\n   *\n   * @param {string} name - name of the key\n   * @param {*} value - value that should be set in the cache\n   * @param {null|number} [at] - used when the input is set to a vector to tell the\n   * index of the value\n   * @protected\n   */\n  _setToCache(name, value, at=null){\n    this.cache().set(this._cacheEntry(name, at), value);\n  }\n\n  /**\n   * Auxiliary method used internally by the input implementations to get a value\n   * from the cache\n   *\n   * @param {string} name - name of the key\n   * @param {null|number} [at] - used when the input is set to a vector to tell the\n   * index of the value\n   * @return {*}\n   * @protected\n   */\n  _getFromCache(name, at=null){\n    return this.cache().get(this._cacheEntry(name, at));\n  }\n\n  /**\n   * Returns the cache entry based on the name and index (at)\n   *\n   * @param {string} name - name of the key\n   * @param {number|null} at - used when the input is set to a vector to tell the\n   * @return {string}\n   *\n   * @private\n   */\n  _cacheEntry(name, at){\n    if (this.isVector()){\n      assert(at !== null, 'Could not determine the index of the vector');\n    }\n\n    return (this.isVector()) ? `${name}(${at})` : `${name}()`;\n  }\n\n  /**\n   * Auxiliary method that resolves the registered input type based\n   *\n   * @param {string|Input} inputClassOrRegisteredName - registered input name or input class\n   * @return {Input}\n   * @private\n   */\n  static _resolveInputType(inputClassOrRegisteredName){\n    if (TypeCheck.isSubClassOf(inputClassOrRegisteredName, Input) || inputClassOrRegisteredName === Input){\n      return inputClassOrRegisteredName;\n    }\n\n    return this.registeredInput(inputClassOrRegisteredName);\n  }\n\n  /**\n   * Auxiliary method that collects all available registered property names for the input type\n   * and returns them\n   *\n   * @param {Input} inputType - input class that should be used to collect the properties\n   * @return {Array<string>}\n   * @private\n   */\n  static _allRegisteredProperties(inputType){\n\n    if (!this._propertiesCache.has(inputType)){\n      let currentClass = inputType;\n      const inputProperties = new Map();\n\n      while (currentClass.name !== ''){\n        if (this._registeredProperties.has(currentClass)){\n          for (const [propertyName, propertyValue] of this._registeredProperties.get(currentClass)){\n            // if a property has been overriding by a sub class then skip it\n            if (!inputProperties.has(propertyName)){\n              inputProperties.set(propertyName, propertyValue);\n            }\n          }\n        }\n        currentClass = Object.getPrototypeOf(currentClass);\n      }\n\n      this._propertiesCache.set(inputType, inputProperties);\n    }\n\n    return this._propertiesCache.get(inputType);\n  }\n\n  static _propertiesCache = new Map();\n\n  static _registeredInputs = new Map();\n\n  static _registeredProperties = new Map();\n}\n\n// registering properties\nInput.registerProperty(Input, 'required', true);\nInput.registerProperty(Input, 'type', true);\nInput.registerProperty(Input, 'immutable', true);\nInput.registerProperty(Input, 'defaultValue', null);\nInput.registerProperty(Input, 'vector', false);\nInput.registerProperty(Input, 'hidden');\nInput.registerProperty(Input, 'autofill');\nInput.registerProperty(Input, 'description');\n\nmodule.exports = Input;\n",
    "static": true,
    "longname": "src/Input.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 201,
    "kind": "variable",
    "name": "__import_module__assert",
    "memberof": "src/Input.js",
    "static": true,
    "longname": "src/Input.js~__import_module__assert",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Input.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 202,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Input.js",
    "static": true,
    "longname": "src/Input.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Input.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 203,
    "kind": "variable",
    "name": "__import_module__ValidationFail",
    "memberof": "src/Input.js",
    "static": true,
    "longname": "src/Input.js~__import_module__ValidationFail",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Input.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 204,
    "kind": "variable",
    "name": "__import_module__Utils",
    "memberof": "src/Input.js",
    "static": true,
    "longname": "src/Input.js~__import_module__Utils",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Input.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 205,
    "kind": "variable",
    "name": "_name",
    "memberof": "src/Input.js",
    "static": true,
    "longname": "src/Input.js~_name",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Input.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 206,
    "kind": "variable",
    "name": "_readOnly",
    "memberof": "src/Input.js",
    "static": true,
    "longname": "src/Input.js~_readOnly",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Input.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 207,
    "kind": "variable",
    "name": "_properties",
    "memberof": "src/Input.js",
    "static": true,
    "longname": "src/Input.js~_properties",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Input.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 208,
    "kind": "variable",
    "name": "_lockedProperties",
    "memberof": "src/Input.js",
    "static": true,
    "longname": "src/Input.js~_lockedProperties",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Input.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 209,
    "kind": "variable",
    "name": "_cache",
    "memberof": "src/Input.js",
    "static": true,
    "longname": "src/Input.js~_cache",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Input.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 210,
    "kind": "class",
    "name": "Input",
    "memberof": "src/Input.js",
    "static": true,
    "longname": "src/Input.js~Input",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Input.js",
    "importStyle": "Input",
    "description": "An input holds a value that is used for the execution of the {@link Action}.\n\nThe value carried by the input gets checked through a wide range of validations\nthat make sure the value meets the necessary requirements for  the execution\nof the {@link Action}.\n\nThe validations are performed asynchronously which enables an implementation\nthat can go far beyond checking the data type or matching the value through\na regex. In most cases these validations are driven by `properties`. Properties are\nusually defined at construction time. Also, non-generic validations can be\nimplemented through `extendedValidation`, making possible to define validations\nthat are tied with an action itself.\n\nInputs are created through {@link Input.create} using a\n[syntactic sugar](https://en.wikipedia.org/wiki/Syntactic_sugar) that describes\ntheir name and type (aka [TypeScript](https://www.typescriptlang.org/)), for instance:\n\n```javascript\nInput.create('myInput: bool')\n```\n\nAny input can be defined as a vector by using the short array syntax `[]`:\n\n```javascript\nInput.create('myInput: bool[]')\n```\n\nAdditionally, you can specify if an input is optional (not required) by adding\n`?` beside of the input name:\n\n```javascript\nInput.create('myInput?: bool[]')\n```\n\nYou can also create inputs through a verbose (boilerplate) interface where each\nof the options described above can be defined at construction time via properties:\n```javascript\nInput.create('myInput', {type: 'bool', vector: true, required: false})\n```\n\nSince inputs are used by actions they can be created directly inside of an {@link Action} via\n{@link Action.createInput} that internally triggers {@link Input.create} factory method:\n\n```\nclass HelloWorld extends Mebo.Action{\n  constructor(){\n    super();\n    //  compact version\n    this.createInput('myInputA?: bool[]');\n\n    // same as effect as above, but not so friendly to read\n    this.addInput(Input.create('myInputB?: bool[]'));\n  }\n}\n```\n\nTo register a new input type, take a look at {@link Input.register}\n\n<h2>Property Summary</h2>\n\nProperty Name | Description | Defined&nbsp;by Default | Default Value\n--- | --- | :---: | :---:\nrequired | boolean telling if the value is required (defined at the construction time)  | ::on:: | ::true::\nimmutable | boolean telling if the data of the value cannot be altered  overtime, however the value of the input can still be replaced by  the input value setter, in order to prevent it you can set an input as  {@link readOnly} | ::on:: | ::true::\ndefaultValue | default value of the input | ::on:: | ::null::\nelementType | tells how the input should be presented via {@link Cli}:  `'option'` or `'argument'` ({@link http://docopt.org}) | ::on:: | `'option'`\nvector | boolean telling if the input holds a vector value (defined  at the construction time) | ::on:: | ::auto::\nhidden | boolean telling if the input is hidden from the {@link Reader},  therefore it should only be used internally | ::off:: | ::none::\nautofill | key name about a value that may be under the {@link Session.autofill}. This  value is used to initialize the input. It occurs when a session is assigned  to an action ({@link Action.setSession}) | ::off:: | ::none::\ndescription | description about the input, currently this information is displayed  when an action is running through {@link Cli} | ::off:: | ::none::\nshortOption | short version of the input name used to speficy when running  through the {@link Cli} | ::off:: | ::none::\n\n<br/>The assignment of a property value can be done at construction time or through\nthe setter {@link Input.assignProperty}. A property value can be queried by the\ngetter {@link Input.property}. To add new properties to an input type, please take\na look at {@link Input.registerProperty}.",
    "lineNumber": 93,
    "interface": false
  },
  {
    "__docId__": 211,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Input.js~Input#constructor",
    "access": null,
    "description": "Creates an input",
    "lineNumber": 104,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "name of the input"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "properties",
        "description": "plain object containing the properties which\nwill be assigned to the {@link Input}"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "extendedValidation",
        "description": "callback that can be defined to supply\ncustom validations to the {@link Input}"
      }
    ]
  },
  {
    "__docId__": 212,
    "kind": "member",
    "name": "[_name]",
    "memberof": "src/Input.js~Input",
    "static": false,
    "longname": "src/Input.js~Input#[_name]",
    "access": null,
    "description": null,
    "lineNumber": 117,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 213,
    "kind": "member",
    "name": "[_readOnly]",
    "memberof": "src/Input.js~Input",
    "static": false,
    "longname": "src/Input.js~Input#[_readOnly]",
    "access": null,
    "description": null,
    "lineNumber": 118,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 214,
    "kind": "member",
    "name": "[_properties]",
    "memberof": "src/Input.js~Input",
    "static": false,
    "longname": "src/Input.js~Input#[_properties]",
    "access": null,
    "description": null,
    "lineNumber": 119,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 215,
    "kind": "member",
    "name": "[_lockedProperties]",
    "memberof": "src/Input.js~Input",
    "static": false,
    "longname": "src/Input.js~Input#[_lockedProperties]",
    "access": null,
    "description": null,
    "lineNumber": 120,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 216,
    "kind": "member",
    "name": "[_cache]",
    "memberof": "src/Input.js~Input",
    "static": false,
    "longname": "src/Input.js~Input#[_cache]",
    "access": null,
    "description": null,
    "lineNumber": 121,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 217,
    "kind": "member",
    "name": "_extendedValidation",
    "memberof": "src/Input.js~Input",
    "static": false,
    "longname": "src/Input.js~Input#_extendedValidation",
    "access": null,
    "description": null,
    "lineNumber": 134,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 218,
    "kind": "method",
    "name": "create",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Input.js~Input.create",
    "access": null,
    "description": "Creates an input instance.",
    "examples": [
      "// minimal\nInput.create('inputName: numeric');",
      "// full\nInput.create('inputName: numeric', {min: 1, max: 5}, function(at){\n return new Promise((resolve, reject) => {\n   if (this.valueAt(at) === 3)\n     reject(new ValidationFail('Failed for some reason'));\n   else\n     resolve(this.value());\n });\n})"
    ],
    "lineNumber": 164,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "inputInterface",
        "description": "string followed by either the pattern `name: type`\nor `name?: type` in case of optional {@link Input}. The type is case-insensitive"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "properties",
        "description": "plain object containing the properties which\nwill be assigned to the {@link Input}"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "extendedValidation",
        "description": "callback that can be defined to supply\ncustom validations to the {@link Input}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Input"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 219,
    "kind": "method",
    "name": "isEmpty",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Input.js~Input#isEmpty",
    "access": null,
    "description": "Returns if the value of the input is empty. This is used mainly by\nthe property `required=false` to know if the input does not have a value\nassigned to it.",
    "lineNumber": 207,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "If the input is empty"
    }
  },
  {
    "__docId__": 220,
    "kind": "method",
    "name": "isVector",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Input.js~Input#isVector",
    "access": null,
    "description": "Returns if the value of the input is a vector. This information is defined\nby the property `vector=true`",
    "lineNumber": 218,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "if the input is a vector"
    }
  },
  {
    "__docId__": 221,
    "kind": "method",
    "name": "isRequired",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Input.js~Input#isRequired",
    "access": null,
    "description": "Returns if the value of the input is required. This information is defined\nby the property `required=true`",
    "lineNumber": 228,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "if the input is required"
    }
  },
  {
    "__docId__": 222,
    "kind": "method",
    "name": "setupFrom",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Input.js~Input#setupFrom",
    "access": null,
    "description": "Sets the input value by avoiding the overhead that may occur when the\nsame value is used across actions that have the input type, therefore\nthis method avoids the re-computation by copying the caches and value\nassociated with the source input to the current input. The cache will be\nonly copied if both source and target inputs have the `immutable` property\nenabled (default true).",
    "lineNumber": 245,
    "params": [
      {
        "nullable": null,
        "types": [
          "Input"
        ],
        "spread": false,
        "optional": false,
        "name": "sourceInput",
        "description": "input used as source to setup the current input"
      },
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "at",
        "description": "index used when the target input is defined as vector to\ntells which value should be used"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "cache",
        "description": "tells if the cache will be copied as well"
      }
    ]
  },
  {
    "__docId__": 223,
    "kind": "method",
    "name": "cache",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Input.js~Input#cache",
    "access": null,
    "description": "Returns the cache used by the input\n\nThis method is called by ({@link setupFrom}) to setup the input based on an\nalready existing input",
    "lineNumber": 312,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "ImmutableMap"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 224,
    "kind": "method",
    "name": "clearCache",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Input.js~Input#clearCache",
    "access": null,
    "description": "Forces to flush the internal input cache",
    "lineNumber": 319,
    "params": []
  },
  {
    "__docId__": 225,
    "kind": "method",
    "name": "validate",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Input.js~Input#validate",
    "access": null,
    "description": "Executes the input validations ({@link _validation}), in case of a failed\nvalidation then an exception of type {@link ValidationFail} is raised",
    "lineNumber": 329,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "Returns the value of the input"
    }
  },
  {
    "__docId__": 226,
    "kind": "method",
    "name": "property",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Input.js~Input#property",
    "access": null,
    "description": "Returns the property value for the input property name",
    "lineNumber": 393,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "name of the property"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "The value of the property (or the defaultValue in case of the\nproperty does not exist)"
    }
  },
  {
    "__docId__": 227,
    "kind": "method",
    "name": "assignProperty",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Input.js~Input#assignProperty",
    "access": null,
    "description": "Sets a property to the input. In case the property already exists then the value\nis going to be overridden. By default the only properties that can be modified are\nthe ones found under {@link Input.registeredInputNames}. However you can\nassign a non-registered property by enabling `loose` parameter.\n\nProperty values can be locked, therefore preventing modifications\n({@link Input.lockProperty}).",
    "lineNumber": 423,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "name of the property"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value for the property"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "loose",
        "description": "when true lets to assign a property that is not\nregistered to the input ({@link Input.registeredInputNames})"
      }
    ]
  },
  {
    "__docId__": 228,
    "kind": "method",
    "name": "lockProperty",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Input.js~Input#lockProperty",
    "access": null,
    "description": "Prevents a property value to be modified by {@link Input.assignProperty}",
    "lineNumber": 453,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "name of the property"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "lock",
        "description": "if true it locks the property otherwise\nit removes the lock from the property"
      }
    ]
  },
  {
    "__docId__": 229,
    "kind": "method",
    "name": "isPropertyLocked",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Input.js~Input#isPropertyLocked",
    "access": null,
    "description": "Returns a boolean telling if the property is locked ({@link Input.lockProperty})",
    "lineNumber": 474,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "name of the property"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 230,
    "kind": "method",
    "name": "hasProperty",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Input.js~Input#hasProperty",
    "access": null,
    "description": "Returns a boolean telling if the input property name is assigned to the input",
    "lineNumber": 484,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "name of the property"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 231,
    "kind": "method",
    "name": "propertyNames",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Input.js~Input#propertyNames",
    "access": null,
    "description": "Returns a list containing the property names assigned to the input",
    "lineNumber": 495,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 232,
    "kind": "method",
    "name": "setValue",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Input.js~Input#setValue",
    "access": null,
    "description": "Sets the value of the input",
    "lineNumber": 506,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value that should be set to the input"
      }
    ]
  },
  {
    "__docId__": 233,
    "kind": "member",
    "name": "_value",
    "memberof": "src/Input.js~Input",
    "static": false,
    "longname": "src/Input.js~Input#_value",
    "access": null,
    "description": null,
    "lineNumber": 516,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 234,
    "kind": "method",
    "name": "value",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Input.js~Input#value",
    "access": null,
    "description": "Returns the value of the input",
    "lineNumber": 528,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 235,
    "kind": "method",
    "name": "name",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Input.js~Input#name",
    "access": null,
    "description": "Returns the name of the input which is defined at construction time (inputs cannot\nbe renamed)",
    "lineNumber": 538,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 236,
    "kind": "method",
    "name": "isSerializable",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Input.js~Input#isSerializable",
    "access": null,
    "description": "Returns if the input is serializable\n\nThis method should be re-implemented by derived classes to tell if the input can be\nserialized (default true).\n\nIn case of a serializable input, the methods {@link Input._encode} and {@link Input._decode}\nare expected to be implemented.",
    "lineNumber": 553,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 237,
    "kind": "method",
    "name": "setReadOnly",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Input.js~Input#setReadOnly",
    "access": null,
    "description": "Changes the read-only state of the input. A read-only input cannot have its\nvalue and properties modified. It's mainly used during the execution of the {@link Action}\nwhere all inputs are assigned as read-only, therefore when the execution is completed\nthe inputs are restored with the original read-only value assigned before\nthe execution of the action",
    "lineNumber": 566,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "enable",
        "description": "tells if a input is read-only"
      }
    ]
  },
  {
    "__docId__": 238,
    "kind": "member",
    "name": "[_readOnly]",
    "memberof": "src/Input.js~Input",
    "static": false,
    "longname": "src/Input.js~Input#[_readOnly]",
    "access": null,
    "description": null,
    "lineNumber": 567,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 239,
    "kind": "method",
    "name": "readOnly",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Input.js~Input#readOnly",
    "access": null,
    "description": "Returns a boolean telling if the input is in read-only mode. A read-only input\ncannot have its value and properties modified",
    "lineNumber": 576,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 240,
    "kind": "method",
    "name": "parseValue",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Input.js~Input#parseValue",
    "access": null,
    "description": "Decodes a value represented as string to the type that is compatible with the input.\nThis method is called by the {@link Handler} or when an action is loaded/created using\n{@link Action.fromJSON}/{@link Action.createFromJSON}. In case the input\nis defined as vector then the value can be defined using an array encoded in JSON.\nThe parsed value gets returned and assigned to the input as well (you can control this\nby the `assignValue` argument).\n\nThe implementation of the decoding is done by the method {@link Input._decode}.\nTo know if an input supports decoding checkout the {@link Input.isSerializable}.\n\nTo know how the serialization is done for the inputs bundled with\nMebo take a look at {@link Reader} documentation.",
    "lineNumber": 599,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "string containing the serialized data"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "assignValue",
        "description": "tells if the parsed value should be assigned\nto the input"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 241,
    "kind": "method",
    "name": "serializeValue",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Input.js~Input#serializeValue",
    "access": null,
    "description": "This method should return a string representation about the current value in a way that\ncan be recovered later through {@link parseValue}.\n\nThe encode implementation is done by the  method {@link Input._encode}.\nTo know if an input supports serialization checkout the {@link Input.isSerializable}.\n\nAlso, in case you want to know the serialization form for the inputs bundled with\nMebo checkout {@link Reader}.",
    "lineNumber": 660,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 242,
    "kind": "method",
    "name": "_decode",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Input.js~Input._decode",
    "access": "protected",
    "description": "Decodes the input value from the string representation ({@link Input._encode}) to the\ndata type of the input. This method is called internally during {@link Input.parseValue}",
    "lineNumber": 696,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "encoded value"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 243,
    "kind": "method",
    "name": "_encode",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Input.js~Input._encode",
    "access": "protected",
    "description": "Encodes the input value to a string representation that can be later decoded\nthrough {@link Input._decode}. This method is called internally during the\n{@link serializeValue}",
    "lineNumber": 711,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value that should be encoded to a string"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 244,
    "kind": "method",
    "name": "register",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Input.js~Input.register",
    "access": null,
    "description": "Registers a new input type to the available inputs",
    "lineNumber": 723,
    "params": [
      {
        "nullable": null,
        "types": [
          "Input"
        ],
        "spread": false,
        "optional": false,
        "name": "inputClass",
        "description": "input implementation that will be registered"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "name",
        "description": "string containing the registration name for the\ninput. In case of an empty string, the registration is done by using the name\nof the type (this information is stored in lowercase)"
      }
    ]
  },
  {
    "__docId__": 245,
    "kind": "method",
    "name": "registeredInput",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Input.js~Input.registeredInput",
    "access": null,
    "description": "Returns the input type based on the registration name",
    "lineNumber": 741,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "name of the registered input type"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Input"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 246,
    "kind": "method",
    "name": "registeredInputNames",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Input.js~Input.registeredInputNames",
    "access": null,
    "description": "Returns a list containing the names of the registered input types",
    "lineNumber": 758,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 247,
    "kind": "method",
    "name": "valueAt",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Input.js~Input#valueAt",
    "access": null,
    "description": "This method enforces the context of the value being queried.\nSince the input can behave as vector it makes sure that when that's\nthe case the index must be supplied otherwise it raises an exception.\nUse this method when you need to query the value through validations where\nthe index (at) is always passed to them, whether if the input is vector\nor scalar",
    "lineNumber": 774,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "index",
        "description": "used when the input is set to a vector to tell the\nindex of the value"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 248,
    "kind": "method",
    "name": "registerProperty",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Input.js~Input.registerProperty",
    "access": null,
    "description": "Registers a property for the input type (also available as `Mebo.Input.registerProperty`)\n\n```\n// example of registering a new property\nMebo.Input.registerProperty('text', 'myCustomProperty', 'A initial value if necessary')\n```",
    "lineNumber": 797,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "Input"
        ],
        "spread": false,
        "optional": false,
        "name": "inputClassOrRegisteredName",
        "description": "registered input name or input class\nin which the property should be registered"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "name of the property (in case the property name already\nexists than it going to be overridden for the input type)"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "initialValue",
        "description": "optional initial value for the property (undefined by default)"
      }
    ]
  },
  {
    "__docId__": 249,
    "kind": "method",
    "name": "registeredPropertyNames",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Input.js~Input.registeredPropertyNames",
    "access": null,
    "description": "Returns a list about all registered property names including the inherited ones for\nthe input type\n\n```\n// returning all properties for an input type (using 'numeric' as example)\nMebo.Input.registeredPropertyNames('numeric');\n```",
    "lineNumber": 826,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "Input"
        ],
        "spread": false,
        "optional": false,
        "name": "inputClassOrRegisteredName",
        "description": "registered input name or input class"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 250,
    "kind": "method",
    "name": "_validation",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Input.js~Input#_validation",
    "access": "protected",
    "description": "Use this method to implement generic validations\nfor your input implementation. In case any validation fails this method\nshould return a {@link ValidationFail} (This method is called when the\nvalidations are perform through {@link Input.validate})",
    "lineNumber": 843,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "Returns the value of the input"
    }
  },
  {
    "__docId__": 251,
    "kind": "method",
    "name": "_isCached",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Input.js~Input#_isCached",
    "access": "protected",
    "description": "Auxiliary method used internally by input implementations to check if the key\nis under the cache",
    "lineNumber": 857,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "name of the key"
      },
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "at",
        "description": "used when the input is set to a vector to tell the\nindex of the value"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 252,
    "kind": "method",
    "name": "_setToCache",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Input.js~Input#_setToCache",
    "access": "protected",
    "description": "Auxiliary method used internally by input implementations to set a value to\nthe cache",
    "lineNumber": 871,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "name of the key"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value that should be set in the cache"
      },
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "at",
        "description": "used when the input is set to a vector to tell the\nindex of the value"
      }
    ]
  },
  {
    "__docId__": 253,
    "kind": "method",
    "name": "_getFromCache",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Input.js~Input#_getFromCache",
    "access": "protected",
    "description": "Auxiliary method used internally by the input implementations to get a value\nfrom the cache",
    "lineNumber": 885,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "name of the key"
      },
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "at",
        "description": "used when the input is set to a vector to tell the\nindex of the value"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 254,
    "kind": "method",
    "name": "_cacheEntry",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Input.js~Input#_cacheEntry",
    "access": "private",
    "description": "Returns the cache entry based on the name and index (at)",
    "lineNumber": 898,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "name of the key"
      },
      {
        "nullable": null,
        "types": [
          "number",
          "null"
        ],
        "spread": false,
        "optional": false,
        "name": "at",
        "description": "used when the input is set to a vector to tell the"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 255,
    "kind": "method",
    "name": "_resolveInputType",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Input.js~Input._resolveInputType",
    "access": "private",
    "description": "Auxiliary method that resolves the registered input type based",
    "lineNumber": 913,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "Input"
        ],
        "spread": false,
        "optional": false,
        "name": "inputClassOrRegisteredName",
        "description": "registered input name or input class"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Input"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 256,
    "kind": "method",
    "name": "_allRegisteredProperties",
    "memberof": "src/Input.js~Input",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Input.js~Input._allRegisteredProperties",
    "access": "private",
    "description": "Auxiliary method that collects all available registered property names for the input type\nand returns them",
    "lineNumber": 929,
    "params": [
      {
        "nullable": null,
        "types": [
          "Input"
        ],
        "spread": false,
        "optional": false,
        "name": "inputType",
        "description": "input class that should be used to collect the properties"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 257,
    "kind": "member",
    "name": "_propertiesCache",
    "memberof": "src/Input.js~Input",
    "static": true,
    "longname": "src/Input.js~Input._propertiesCache",
    "access": null,
    "description": null,
    "lineNumber": 953,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 258,
    "kind": "member",
    "name": "_registeredInputs",
    "memberof": "src/Input.js~Input",
    "static": true,
    "longname": "src/Input.js~Input._registeredInputs",
    "access": null,
    "description": null,
    "lineNumber": 955,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 259,
    "kind": "member",
    "name": "_registeredProperties",
    "memberof": "src/Input.js~Input",
    "static": true,
    "longname": "src/Input.js~Input._registeredProperties",
    "access": null,
    "description": null,
    "lineNumber": 957,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 260,
    "kind": "file",
    "name": "src/Inputs/Any.js",
    "content": "const TypeCheck = require('js-typecheck');\nconst ValidationFail = require('../Errors/ValidationFail');\nconst Input = require('../Input');\n\n\n/**\n * Any value input.\n *\n * This input type holds any kind of object, however it's not exposed for\n * handlers ({@link Handler}). It's intended to be used only internally.\n *\n * ```javascript\n * const input = Input.create('myInput: any');\n * input.setValue({a: 1});\n * ```\n *\n * <h2>Property Summary</h2>\n *\n * Property Name | Description | Defined&nbsp;by Default | Default Value\n * --- | --- | :---: | :---:\n * hidden | boolean telling if the input is hidden from the {@link Reader}, \\\n * therefore it should only be used internally | ::on:: | ::true::\n * allowedInstance | Specific object type that should be allowed by the input \\\n * | ::off:: | ::none::\n *\n * All properties including the inherited ones can be listed via\n * {@link registeredPropertyNames}\n */\nclass Any extends Input{\n\n  /**\n   * Implements input's validations\n   *\n   * @param {null|number} at - index used when input has been created as a vector that\n   * tells which value should be used\n   * @return {Promise<*>} value held by the input based on the current context (at)\n   * @protected\n   */\n  _validation(at){\n\n    // calling super class validations\n    return super._validation(at).then((value) => {\n\n      // type checking\n      if (!TypeCheck.isObject(value)){\n        throw new ValidationFail(\n          'Value needs to be an object!',\n          '25c9158a-30ee-4a9f-8767-bc2c170f77fd',\n        );\n      }\n      // allowed instance checking\n      else if (this.property('allowedInstance') && !(value instanceof this.property('allowedInstance'))){\n        throw new ValidationFail(\n          `Invalid object type: ${value.constructor.name}, expecting ${this.property('allowedInstance').name}`,\n          'd59814e4-0432-435a-b116-4491819c58d4',\n        );\n      }\n\n      return value;\n    });\n  }\n\n  /**\n   * Serialization is not supported\n   *\n   * @return {boolean}\n   */\n  isSerializable(){\n    return false;\n  }\n}\n\n// registering the input\nInput.register(Any);\n\n// registering properties\nInput.registerProperty(Any, 'hidden', true);\nInput.registerProperty(Any, 'allowedInstance');\n\nmodule.exports = Any;\n",
    "static": true,
    "longname": "src/Inputs/Any.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 261,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Inputs/Any.js",
    "static": true,
    "longname": "src/Inputs/Any.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Any.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 262,
    "kind": "variable",
    "name": "__import_module__ValidationFail",
    "memberof": "src/Inputs/Any.js",
    "static": true,
    "longname": "src/Inputs/Any.js~__import_module__ValidationFail",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Any.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 263,
    "kind": "variable",
    "name": "__import_module__Input",
    "memberof": "src/Inputs/Any.js",
    "static": true,
    "longname": "src/Inputs/Any.js~__import_module__Input",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Any.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 264,
    "kind": "class",
    "name": "Any",
    "memberof": "src/Inputs/Any.js",
    "static": true,
    "longname": "src/Inputs/Any.js~Any",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Inputs/Any.js",
    "importStyle": "Any",
    "description": "Any value input.\n\nThis input type holds any kind of object, however it's not exposed for\nhandlers ({@link Handler}). It's intended to be used only internally.\n\n```javascript\nconst input = Input.create('myInput: any');\ninput.setValue({a: 1});\n```\n\n<h2>Property Summary</h2>\n\nProperty Name | Description | Defined&nbsp;by Default | Default Value\n--- | --- | :---: | :---:\nhidden | boolean telling if the input is hidden from the {@link Reader},  therefore it should only be used internally | ::on:: | ::true::\nallowedInstance | Specific object type that should be allowed by the input  | ::off:: | ::none::\n\nAll properties including the inherited ones can be listed via\n{@link registeredPropertyNames}",
    "lineNumber": 27,
    "interface": false,
    "extends": [
      "Input"
    ]
  },
  {
    "__docId__": 265,
    "kind": "method",
    "name": "_validation",
    "memberof": "src/Inputs/Any.js~Any",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/Any.js~Any#_validation",
    "access": "protected",
    "description": "Implements input's validations",
    "lineNumber": 37,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "value held by the input based on the current context (at)"
    }
  },
  {
    "__docId__": 266,
    "kind": "method",
    "name": "isSerializable",
    "memberof": "src/Inputs/Any.js~Any",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/Any.js~Any#isSerializable",
    "access": null,
    "description": "Serialization is not supported",
    "lineNumber": 66,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 267,
    "kind": "file",
    "name": "src/Inputs/BaseText.js",
    "content": "const TypeCheck = require('js-typecheck');\nconst ValidationFail = require('../Errors/ValidationFail');\nconst Input = require('../Input');\n\n\n/**\n * Base text input class derived by all text input implementations.\n *\n * <h2>Property Summary</h2>\n *\n * Property Name | Description | Defined&nbsp;by Default | Default Value\n * --- | --- | :---: | :---:\n * primitive | ensures the value is a primitive | ::on:: | ::true::\n * regex | custom regular expression to test the value | ::off:: | ::none::\n *\n * All properties including the inherited ones can be listed via\n * {@link registeredPropertyNames}\n */\nclass BaseText extends Input{\n\n  /**\n   * Returns if the input is empty\n   * @return {boolean}\n   */\n  isEmpty(){\n    return (super.isEmpty() || this.value().length === 0);\n  }\n\n  /**\n   * Implements input's validations\n   *\n   * @param {null|number} at - index used when input has been created as a vector that\n   * tells which value should be used\n   * @return {Promise<*>} value held by the input based on the current context (at)\n   * @protected\n   */\n  _validation(at){\n\n    // calling super class validations\n    return super._validation(at).then((value) => {\n\n      // type checking\n      if (!TypeCheck.isString(value)){\n        throw new ValidationFail(\n          'Value needs to be a string',\n          '71b205ae-95ed-42a2-b5e9-ccf8e42ba454',\n        );\n      }\n      // primitive property\n      else if (this.property('primitive') && value instanceof String){\n        throw new ValidationFail(\n          'Value needs to be a primitive',\n          '81b44982-3c7b-4a25-952b-70ec640c58d4',\n        );\n      }\n      // regex property\n      else if (this.property('regex') && (!(new RegExp(this.property('regex'))).test(value))){\n        throw new ValidationFail(\n          'Value does not meet the requirements',\n          'c902610c-ef17-4a10-bc75-887d1550793a',\n        );\n      }\n\n      return value;\n    });\n  }\n}\n\n// registering properties\nInput.registerProperty(BaseText, 'primitive', true);\nInput.registerProperty(BaseText, 'regex');\n\nmodule.exports = BaseText;\n",
    "static": true,
    "longname": "src/Inputs/BaseText.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 268,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Inputs/BaseText.js",
    "static": true,
    "longname": "src/Inputs/BaseText.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/BaseText.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 269,
    "kind": "variable",
    "name": "__import_module__ValidationFail",
    "memberof": "src/Inputs/BaseText.js",
    "static": true,
    "longname": "src/Inputs/BaseText.js~__import_module__ValidationFail",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/BaseText.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 270,
    "kind": "variable",
    "name": "__import_module__Input",
    "memberof": "src/Inputs/BaseText.js",
    "static": true,
    "longname": "src/Inputs/BaseText.js~__import_module__Input",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/BaseText.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 271,
    "kind": "class",
    "name": "BaseText",
    "memberof": "src/Inputs/BaseText.js",
    "static": true,
    "longname": "src/Inputs/BaseText.js~BaseText",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Inputs/BaseText.js",
    "importStyle": "BaseText",
    "description": "Base text input class derived by all text input implementations.\n\n<h2>Property Summary</h2>\n\nProperty Name | Description | Defined&nbsp;by Default | Default Value\n--- | --- | :---: | :---:\nprimitive | ensures the value is a primitive | ::on:: | ::true::\nregex | custom regular expression to test the value | ::off:: | ::none::\n\nAll properties including the inherited ones can be listed via\n{@link registeredPropertyNames}",
    "lineNumber": 19,
    "interface": false,
    "extends": [
      "Input"
    ]
  },
  {
    "__docId__": 272,
    "kind": "method",
    "name": "isEmpty",
    "memberof": "src/Inputs/BaseText.js~BaseText",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/BaseText.js~BaseText#isEmpty",
    "access": null,
    "description": "Returns if the input is empty",
    "lineNumber": 25,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 273,
    "kind": "method",
    "name": "_validation",
    "memberof": "src/Inputs/BaseText.js~BaseText",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/BaseText.js~BaseText#_validation",
    "access": "protected",
    "description": "Implements input's validations",
    "lineNumber": 37,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "value held by the input based on the current context (at)"
    }
  },
  {
    "__docId__": 274,
    "kind": "file",
    "name": "src/Inputs/Bool.js",
    "content": "const TypeCheck = require('js-typecheck');\nconst ValidationFail = require('../Errors/ValidationFail');\nconst Input = require('../Input');\n\n\n/**\n * Boolean input.\n *\n * ```javascript\n * const input = Input.create('myInput: bool');\n * input.setValue(false);\n * ```\n *\n * ```javascript\n * // vector version\n * const input = Input.create('myInput: bool[]');\n * input.setValue([false, true, false]);\n * ```\n *\n * *This input can also be created using the alias:* `boolean`\n *\n * <h2>Property Summary</h2>\n *\n * Property Name | Description | Defined&nbsp;by Default | Default Value\n * --- | --- | :---: | :---:\n * primitive | ensures the value is a primitive | ::on:: | ::true::\n *\n * All properties including the inherited ones can be listed via\n * {@link registeredPropertyNames}\n */\nclass Bool extends Input{\n\n  /**\n   * Implements input's validations\n   *\n   * @param {null|number} at - index used when input has been created as a vector that\n   * tells which value should be used\n   * @return {Promise<*>} value held by the input based on the current context (at)\n   * @protected\n   */\n  _validation(at){\n\n    // calling super class validations\n    return super._validation(at).then((value) => {\n\n      // type checking\n      if (!(TypeCheck.isBool(value) || value instanceof Boolean)){\n        throw new ValidationFail(\n          'Value needs to be a boolean',\n          '4304c51a-a48f-41d2-a2b8-9ba43c6617f3',\n        );\n      }\n      // primitive property\n      else if (this.property('primitive') && value instanceof Boolean){\n        throw new ValidationFail(\n          'Value needs to be a primitive',\n          '5decf593-f5a2-4368-a675-9b47256c395a',\n        );\n      }\n\n      return value;\n    });\n  }\n\n  /**\n   * Decodes the input value from the string representation ({@link _encode}) to the\n   * data type of the input. This method is called internally during {@link parseValue}\n   *\n   * @param {string} value - string containing the encoded value\n   * @return {bool}\n   * @protected\n   */\n  static _decode(value){\n    return value.toLowerCase() === 'true' || value === '1';\n  }\n\n  /**\n   * Encodes the input value to a string representation that can be later decoded\n   * through {@link _decode}. This method is called internally during the\n   * {@link serializeValue}\n   *\n   * @param {*} value - value that should be encoded to a string\n   * @return {string}\n   * @protected\n   */\n  static _encode(value){\n    return (value) ? '1' : '0';\n  }\n}\n\n// registering the input\nInput.register(Bool);\n\n// also, registering as 'boolean' for convenience\nInput.register(Bool, 'boolean');\n\n// registering properties\nInput.registerProperty(Bool, 'primitive', true);\n\nmodule.exports = Bool;\n",
    "static": true,
    "longname": "src/Inputs/Bool.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 275,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Inputs/Bool.js",
    "static": true,
    "longname": "src/Inputs/Bool.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Bool.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 276,
    "kind": "variable",
    "name": "__import_module__ValidationFail",
    "memberof": "src/Inputs/Bool.js",
    "static": true,
    "longname": "src/Inputs/Bool.js~__import_module__ValidationFail",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Bool.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 277,
    "kind": "variable",
    "name": "__import_module__Input",
    "memberof": "src/Inputs/Bool.js",
    "static": true,
    "longname": "src/Inputs/Bool.js~__import_module__Input",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Bool.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 278,
    "kind": "class",
    "name": "Bool",
    "memberof": "src/Inputs/Bool.js",
    "static": true,
    "longname": "src/Inputs/Bool.js~Bool",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Inputs/Bool.js",
    "importStyle": "Bool",
    "description": "Boolean input.\n\n```javascript\nconst input = Input.create('myInput: bool');\ninput.setValue(false);\n```\n\n```javascript\n// vector version\nconst input = Input.create('myInput: bool[]');\ninput.setValue([false, true, false]);\n```\n\n*This input can also be created using the alias:* `boolean`\n\n<h2>Property Summary</h2>\n\nProperty Name | Description | Defined&nbsp;by Default | Default Value\n--- | --- | :---: | :---:\nprimitive | ensures the value is a primitive | ::on:: | ::true::\n\nAll properties including the inherited ones can be listed via\n{@link registeredPropertyNames}",
    "lineNumber": 31,
    "interface": false,
    "extends": [
      "Input"
    ]
  },
  {
    "__docId__": 279,
    "kind": "method",
    "name": "_validation",
    "memberof": "src/Inputs/Bool.js~Bool",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/Bool.js~Bool#_validation",
    "access": "protected",
    "description": "Implements input's validations",
    "lineNumber": 41,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "value held by the input based on the current context (at)"
    }
  },
  {
    "__docId__": 280,
    "kind": "method",
    "name": "_decode",
    "memberof": "src/Inputs/Bool.js~Bool",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Inputs/Bool.js~Bool._decode",
    "access": "protected",
    "description": "Decodes the input value from the string representation ({@link _encode}) to the\ndata type of the input. This method is called internally during {@link parseValue}",
    "lineNumber": 73,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "string containing the encoded value"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "bool"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 281,
    "kind": "method",
    "name": "_encode",
    "memberof": "src/Inputs/Bool.js~Bool",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Inputs/Bool.js~Bool._encode",
    "access": "protected",
    "description": "Encodes the input value to a string representation that can be later decoded\nthrough {@link _decode}. This method is called internally during the\n{@link serializeValue}",
    "lineNumber": 86,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value that should be encoded to a string"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 282,
    "kind": "file",
    "name": "src/Inputs/Buf.js",
    "content": "const ValidationFail = require('../Errors/ValidationFail');\nconst Input = require('../Input');\n\n\n/**\n * Buffer input.\n *\n * ```javascript\n * const input = Input.create('myInput: buffer');\n * input.setValue(Buffer.from('test', 'ascii');\n * ```\n *\n * <h2>Property Summary</h2>\n *\n * Property Name | Description | Defined&nbsp;by Default | Default Value\n * --- | --- | :---: | :---:\n * hidden | boolean telling if the input is hidden from the {@link Reader}, \\\n * therefore it should only be used internally | ::on:: | ::true::\n * maxLength | maximum size of the buffer in bytes | ::off:: | ::none::\n *\n * All properties including the inherited ones can be listed via\n * {@link registeredPropertyNames}\n */\nclass Buf extends Input{\n\n  /**\n   * Returns if the input is empty\n   * @return {boolean}\n   */\n  isEmpty(){\n    return (super.isEmpty() || this.value().length === 0);\n  }\n\n  /**\n   * Implements input's validations\n   *\n   * @param {null|number} at - index used when input has been created as a vector that\n   * tells which value should be used\n   * @return {Promise<*>} value held by the input based on the current context (at)\n   * @protected\n   */\n  _validation(at){\n\n    // calling super class validations\n    return super._validation(at).then((value) => {\n\n      const maxLength = this.property('maxLength');\n\n      // type checking\n      if (!(value instanceof Buffer)){\n        throw new ValidationFail(\n          'Value needs to be a Buffer!',\n          '4c5c74ab-21f1-4df2-8985-8b4c030df3ed',\n        );\n      }\n\n      // specific type check\n      else if (maxLength !== null && value.length > maxLength){\n        throw new ValidationFail(\n          'Value exceeds the maximum length',\n          '4387c432-ffd6-48d6-a144-91566d262fa0',\n        );\n      }\n\n      return value;\n    });\n  }\n\n  /**\n   * Decodes the input value from the string representation ({@link _encode}) to the\n   * data type of the input. This method is called internally during {@link parseValue}\n   *\n   * @param {string} value - string containing the encoded value\n   * @return {bool}\n   * @protected\n   */\n  static _decode(value){\n    return Buffer.from(value, 'base64');\n  }\n\n  /**\n   * Encodes the input value to a string representation that can be later decoded\n   * through {@link _decode}. This method is called internally during the\n   * {@link serializeValue}\n   *\n   * @param {*} value - value that should be encoded to a string\n   * @return {string}\n   * @protected\n   */\n  static _encode(value){\n    return value.toString('base64');\n  }\n}\n\n// registering the input\nInput.register(Buf);\n\n// also, registering as 'string' for convenience\nInput.register(Buf, 'buffer');\n\n// registering properties\nInput.registerProperty(Buf, 'hidden', true);\nInput.registerProperty(Buf, 'maxLength');\n\nmodule.exports = Buf;\n",
    "static": true,
    "longname": "src/Inputs/Buf.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 283,
    "kind": "variable",
    "name": "__import_module__ValidationFail",
    "memberof": "src/Inputs/Buf.js",
    "static": true,
    "longname": "src/Inputs/Buf.js~__import_module__ValidationFail",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Buf.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 284,
    "kind": "variable",
    "name": "__import_module__Input",
    "memberof": "src/Inputs/Buf.js",
    "static": true,
    "longname": "src/Inputs/Buf.js~__import_module__Input",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Buf.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 285,
    "kind": "class",
    "name": "Buf",
    "memberof": "src/Inputs/Buf.js",
    "static": true,
    "longname": "src/Inputs/Buf.js~Buf",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Inputs/Buf.js",
    "importStyle": "Buf",
    "description": "Buffer input.\n\n```javascript\nconst input = Input.create('myInput: buffer');\ninput.setValue(Buffer.from('test', 'ascii');\n```\n\n<h2>Property Summary</h2>\n\nProperty Name | Description | Defined&nbsp;by Default | Default Value\n--- | --- | :---: | :---:\nhidden | boolean telling if the input is hidden from the {@link Reader},  therefore it should only be used internally | ::on:: | ::true::\nmaxLength | maximum size of the buffer in bytes | ::off:: | ::none::\n\nAll properties including the inherited ones can be listed via\n{@link registeredPropertyNames}",
    "lineNumber": 23,
    "interface": false,
    "extends": [
      "Input"
    ]
  },
  {
    "__docId__": 286,
    "kind": "method",
    "name": "isEmpty",
    "memberof": "src/Inputs/Buf.js~Buf",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/Buf.js~Buf#isEmpty",
    "access": null,
    "description": "Returns if the input is empty",
    "lineNumber": 29,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 287,
    "kind": "method",
    "name": "_validation",
    "memberof": "src/Inputs/Buf.js~Buf",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/Buf.js~Buf#_validation",
    "access": "protected",
    "description": "Implements input's validations",
    "lineNumber": 41,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "value held by the input based on the current context (at)"
    }
  },
  {
    "__docId__": 288,
    "kind": "method",
    "name": "_decode",
    "memberof": "src/Inputs/Buf.js~Buf",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Inputs/Buf.js~Buf._decode",
    "access": "protected",
    "description": "Decodes the input value from the string representation ({@link _encode}) to the\ndata type of the input. This method is called internally during {@link parseValue}",
    "lineNumber": 76,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "string containing the encoded value"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "bool"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 289,
    "kind": "method",
    "name": "_encode",
    "memberof": "src/Inputs/Buf.js~Buf",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Inputs/Buf.js~Buf._encode",
    "access": "protected",
    "description": "Encodes the input value to a string representation that can be later decoded\nthrough {@link _decode}. This method is called internally during the\n{@link serializeValue}",
    "lineNumber": 89,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value that should be encoded to a string"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 290,
    "kind": "file",
    "name": "src/Inputs/Email.js",
    "content": "const ValidationFail = require('../Errors/ValidationFail');\nconst Input = require('../Input');\nconst BaseText = require('./BaseText');\n\n\n/**\n * Email address input.\n *\n * ```javascript\n * const input = Input.create('myInput: email');\n * input.setValue('test@domain.com');\n * ```\n *\n * <h2>Property Summary</h2>\n * All properties including the inherited ones can be listed via\n * {@link registeredPropertyNames}\n */\nclass Email extends BaseText{\n\n  /**\n   * Implements input's validations\n   *\n   * @param {null|number} at - index used when input has been created as a vector that\n   * tells which value should be used\n   * @return {Promise<*>} value held by the input based on the current context (at)\n   * @protected\n   */\n  _validation(at){\n\n    // calling super class validations\n    return super._validation(at).then((value) => {\n\n      // format checking\n      if (!Email._emailFormatRegEx.test(value)){\n        throw new ValidationFail(\n          'Invalid email format',\n          '93d6f463-6650-46c8-bb9f-e5c3bc00d78e',\n        );\n      }\n\n      return value;\n    });\n  }\n\n  static _emailFormatRegEx = /^[a-zA-Z0-9.+/=?^_-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/;\n}\n\n// registering the input\nInput.register(Email);\n\nmodule.exports = Email;\n",
    "static": true,
    "longname": "src/Inputs/Email.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 291,
    "kind": "variable",
    "name": "__import_module__ValidationFail",
    "memberof": "src/Inputs/Email.js",
    "static": true,
    "longname": "src/Inputs/Email.js~__import_module__ValidationFail",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Email.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 292,
    "kind": "variable",
    "name": "__import_module__Input",
    "memberof": "src/Inputs/Email.js",
    "static": true,
    "longname": "src/Inputs/Email.js~__import_module__Input",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Email.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 293,
    "kind": "variable",
    "name": "__import_module__BaseText",
    "memberof": "src/Inputs/Email.js",
    "static": true,
    "longname": "src/Inputs/Email.js~__import_module__BaseText",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Email.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 294,
    "kind": "class",
    "name": "Email",
    "memberof": "src/Inputs/Email.js",
    "static": true,
    "longname": "src/Inputs/Email.js~Email",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Inputs/Email.js",
    "importStyle": "Email",
    "description": "Email address input.\n\n```javascript\nconst input = Input.create('myInput: email');\ninput.setValue('test@domain.com');\n```\n\n<h2>Property Summary</h2>\nAll properties including the inherited ones can be listed via\n{@link registeredPropertyNames}",
    "lineNumber": 18,
    "interface": false,
    "extends": [
      "BaseText"
    ]
  },
  {
    "__docId__": 295,
    "kind": "method",
    "name": "_validation",
    "memberof": "src/Inputs/Email.js~Email",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/Email.js~Email#_validation",
    "access": "protected",
    "description": "Implements input's validations",
    "lineNumber": 28,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "value held by the input based on the current context (at)"
    }
  },
  {
    "__docId__": 296,
    "kind": "member",
    "name": "_emailFormatRegEx",
    "memberof": "src/Inputs/Email.js~Email",
    "static": true,
    "longname": "src/Inputs/Email.js~Email._emailFormatRegEx",
    "access": null,
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "undefined"
      ]
    }
  },
  {
    "__docId__": 297,
    "kind": "file",
    "name": "src/Inputs/FilePath.js",
    "content": "const fs = require('fs');\nconst path = require('path');\nconst util = require('util');\nconst debug = require('debug')('Mebo');\nconst ValidationFail = require('../Errors/ValidationFail');\nconst Input = require('../Input');\nconst BaseText = require('./BaseText');\n\n// promisifying\nconst stat = util.promisify(fs.stat);\n\n\n/**\n* File Path input.\n*\n* ```javascript\n* const input = Input.create('myInput: filePath');\n* input.setValue('/tmp/foo.txt');\n* ```\n*\n* <h2>Property Summary</h2>\n*\n* Property Name | Description | Defined&nbsp;by Default | Default Value\n* --- | --- | :---: | :---:\n* restrictWebAccess | boolean telling if the input should have restrict access \\\n* when handling requests. When enabled it only lets the input to be set by a file upload, \\\n* making sure that the input cannot be set otherwise (like through a string) | ::on:: | ::true::\n* maxFileSize | maximum file size in bytes | ::off:: | ::none::\n* exists | checks if the file path exists | ::off:: | ::none::\n* allowedExtensions | specific list of extensions allowed by the input \\\n* (this check is case insensitive), example: ['jpg', 'png'] | ::off:: | ::none::\n*\n* All properties including the inherited ones can be listed via\n* {@link registeredPropertyNames}\n*/\nclass FilePath extends BaseText{\n\n  /**\n  * Returns either the extension of the file path or an empty string in case the\n  * file path does not have an extension\n  *\n  * ```javascript\n  * let myInput = Input.createInput('myInput: filePath');\n  * myInput.setValue('/tmp/file.jpg');\n  * console.log(myInput.extension()); // jpg\n  * ```\n  *\n  * @param {null|number} [at] - index used when input has been created as a vector that\n  * tells which value should be used\n  * @return {string}\n  */\n  extension(at=null){\n\n    let result = '';\n\n    if (!this.isEmpty()){\n      const value = this.valueAt(at);\n      const ext = path.extname(value);\n\n      if (ext.length > 1){\n        result = ext.slice(1);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n  * Returns the basename of the file path\n  *\n  * ```javascript\n  * const myInput = Input.createInput('myInput: filePath');\n  * myInput.setValue('/tmp/file.jpg');\n  * console.log(myInput.basename()); // 'file.jpg'\n  * ```\n  *\n  * @param {null|number} [at] - index used when input has been created as a vector that\n  * tells which value should be used\n  * @return {string}\n  */\n  basename(at=null){\n    return path.basename(this.valueAt(at));\n  }\n\n  /**\n  * Returns the dirname of the file path\n  *\n  * ```javascript\n  * let myInput = Input.createInput('myInput: filePath');\n  * myInput.setValue('/tmp/file.jpg');\n  * console.log(myInput.dirname()); // tmp\n  * ```\n  *\n  * @param {null|number} [at] - index used when input has been created as a vector that\n  * tells which value should be used\n  * @return {string}\n  */\n  dirname(at=null){\n    return path.dirname(this.valueAt(at));\n  }\n\n  /**\n  * Returns the file stats\n  *\n  * @param {null|number} [at] - index used when input has been created as a vector that\n  * tells which value should be used\n  * @return {Promise<Object>}\n  */\n  async stat(at=null){\n\n    // returning from cache\n    if (this._isCached('stats', at)){\n      return this._getFromCache('stats', at);\n    }\n\n    // otherwise processing stats\n    const stats = await stat(this.valueAt(at));\n    this._setToCache('stats', stats, at);\n    return stats;\n  }\n\n  /**\n   * Implements input's validations\n   *\n   * @param {null|number} at - index used when input has been created as a vector that\n   * tells which value should be used\n   * @return {Promise<*>} value held by the input based on the current context (at)\n   * @protected\n   */\n  async _validation(at){\n\n    // calling super class validations\n    // todo: babel does not support 'await' calling a method under 'super'\n    // https://github.com/babel/babel/issues/3930\n    // const value = await super._validation(at);\n    const value = await BaseText.prototype._validation.call(this, at);\n\n    // only specific extensions\n    if (this.property('allowedExtensions') && !this.property('allowedExtensions').map(x => x.toLowerCase()).includes(this.extension(at).toLowerCase())){\n      throw new ValidationFail(\n        util.format(\"Extension '%s' is not supported! (supported extensions: %s)\", this.extension(at), this.property('allowedExtensions')),\n        '05139388-f4ec-4496-be20-f794eb14d1ff',\n      );\n    }\n\n    // file exists & max size\n    if (this.property('exists') || this.property('maxFileSize')){\n\n      let stats = null;\n      let err = null;\n      try{\n        stats = await this.stat(at);\n      }\n      catch(errr){\n        err = errr;\n        debug(err);\n      }\n\n      if (this.property('exists') && err && err.code === 'ENOENT'){\n        err = new ValidationFail(\n          'File does not exist',\n          'dedf89bc-c57a-4ce7-ab84-f84f49144230',\n        );\n      }\n      else if (stats !== null && this.property('maxFileSize') && stats.size > this.property('maxFileSize')){\n        err = new ValidationFail(\n          util.format('File size (%.1f mb) exceeds the limit allowed (%.1f mb)', stats.size/1024/1024, this.property('maxFileSize')/1024/1024),\n          '99c3aeff-241b-4120-a708-d2e1ca1a1dce',\n        );\n      }\n\n      if (err){\n        throw (err);\n      }\n    }\n\n    return value;\n  }\n}\n\n// registering the input\nInput.register(FilePath);\n\n// registering properties\nInput.registerProperty(FilePath, 'maxFileSize');\nInput.registerProperty(FilePath, 'exists');\nInput.registerProperty(FilePath, 'allowedExtensions');\n\nmodule.exports = FilePath;\n",
    "static": true,
    "longname": "src/Inputs/FilePath.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 298,
    "kind": "variable",
    "name": "__import_module__fs",
    "memberof": "src/Inputs/FilePath.js",
    "static": true,
    "longname": "src/Inputs/FilePath.js~__import_module__fs",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/FilePath.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 299,
    "kind": "variable",
    "name": "__import_module__path",
    "memberof": "src/Inputs/FilePath.js",
    "static": true,
    "longname": "src/Inputs/FilePath.js~__import_module__path",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/FilePath.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 300,
    "kind": "variable",
    "name": "__import_module__util",
    "memberof": "src/Inputs/FilePath.js",
    "static": true,
    "longname": "src/Inputs/FilePath.js~__import_module__util",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/FilePath.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 301,
    "kind": "variable",
    "name": "__import_module__debug",
    "memberof": "src/Inputs/FilePath.js",
    "static": true,
    "longname": "src/Inputs/FilePath.js~__import_module__debug",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/FilePath.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 302,
    "kind": "variable",
    "name": "__import_module__ValidationFail",
    "memberof": "src/Inputs/FilePath.js",
    "static": true,
    "longname": "src/Inputs/FilePath.js~__import_module__ValidationFail",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/FilePath.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 303,
    "kind": "variable",
    "name": "__import_module__Input",
    "memberof": "src/Inputs/FilePath.js",
    "static": true,
    "longname": "src/Inputs/FilePath.js~__import_module__Input",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/FilePath.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 304,
    "kind": "variable",
    "name": "__import_module__BaseText",
    "memberof": "src/Inputs/FilePath.js",
    "static": true,
    "longname": "src/Inputs/FilePath.js~__import_module__BaseText",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/FilePath.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 305,
    "kind": "variable",
    "name": "stat",
    "memberof": "src/Inputs/FilePath.js",
    "static": true,
    "longname": "src/Inputs/FilePath.js~stat",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/FilePath.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 306,
    "kind": "class",
    "name": "FilePath",
    "memberof": "src/Inputs/FilePath.js",
    "static": true,
    "longname": "src/Inputs/FilePath.js~FilePath",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Inputs/FilePath.js",
    "importStyle": "FilePath",
    "description": "File Path input.\n\n```javascript\nconst input = Input.create('myInput: filePath');\ninput.setValue('/tmp/foo.txt');\n```\n\n<h2>Property Summary</h2>\n\nProperty Name | Description | Defined&nbsp;by Default | Default Value\n--- | --- | :---: | :---:\nrestrictWebAccess | boolean telling if the input should have restrict access when handling requests. When enabled it only lets the input to be set by a file upload, making sure that the input cannot be set otherwise (like through a string) | ::on:: | ::true::\nmaxFileSize | maximum file size in bytes | ::off:: | ::none::\nexists | checks if the file path exists | ::off:: | ::none::\nallowedExtensions | specific list of extensions allowed by the input (this check is case insensitive), example: ['jpg', 'png'] | ::off:: | ::none::\n\nAll properties including the inherited ones can be listed via\n{@link registeredPropertyNames}",
    "lineNumber": 33,
    "interface": false,
    "extends": [
      "BaseText"
    ]
  },
  {
    "__docId__": 307,
    "kind": "method",
    "name": "extension",
    "memberof": "src/Inputs/FilePath.js~FilePath",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/FilePath.js~FilePath#extension",
    "access": null,
    "description": "Returns either the extension of the file path or an empty string in case the\nfile path does not have an extension\n\n```javascript\nlet myInput = Input.createInput('myInput: filePath');\nmyInput.setValue('/tmp/file.jpg');\nconsole.log(myInput.extension()); // jpg\n```",
    "lineNumber": 49,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 308,
    "kind": "method",
    "name": "basename",
    "memberof": "src/Inputs/FilePath.js~FilePath",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/FilePath.js~FilePath#basename",
    "access": null,
    "description": "Returns the basename of the file path\n\n```javascript\nconst myInput = Input.createInput('myInput: filePath');\nmyInput.setValue('/tmp/file.jpg');\nconsole.log(myInput.basename()); // 'file.jpg'\n```",
    "lineNumber": 78,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 309,
    "kind": "method",
    "name": "dirname",
    "memberof": "src/Inputs/FilePath.js~FilePath",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/FilePath.js~FilePath#dirname",
    "access": null,
    "description": "Returns the dirname of the file path\n\n```javascript\nlet myInput = Input.createInput('myInput: filePath');\nmyInput.setValue('/tmp/file.jpg');\nconsole.log(myInput.dirname()); // tmp\n```",
    "lineNumber": 95,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 310,
    "kind": "method",
    "name": "stat",
    "memberof": "src/Inputs/FilePath.js~FilePath",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Inputs/FilePath.js~FilePath#stat",
    "access": null,
    "description": "Returns the file stats",
    "lineNumber": 106,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Object>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 311,
    "kind": "method",
    "name": "_validation",
    "memberof": "src/Inputs/FilePath.js~FilePath",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Inputs/FilePath.js~FilePath#_validation",
    "access": "protected",
    "description": "Implements input's validations",
    "lineNumber": 127,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "value held by the input based on the current context (at)"
    }
  },
  {
    "__docId__": 312,
    "kind": "file",
    "name": "src/Inputs/Hash.js",
    "content": "const crypto = require('crypto');\nconst TypeCheck = require('js-typecheck');\nconst ValidationFail = require('../Errors/ValidationFail');\nconst Input = require('../Input');\nconst Hex = require('./Hex');\n\n\n/**\n * Hash input.\n *\n * ```javascript\n * const input = Input.create('myInput: hash', {size: 64});\n * input.setValue('b542f74248124c32');\n * ```\n *\n * <h2>Property Summary</h2>\n *\n * Property Name | Description | Defined&nbsp;by Default | Default Value\n * --- | --- | :---: | :---:\n * size | bit size of the hash. This property needs to be defined at constructor \\\n *  time | ::true:: | ::none::\n *\n * All properties including the inherited ones can be listed via\n * {@link registeredPropertyNames}\n */\nclass Hash extends Hex{\n\n  constructor(...args){\n    super(...args);\n\n    // making sure 'size' property has been defined\n    if (TypeCheck.isNone(this.property('size'))){\n      throw new Error(`Can't create a hash input (${this.name()}) without the 'size' property!`);\n    }\n\n    // locking the 'size' property\n    this.lockProperty('size');\n  }\n\n  /**\n   * Generates a new random hash and assigns it to the value of the input. This method\n   * is not supported by vector inputs.\n   */\n  setRandom(){\n    if (this.isVector()){\n      throw new Error('Not supported, input is a vector!');\n    }\n\n    const size = this.property('size', 0) / 8;\n    this.setValue(crypto.randomBytes(size).toString('hex'));\n  }\n\n  /**\n   * Implements input's validations\n   *\n   * @param {null|number} at - index used when input has been created as a vector that\n   * tells which value should be used\n   * @return {Promise<*>} value held by the input based on the current context (at)\n   * @protected\n   */\n  _validation(at){\n\n    // calling super class validations\n    return super._validation(at).then((value) => {\n\n      // size checking\n      if (this.property('size') !== (value.length / 2) * 8){\n        throw new ValidationFail(\n          'Invalid hash size',\n          'c83d98b0-8409-47c3-89c9-f81452c910c0',\n        );\n      }\n\n      return value;\n    });\n  }\n}\n\n// registering the input\nInput.register(Hash);\n\nmodule.exports = Hash;\n",
    "static": true,
    "longname": "src/Inputs/Hash.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 313,
    "kind": "variable",
    "name": "__import_module__crypto",
    "memberof": "src/Inputs/Hash.js",
    "static": true,
    "longname": "src/Inputs/Hash.js~__import_module__crypto",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Hash.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 314,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Inputs/Hash.js",
    "static": true,
    "longname": "src/Inputs/Hash.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Hash.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 315,
    "kind": "variable",
    "name": "__import_module__ValidationFail",
    "memberof": "src/Inputs/Hash.js",
    "static": true,
    "longname": "src/Inputs/Hash.js~__import_module__ValidationFail",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Hash.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 316,
    "kind": "variable",
    "name": "__import_module__Input",
    "memberof": "src/Inputs/Hash.js",
    "static": true,
    "longname": "src/Inputs/Hash.js~__import_module__Input",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Hash.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 317,
    "kind": "variable",
    "name": "__import_module__Hex",
    "memberof": "src/Inputs/Hash.js",
    "static": true,
    "longname": "src/Inputs/Hash.js~__import_module__Hex",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Hash.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 318,
    "kind": "class",
    "name": "Hash",
    "memberof": "src/Inputs/Hash.js",
    "static": true,
    "longname": "src/Inputs/Hash.js~Hash",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Inputs/Hash.js",
    "importStyle": "Hash",
    "description": "Hash input.\n\n```javascript\nconst input = Input.create('myInput: hash', {size: 64});\ninput.setValue('b542f74248124c32');\n```\n\n<h2>Property Summary</h2>\n\nProperty Name | Description | Defined&nbsp;by Default | Default Value\n--- | --- | :---: | :---:\nsize | bit size of the hash. This property needs to be defined at constructor   time | ::true:: | ::none::\n\nAll properties including the inherited ones can be listed via\n{@link registeredPropertyNames}",
    "lineNumber": 25,
    "interface": false,
    "extends": [
      "Hex"
    ]
  },
  {
    "__docId__": 319,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Inputs/Hash.js~Hash",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/Hash.js~Hash#constructor",
    "access": null,
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ]
  },
  {
    "__docId__": 320,
    "kind": "method",
    "name": "setRandom",
    "memberof": "src/Inputs/Hash.js~Hash",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/Hash.js~Hash#setRandom",
    "access": null,
    "description": "Generates a new random hash and assigns it to the value of the input. This method\nis not supported by vector inputs.",
    "lineNumber": 43,
    "params": []
  },
  {
    "__docId__": 321,
    "kind": "method",
    "name": "_validation",
    "memberof": "src/Inputs/Hash.js~Hash",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/Hash.js~Hash#_validation",
    "access": "protected",
    "description": "Implements input's validations",
    "lineNumber": 60,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "value held by the input based on the current context (at)"
    }
  },
  {
    "__docId__": 322,
    "kind": "file",
    "name": "src/Inputs/Hex.js",
    "content": "const assert = require('assert');\nconst TypeCheck = require('js-typecheck');\nconst ValidationFail = require('../Errors/ValidationFail');\nconst Input = require('../Input');\nconst BaseText = require('./BaseText');\n\n\n/**\n * Hexadecimal input.\n *\n * ```javascript\n * const input = Input.create('myInput: hex');\n * input.setValue('ffff00');\n * ```\n *\n * <h2>Property Summary</h2>\n *\n * Property Name | Description | Defined&nbsp;by Default | Default Value\n * --- | --- | :---: | :---:\n * size | optional maximum bit size of the value | ::none:: | ::none::\n *\n * All properties including the inherited ones can be listed via\n * {@link registeredPropertyNames}\n */\nclass Hex extends BaseText{\n\n  /**\n   * Returns the current value in decimal\n   *\n   * @return {number}\n   */\n  decimalValue(){\n    const currentValue = this.value();\n    assert(Hex._isHexValue(currentValue), 'Current value is not hexadecimal');\n\n    return parseInt(currentValue, 16);\n  }\n\n  /**\n   * Sets the current value from a decimal number\n   *\n   * @param {number} value - decimal value\n   */\n  setValueFromDecimal(value){\n    assert(TypeCheck.isNumber(value), 'Value needs to be a number');\n\n    this.setValue(value.toString(16));\n  }\n\n  /**\n   * Implements input's validations\n   *\n   * @param {null|number} at - index used when input has been created as a vector that\n   * tells which value should be used\n   * @return {Promise<*>} value held by the input based on the current context (at)\n   * @protected\n   */\n  _validation(at){\n\n    // calling super class validations\n    return super._validation(at).then((value) => {\n\n      // hex value checking\n      if (!Hex._isHexValue(value)){\n        throw new ValidationFail(\n          'Invalid hex value',\n          '1747c406-2a14-4d0f-8a1d-1c554763e8a3',\n        );\n      }\n      // value size checking\n      else if (this.property('size') && (value.length / 2) * 8 > this.property('size')){\n        throw new ValidationFail(\n          'Value exceeds the maximum bit size',\n          '0f8d2885-a4ac-4b7f-bb5b-32466c85363a',\n        );\n      }\n\n      return value;\n    });\n  }\n\n  /**\n   * Auxiliary method that returns a boolean telling if the value is a valid\n   * Hexadecimal value.\n   *\n   * @param {string} value - string containing the hex value\n   * @return {boolean}\n   * @private\n   */\n  static _isHexValue(value){\n    return (TypeCheck.isString(value) && this._uuidFormatRegEx.test(value));\n  }\n\n  static _uuidFormatRegEx = /^[0-9a-fA-F]+$/;\n}\n\n// registering the input\nInput.register(Hex);\n\n// registering properties\nInput.registerProperty(Hex, 'size');\n\nmodule.exports = Hex;\n",
    "static": true,
    "longname": "src/Inputs/Hex.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 323,
    "kind": "variable",
    "name": "__import_module__assert",
    "memberof": "src/Inputs/Hex.js",
    "static": true,
    "longname": "src/Inputs/Hex.js~__import_module__assert",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Hex.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 324,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Inputs/Hex.js",
    "static": true,
    "longname": "src/Inputs/Hex.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Hex.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 325,
    "kind": "variable",
    "name": "__import_module__ValidationFail",
    "memberof": "src/Inputs/Hex.js",
    "static": true,
    "longname": "src/Inputs/Hex.js~__import_module__ValidationFail",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Hex.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 326,
    "kind": "variable",
    "name": "__import_module__Input",
    "memberof": "src/Inputs/Hex.js",
    "static": true,
    "longname": "src/Inputs/Hex.js~__import_module__Input",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Hex.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 327,
    "kind": "variable",
    "name": "__import_module__BaseText",
    "memberof": "src/Inputs/Hex.js",
    "static": true,
    "longname": "src/Inputs/Hex.js~__import_module__BaseText",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Hex.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 328,
    "kind": "class",
    "name": "Hex",
    "memberof": "src/Inputs/Hex.js",
    "static": true,
    "longname": "src/Inputs/Hex.js~Hex",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Inputs/Hex.js",
    "importStyle": "Hex",
    "description": "Hexadecimal input.\n\n```javascript\nconst input = Input.create('myInput: hex');\ninput.setValue('ffff00');\n```\n\n<h2>Property Summary</h2>\n\nProperty Name | Description | Defined&nbsp;by Default | Default Value\n--- | --- | :---: | :---:\nsize | optional maximum bit size of the value | ::none:: | ::none::\n\nAll properties including the inherited ones can be listed via\n{@link registeredPropertyNames}",
    "lineNumber": 25,
    "interface": false,
    "extends": [
      "BaseText"
    ]
  },
  {
    "__docId__": 329,
    "kind": "method",
    "name": "decimalValue",
    "memberof": "src/Inputs/Hex.js~Hex",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/Hex.js~Hex#decimalValue",
    "access": null,
    "description": "Returns the current value in decimal",
    "lineNumber": 32,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 330,
    "kind": "method",
    "name": "setValueFromDecimal",
    "memberof": "src/Inputs/Hex.js~Hex",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/Hex.js~Hex#setValueFromDecimal",
    "access": null,
    "description": "Sets the current value from a decimal number",
    "lineNumber": 44,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "decimal value"
      }
    ]
  },
  {
    "__docId__": 331,
    "kind": "method",
    "name": "_validation",
    "memberof": "src/Inputs/Hex.js~Hex",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/Hex.js~Hex#_validation",
    "access": "protected",
    "description": "Implements input's validations",
    "lineNumber": 58,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "value held by the input based on the current context (at)"
    }
  },
  {
    "__docId__": 332,
    "kind": "method",
    "name": "_isHexValue",
    "memberof": "src/Inputs/Hex.js~Hex",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Inputs/Hex.js~Hex._isHexValue",
    "access": "private",
    "description": "Auxiliary method that returns a boolean telling if the value is a valid\nHexadecimal value.",
    "lineNumber": 90,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "string containing the hex value"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 333,
    "kind": "member",
    "name": "_uuidFormatRegEx",
    "memberof": "src/Inputs/Hex.js~Hex",
    "static": true,
    "longname": "src/Inputs/Hex.js~Hex._uuidFormatRegEx",
    "access": null,
    "description": null,
    "lineNumber": 94,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "undefined"
      ]
    }
  },
  {
    "__docId__": 334,
    "kind": "file",
    "name": "src/Inputs/Ip.js",
    "content": "const nodeIp = require('ip');\nconst ValidationFail = require('../Errors/ValidationFail');\nconst Input = require('../Input');\nconst BaseText = require('./BaseText');\n\n\n/**\n * Ip address input.\n *\n * ```javascript\n * // ipv4\n * const input = Input.create('myInput: ip');\n * input.setValue('192.168.0.1');\n * ```\n *\n * ```javascript\n * // ipv6\n * const input = Input.create('myInput: ip');\n * input.setValue('::ffff:127.0.0.1');\n * ```\n *\n * ```javascript\n * // initializes the value of the input with 'remoteAddress'\n * // which is defined by the web handler\n * const input = Input.create('myInput: ip', {autofill: 'remoteAddress'});\n * console.log(input.value());\n * ```\n *\n * <h2>Property Summary</h2>\n *\n * Property Name | Description | Defined&nbsp;by Default | Default Value\n * --- | --- | :---: | :---:\n * allowV6 | boolean telling if the input allows ipv6 | ::on:: | ::true::\n *\n * All properties including the inherited ones can be listed via\n * {@link registeredPropertyNames}\n */\nclass Ip extends BaseText{\n\n  /**\n   * Returns a boolean telling if the value is ipv4\n   *\n   * @param {null|number} [at] - index used when input has been created as a vector that\n   * tells which value should be used\n   * @return {boolean}\n   */\n  isV4(at=null){\n\n    const value = this.valueAt(at);\n    return nodeIp.isV4Format(value);\n  }\n\n  /**\n   * Returns a boolean telling if the value is ipv6\n   *\n   * @param {null|number} [at] - index used when input has been created as a vector that\n   * tells which value should be used\n   * @return {boolean}\n   */\n  isV6(at=null){\n\n    const value = this.valueAt(at);\n    return nodeIp.isV6Format(value);\n  }\n\n  /**\n   * Returns a boolean telling if the value is a private ip address\n   *\n   * @param {null|number} [at] - index used when input has been created as a vector that\n   * tells which value should be used\n   * @return {boolean}\n   */\n  isPrivate(at=null){\n\n    const value = this.valueAt(at);\n    return nodeIp.isPrivate(value);\n  }\n\n  /**\n   * Implements input's validations\n   *\n   * @param {null|number} at - index used when input has been created as a vector that\n   * tells which value should be used\n   * @return {Promise<*>} value held by the input based on the current context (at)\n   * @protected\n   */\n  _validation(at){\n\n    // calling super class validations\n    return super._validation(at).then((value) => {\n\n      // checking ip version\n      if (!(this.isV4(at) || (this.property('allowV6') && this.isV6(at)))){\n        throw new ValidationFail(\n          'Invalid ip!',\n          '54cb9e90-468e-49ea-8f34-512a7b729d28',\n        );\n      }\n\n      return value;\n    });\n  }\n}\n\n// registering the input\nInput.register(Ip);\n\n// registering properties\nInput.registerProperty(Ip, 'allowV6', true);\n\nmodule.exports = Ip;\n",
    "static": true,
    "longname": "src/Inputs/Ip.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 335,
    "kind": "variable",
    "name": "__import_module__nodeIp",
    "memberof": "src/Inputs/Ip.js",
    "static": true,
    "longname": "src/Inputs/Ip.js~__import_module__nodeIp",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Ip.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 336,
    "kind": "variable",
    "name": "__import_module__ValidationFail",
    "memberof": "src/Inputs/Ip.js",
    "static": true,
    "longname": "src/Inputs/Ip.js~__import_module__ValidationFail",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Ip.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 337,
    "kind": "variable",
    "name": "__import_module__Input",
    "memberof": "src/Inputs/Ip.js",
    "static": true,
    "longname": "src/Inputs/Ip.js~__import_module__Input",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Ip.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 338,
    "kind": "variable",
    "name": "__import_module__BaseText",
    "memberof": "src/Inputs/Ip.js",
    "static": true,
    "longname": "src/Inputs/Ip.js~__import_module__BaseText",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Ip.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 339,
    "kind": "class",
    "name": "Ip",
    "memberof": "src/Inputs/Ip.js",
    "static": true,
    "longname": "src/Inputs/Ip.js~Ip",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Inputs/Ip.js",
    "importStyle": "Ip",
    "description": "Ip address input.\n\n```javascript\n// ipv4\nconst input = Input.create('myInput: ip');\ninput.setValue('192.168.0.1');\n```\n\n```javascript\n// ipv6\nconst input = Input.create('myInput: ip');\ninput.setValue('::ffff:127.0.0.1');\n```\n\n```javascript\n// initializes the value of the input with 'remoteAddress'\n// which is defined by the web handler\nconst input = Input.create('myInput: ip', {autofill: 'remoteAddress'});\nconsole.log(input.value());\n```\n\n<h2>Property Summary</h2>\n\nProperty Name | Description | Defined&nbsp;by Default | Default Value\n--- | --- | :---: | :---:\nallowV6 | boolean telling if the input allows ipv6 | ::on:: | ::true::\n\nAll properties including the inherited ones can be listed via\n{@link registeredPropertyNames}",
    "lineNumber": 38,
    "interface": false,
    "extends": [
      "BaseText"
    ]
  },
  {
    "__docId__": 340,
    "kind": "method",
    "name": "isV4",
    "memberof": "src/Inputs/Ip.js~Ip",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/Ip.js~Ip#isV4",
    "access": null,
    "description": "Returns a boolean telling if the value is ipv4",
    "lineNumber": 47,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 341,
    "kind": "method",
    "name": "isV6",
    "memberof": "src/Inputs/Ip.js~Ip",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/Ip.js~Ip#isV6",
    "access": null,
    "description": "Returns a boolean telling if the value is ipv6",
    "lineNumber": 60,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 342,
    "kind": "method",
    "name": "isPrivate",
    "memberof": "src/Inputs/Ip.js~Ip",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/Ip.js~Ip#isPrivate",
    "access": null,
    "description": "Returns a boolean telling if the value is a private ip address",
    "lineNumber": 73,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 343,
    "kind": "method",
    "name": "_validation",
    "memberof": "src/Inputs/Ip.js~Ip",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/Ip.js~Ip#_validation",
    "access": "protected",
    "description": "Implements input's validations",
    "lineNumber": 87,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "value held by the input based on the current context (at)"
    }
  },
  {
    "__docId__": 344,
    "kind": "file",
    "name": "src/Inputs/Numeric.js",
    "content": "const util = require('util');\nconst TypeCheck = require('js-typecheck');\nconst ValidationFail = require('../Errors/ValidationFail');\nconst Input = require('../Input');\n\n\n/**\n * Numeric input.\n *\n * ```javascript\n * const input = Input.create('myInput: numeric');\n * input.setValue(5);\n * ```\n *\n * *This input can also be created using the alias:* `number`\n *\n * <h2>Property Summary</h2>\n *\n * Property Name | Description | Defined&nbsp;by Default | Default Value\n * --- | --- | :---: | :---:\n * primitive | ensures the value is a primitive | ::on:: | ::true::\n * min | minimum allowed value | ::off:: | ::none::\n * max | maximum allowed value | ::off:: | ::none::\n *\n * All properties including the inherited ones can be listed via\n * {@link registeredPropertyNames}\n */\nclass Numeric extends Input{\n\n  /**\n   * Implements input's validations\n   *\n   * @param {null|number} at - index used when input has been created as a vector that\n   * tells which value should be used\n   * @return {Promise<*>} value held by the input based on the current context (at)\n   * @protected\n   */\n  _validation(at){\n\n    // calling super class validations\n    return super._validation(at).then((value) => {\n\n      // type checking\n      if (!(TypeCheck.isNumber(value) || value instanceof Number)){\n        throw new ValidationFail(\n          'Value needs to be a number',\n          'b9f7f1bf-18a3-45f8-83d0-aa8f34f819f6',\n        );\n      }\n      // primitive property\n      else if (this.property('primitive') && value instanceof Number){\n        throw new ValidationFail(\n          'Value needs to be a primitive',\n          '2e2e4535-f346-4829-9cd1-ced2b8969c9e',\n        );\n      }\n      // min property\n      else if (this.hasProperty('min') && value < this.property('min')){\n        throw new ValidationFail(\n          util.format('Value needs to be greater or equal to the minimum: %d', this.property('min')),\n          '12e85420-04ae-4ef0-b64c-400b68bced3c',\n        );\n      }\n      // max property\n      else if (this.hasProperty('max') && value > this.property('max')){\n        throw new ValidationFail(\n          util.format('Value needs to be less or equal to the maximum: %d', this.property('max')),\n          'd1d3ffc2-67e9-4404-873c-199603ca7632',\n        );\n      }\n\n      return value;\n    });\n  }\n\n  /**\n   * Decodes the value by casting it to the type that is compatible with the input\n   *\n   * @param {string} value - string containing the encoded value\n   * @return {number}\n   * @protected\n   */\n  static _decode(value){\n    return Number(value);\n  }\n}\n\n// registering the input\nInput.register(Numeric);\n\n// also, registering as 'number' for convenience\nInput.register(Numeric, 'number');\n\n// registering properties\nInput.registerProperty(Numeric, 'primitive', true);\nInput.registerProperty(Numeric, 'min');\nInput.registerProperty(Numeric, 'max');\n\nmodule.exports = Numeric;\n",
    "static": true,
    "longname": "src/Inputs/Numeric.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 345,
    "kind": "variable",
    "name": "__import_module__util",
    "memberof": "src/Inputs/Numeric.js",
    "static": true,
    "longname": "src/Inputs/Numeric.js~__import_module__util",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Numeric.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 346,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Inputs/Numeric.js",
    "static": true,
    "longname": "src/Inputs/Numeric.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Numeric.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 347,
    "kind": "variable",
    "name": "__import_module__ValidationFail",
    "memberof": "src/Inputs/Numeric.js",
    "static": true,
    "longname": "src/Inputs/Numeric.js~__import_module__ValidationFail",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Numeric.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 348,
    "kind": "variable",
    "name": "__import_module__Input",
    "memberof": "src/Inputs/Numeric.js",
    "static": true,
    "longname": "src/Inputs/Numeric.js~__import_module__Input",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Numeric.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 349,
    "kind": "class",
    "name": "Numeric",
    "memberof": "src/Inputs/Numeric.js",
    "static": true,
    "longname": "src/Inputs/Numeric.js~Numeric",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Inputs/Numeric.js",
    "importStyle": "Numeric",
    "description": "Numeric input.\n\n```javascript\nconst input = Input.create('myInput: numeric');\ninput.setValue(5);\n```\n\n*This input can also be created using the alias:* `number`\n\n<h2>Property Summary</h2>\n\nProperty Name | Description | Defined&nbsp;by Default | Default Value\n--- | --- | :---: | :---:\nprimitive | ensures the value is a primitive | ::on:: | ::true::\nmin | minimum allowed value | ::off:: | ::none::\nmax | maximum allowed value | ::off:: | ::none::\n\nAll properties including the inherited ones can be listed via\n{@link registeredPropertyNames}",
    "lineNumber": 28,
    "interface": false,
    "extends": [
      "Input"
    ]
  },
  {
    "__docId__": 350,
    "kind": "method",
    "name": "_validation",
    "memberof": "src/Inputs/Numeric.js~Numeric",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/Numeric.js~Numeric#_validation",
    "access": "protected",
    "description": "Implements input's validations",
    "lineNumber": 38,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "value held by the input based on the current context (at)"
    }
  },
  {
    "__docId__": 351,
    "kind": "method",
    "name": "_decode",
    "memberof": "src/Inputs/Numeric.js~Numeric",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Inputs/Numeric.js~Numeric._decode",
    "access": "protected",
    "description": "Decodes the value by casting it to the type that is compatible with the input",
    "lineNumber": 83,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "string containing the encoded value"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 352,
    "kind": "file",
    "name": "src/Inputs/Stream.js",
    "content": "const StreamModule = require('stream');\nconst ValidationFail = require('../Errors/ValidationFail');\nconst Input = require('../Input');\n\n\n/**\n * Stream input.\n *\n * ```javascript\n * const input = Input.create('myInput: stream');\n * //...\n * input.setValue(fs.createReadStream('file.txt'));\n * ```\n *\n * <h2>Property Summary</h2>\n *\n * Property Name | Description | Defined&nbsp;by Default | Default Value\n * --- | --- | :---: | :---:\n * hidden | boolean telling if the input is hidden from the {@link Reader}, \\\n * therefore it should only be used internally | ::on:: | ::true::\n * streamType | specific stream type allowed by the input: `readable`, `writable`, \\\n * `duplex` and `transform` | ::off:: | ::none::\n *\n * All properties including the inherited ones can be listed via\n * {@link registeredPropertyNames}\n */\nclass Stream extends Input{\n\n  /**\n   * Implements input's validations\n   *\n   * @param {null|number} at - index used when input has been created as a vector that\n   * tells which value should be used\n   * @return {Promise<*>} value held by the input based on the current context (at)\n   * @protected\n   */\n  _validation(at){\n\n    return super._validation(at).then((value) => {\n\n      // type checking\n      if (!(value instanceof StreamModule)){\n        throw new ValidationFail(\n          'Value needs to be an instance of stream!',\n          '0d891ebd-e494-4439-87c6-2a6fa96e7bcc',\n        );\n      }\n\n      // specific type check\n      else if (this.property('streamType')){\n\n        let success = false;\n        const streamType = this.property('streamType');\n        if (streamType === 'readable' && value instanceof StreamModule.Readable){\n          success = true;\n        }\n        else if (streamType === 'writable' && value instanceof StreamModule.Writable){\n          success = true;\n        }\n        else if (streamType === 'duplex' && value instanceof StreamModule.Duplex){\n          success = true;\n        }\n        else if (streamType === 'transform' && value instanceof StreamModule.Transform){\n          success = true;\n        }\n\n        if (!success){\n          throw new ValidationFail(\n            'Invalid stream type!',\n            '21e29315-d2d0-412a-a000-dc6e9852b94e',\n          );\n        }\n      }\n\n      return value;\n    });\n  }\n\n  /**\n   * Serialization is not supported\n   *\n   * @return {boolean}\n   */\n  isSerializable(){\n    return false;\n  }\n}\n\n// registering the input\nInput.register(Stream);\n\n// registering properties\nInput.registerProperty(Stream, 'hidden', true);\nInput.registerProperty(Stream, 'streamType');\n\nmodule.exports = Stream;\n",
    "static": true,
    "longname": "src/Inputs/Stream.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 353,
    "kind": "variable",
    "name": "__import_module__StreamModule",
    "memberof": "src/Inputs/Stream.js",
    "static": true,
    "longname": "src/Inputs/Stream.js~__import_module__StreamModule",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Stream.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 354,
    "kind": "variable",
    "name": "__import_module__ValidationFail",
    "memberof": "src/Inputs/Stream.js",
    "static": true,
    "longname": "src/Inputs/Stream.js~__import_module__ValidationFail",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Stream.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 355,
    "kind": "variable",
    "name": "__import_module__Input",
    "memberof": "src/Inputs/Stream.js",
    "static": true,
    "longname": "src/Inputs/Stream.js~__import_module__Input",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Stream.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 356,
    "kind": "class",
    "name": "Stream",
    "memberof": "src/Inputs/Stream.js",
    "static": true,
    "longname": "src/Inputs/Stream.js~Stream",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Inputs/Stream.js",
    "importStyle": "Stream",
    "description": "Stream input.\n\n```javascript\nconst input = Input.create('myInput: stream');\n//...\ninput.setValue(fs.createReadStream('file.txt'));\n```\n\n<h2>Property Summary</h2>\n\nProperty Name | Description | Defined&nbsp;by Default | Default Value\n--- | --- | :---: | :---:\nhidden | boolean telling if the input is hidden from the {@link Reader},  therefore it should only be used internally | ::on:: | ::true::\nstreamType | specific stream type allowed by the input: `readable`, `writable`,  `duplex` and `transform` | ::off:: | ::none::\n\nAll properties including the inherited ones can be listed via\n{@link registeredPropertyNames}",
    "lineNumber": 25,
    "interface": false,
    "extends": [
      "Input"
    ]
  },
  {
    "__docId__": 357,
    "kind": "method",
    "name": "_validation",
    "memberof": "src/Inputs/Stream.js~Stream",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/Stream.js~Stream#_validation",
    "access": "protected",
    "description": "Implements input's validations",
    "lineNumber": 35,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "value held by the input based on the current context (at)"
    }
  },
  {
    "__docId__": 358,
    "kind": "method",
    "name": "isSerializable",
    "memberof": "src/Inputs/Stream.js~Stream",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/Stream.js~Stream#isSerializable",
    "access": null,
    "description": "Serialization is not supported",
    "lineNumber": 82,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 359,
    "kind": "file",
    "name": "src/Inputs/Text.js",
    "content": "const util = require('util');\nconst ValidationFail = require('../Errors/ValidationFail');\nconst Input = require('../Input');\nconst BaseText = require('./BaseText');\n\n\n/**\n * Text input.\n *\n * ```javascript\n * const input = Input.create('myInput: text');\n * input.setValue('Some text');\n * ```\n *\n * ```javascript\n * // vector\n * const input = Input.create('myInput: text[]');\n * input.setValue(['A', 'B', 'C']);\n * ```\n *\n * *This input can also be created using the alias:* `string`\n *\n * <h2>Property Summary</h2>\n *\n * Property Name | Description | Defined&nbsp;by Default | Default Value\n * --- | --- | :---: | :---:\n * min | minimum number of characters | ::off:: | ::none::\n * max | maximum number of characters | ::off:: | ::none::\n *\n * All properties including the inherited ones can be listed via\n * {@link registeredPropertyNames}\n */\nclass Text extends BaseText{\n\n  /**\n   * Implements input's validations\n   *\n   * @param {null|number} at - index used when input has been created as a vector that\n   * tells which value should be used\n   * @return {Promise<*>} value held by the input based on the current context (at)\n   * @protected\n   */\n  _validation(at){\n\n    // calling super class validations\n    return super._validation(at).then((value) => {\n\n      // min property\n      if (this.hasProperty('min') && value.length < this.property('min')){\n        throw new ValidationFail(\n          util.format('Value is too short, it needs to have at least %d characters', this.property('min')),\n          '64358b78-ec83-4494-b734-0b1bdac43720',\n        );\n      }\n      // max property\n      else if (this.hasProperty('max') && value.length > this.property('max')){\n        throw new ValidationFail(\n          util.format('Value is too long, maximum is %d characters', this.property('max')),\n          'c7ff4423-2c27-4538-acd7-923dada7f4d3',\n        );\n      }\n\n      return value;\n    });\n  }\n}\n\n// registering the input\nInput.register(Text);\n\n// also, registering as 'string' for convenience\nInput.register(Text, 'string');\n\n// registering properties\nInput.registerProperty(Text, 'min');\nInput.registerProperty(Text, 'max');\n\nmodule.exports = Text;\n",
    "static": true,
    "longname": "src/Inputs/Text.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 360,
    "kind": "variable",
    "name": "__import_module__util",
    "memberof": "src/Inputs/Text.js",
    "static": true,
    "longname": "src/Inputs/Text.js~__import_module__util",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Text.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 361,
    "kind": "variable",
    "name": "__import_module__ValidationFail",
    "memberof": "src/Inputs/Text.js",
    "static": true,
    "longname": "src/Inputs/Text.js~__import_module__ValidationFail",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Text.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 362,
    "kind": "variable",
    "name": "__import_module__Input",
    "memberof": "src/Inputs/Text.js",
    "static": true,
    "longname": "src/Inputs/Text.js~__import_module__Input",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Text.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 363,
    "kind": "variable",
    "name": "__import_module__BaseText",
    "memberof": "src/Inputs/Text.js",
    "static": true,
    "longname": "src/Inputs/Text.js~__import_module__BaseText",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Text.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 364,
    "kind": "class",
    "name": "Text",
    "memberof": "src/Inputs/Text.js",
    "static": true,
    "longname": "src/Inputs/Text.js~Text",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Inputs/Text.js",
    "importStyle": "Text",
    "description": "Text input.\n\n```javascript\nconst input = Input.create('myInput: text');\ninput.setValue('Some text');\n```\n\n```javascript\n// vector\nconst input = Input.create('myInput: text[]');\ninput.setValue(['A', 'B', 'C']);\n```\n\n*This input can also be created using the alias:* `string`\n\n<h2>Property Summary</h2>\n\nProperty Name | Description | Defined&nbsp;by Default | Default Value\n--- | --- | :---: | :---:\nmin | minimum number of characters | ::off:: | ::none::\nmax | maximum number of characters | ::off:: | ::none::\n\nAll properties including the inherited ones can be listed via\n{@link registeredPropertyNames}",
    "lineNumber": 33,
    "interface": false,
    "extends": [
      "BaseText"
    ]
  },
  {
    "__docId__": 365,
    "kind": "method",
    "name": "_validation",
    "memberof": "src/Inputs/Text.js~Text",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/Text.js~Text#_validation",
    "access": "protected",
    "description": "Implements input's validations",
    "lineNumber": 43,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "value held by the input based on the current context (at)"
    }
  },
  {
    "__docId__": 366,
    "kind": "file",
    "name": "src/Inputs/Timestamp.js",
    "content": "const TypeCheck = require('js-typecheck');\nconst ValidationFail = require('../Errors/ValidationFail');\nconst Input = require('../Input');\n\n\n/**\n * Timestamp input.\n *\n * ```javascript\n * const input = Input.create('myInput: timestamp');\n * input.setValue(new Date());\n * ```\n *\n * *This input can also be created using the alias:* `date`\n *\n * <h2>Property Summary</h2>\n * All properties including the inherited ones can be listed via\n * {@link registeredPropertyNames}\n */\nclass Timestamp extends Input{\n\n  /**\n   * Implements input's validations\n   *\n   * @param {null|number} at - index used when input has been created as a vector that\n   * tells which value should be used\n   * @return {Promise<*>} value held by the input based on the current context (at)\n   * @protected\n   */\n  _validation(at){\n\n    // calling super class validations\n    return super._validation(at).then((value) => {\n\n      // type checking\n      if (!(value instanceof Date && TypeCheck.isNumber(value.getTime()))){\n        throw new ValidationFail(\n          'Value needs to be a valid Date',\n          '93b2fcf4-7fc6-4a3d-bfff-4504b37b9801',\n        );\n      }\n\n      return value;\n    });\n  }\n\n  /**\n   * Decodes the value by casting it to the type that is compatible with the input\n   *\n   * @param {string} value - string containing the encoded value\n   * @return {Date}\n   * @protected\n   */\n  static _decode(value){\n    return new Date(value);\n  }\n}\n\n// registering the input\nInput.register(Timestamp);\n\n// also, registering as 'date' for convenience\nInput.register(Timestamp, 'date');\n\nmodule.exports = Timestamp;\n",
    "static": true,
    "longname": "src/Inputs/Timestamp.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 367,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Inputs/Timestamp.js",
    "static": true,
    "longname": "src/Inputs/Timestamp.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Timestamp.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 368,
    "kind": "variable",
    "name": "__import_module__ValidationFail",
    "memberof": "src/Inputs/Timestamp.js",
    "static": true,
    "longname": "src/Inputs/Timestamp.js~__import_module__ValidationFail",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Timestamp.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 369,
    "kind": "variable",
    "name": "__import_module__Input",
    "memberof": "src/Inputs/Timestamp.js",
    "static": true,
    "longname": "src/Inputs/Timestamp.js~__import_module__Input",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Timestamp.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 370,
    "kind": "class",
    "name": "Timestamp",
    "memberof": "src/Inputs/Timestamp.js",
    "static": true,
    "longname": "src/Inputs/Timestamp.js~Timestamp",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Inputs/Timestamp.js",
    "importStyle": "Timestamp",
    "description": "Timestamp input.\n\n```javascript\nconst input = Input.create('myInput: timestamp');\ninput.setValue(new Date());\n```\n\n*This input can also be created using the alias:* `date`\n\n<h2>Property Summary</h2>\nAll properties including the inherited ones can be listed via\n{@link registeredPropertyNames}",
    "lineNumber": 20,
    "interface": false,
    "extends": [
      "Input"
    ]
  },
  {
    "__docId__": 371,
    "kind": "method",
    "name": "_validation",
    "memberof": "src/Inputs/Timestamp.js~Timestamp",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/Timestamp.js~Timestamp#_validation",
    "access": "protected",
    "description": "Implements input's validations",
    "lineNumber": 30,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "value held by the input based on the current context (at)"
    }
  },
  {
    "__docId__": 372,
    "kind": "method",
    "name": "_decode",
    "memberof": "src/Inputs/Timestamp.js~Timestamp",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Inputs/Timestamp.js~Timestamp._decode",
    "access": "protected",
    "description": "Decodes the value by casting it to the type that is compatible with the input",
    "lineNumber": 54,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "string containing the encoded value"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Date"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 373,
    "kind": "file",
    "name": "src/Inputs/UUID.js",
    "content": "const uuid = require('uuid');\nconst ValidationFail = require('../Errors/ValidationFail');\nconst Input = require('../Input');\nconst BaseText = require('./BaseText');\n\n\n/**\n * UUID input.\n *\n * ```javascript\n * const input = Input.create('myInput: uuid');\n * input.setValue('075054e0-810a-11e6-8c1d-e5fb28c699ca');\n * ```\n *\n * <h2>Property Summary</h2>\n * All properties including the inherited ones can be listed via\n * {@link registeredPropertyNames}\n *\n * @see https://en.wikipedia.org/wiki/Universally_unique_identifier\n */\nclass UUID extends BaseText{\n\n  /**\n   * Generates a new time based id (uuid v1) and assigns it to the value\n   * of the input. This method is not supported by vector inputs.\n   *\n   */\n  setTimeBasedRandom(){\n    if (this.isVector()){\n      throw new Error('Not supported, input is a vector!');\n    }\n\n    this.setValue(uuid.v1());\n  }\n\n  /**\n   * Generates a new random id (uuid v4) and assigns it to the value\n   * of the input. This method is not supported by vector inputs.\n   */\n  setRandom(){\n    if (this.isVector()){\n      throw new Error('Not supported, input is a vector!');\n    }\n\n    this.setValue(uuid.v4());\n  }\n\n  /**\n   * Implements input's validations\n   *\n   * @param {null|number} at - index used when input has been created as a vector that\n   * tells which value should be used\n   * @return {Promise<*>} value held by the input based on the current context (at)\n   * @protected\n   */\n  _validation(at){\n\n    // calling super class validations\n    return super._validation(at).then((value) => {\n\n      // format checking\n      if (!UUID._uuidFormatRegEx.test(value)){\n        throw new ValidationFail(\n          'Invalid UUID format',\n          '66b476c7-d1d3-4241-91a3-d71154807840',\n        );\n      }\n\n      return value;\n    });\n  }\n\n  static _uuidFormatRegEx = /^\\w{8}-\\w{4}-\\w{4}-\\w{4}-\\w{12}$/;\n}\n\n// registering the input\nInput.register(UUID);\n\nmodule.exports = UUID;\n",
    "static": true,
    "longname": "src/Inputs/UUID.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 374,
    "kind": "variable",
    "name": "__import_module__uuid",
    "memberof": "src/Inputs/UUID.js",
    "static": true,
    "longname": "src/Inputs/UUID.js~__import_module__uuid",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/UUID.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 375,
    "kind": "variable",
    "name": "__import_module__ValidationFail",
    "memberof": "src/Inputs/UUID.js",
    "static": true,
    "longname": "src/Inputs/UUID.js~__import_module__ValidationFail",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/UUID.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 376,
    "kind": "variable",
    "name": "__import_module__Input",
    "memberof": "src/Inputs/UUID.js",
    "static": true,
    "longname": "src/Inputs/UUID.js~__import_module__Input",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/UUID.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 377,
    "kind": "variable",
    "name": "__import_module__BaseText",
    "memberof": "src/Inputs/UUID.js",
    "static": true,
    "longname": "src/Inputs/UUID.js~__import_module__BaseText",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/UUID.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 378,
    "kind": "class",
    "name": "UUID",
    "memberof": "src/Inputs/UUID.js",
    "static": true,
    "longname": "src/Inputs/UUID.js~UUID",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Inputs/UUID.js",
    "importStyle": "UUID",
    "description": "UUID input.\n\n```javascript\nconst input = Input.create('myInput: uuid');\ninput.setValue('075054e0-810a-11e6-8c1d-e5fb28c699ca');\n```\n\n<h2>Property Summary</h2>\nAll properties including the inherited ones can be listed via\n{@link registeredPropertyNames}",
    "see": [
      "https://en.wikipedia.org/wiki/Universally_unique_identifier"
    ],
    "lineNumber": 21,
    "interface": false,
    "extends": [
      "BaseText"
    ]
  },
  {
    "__docId__": 379,
    "kind": "method",
    "name": "setTimeBasedRandom",
    "memberof": "src/Inputs/UUID.js~UUID",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/UUID.js~UUID#setTimeBasedRandom",
    "access": null,
    "description": "Generates a new time based id (uuid v1) and assigns it to the value\nof the input. This method is not supported by vector inputs.",
    "lineNumber": 28,
    "params": []
  },
  {
    "__docId__": 380,
    "kind": "method",
    "name": "setRandom",
    "memberof": "src/Inputs/UUID.js~UUID",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/UUID.js~UUID#setRandom",
    "access": null,
    "description": "Generates a new random id (uuid v4) and assigns it to the value\nof the input. This method is not supported by vector inputs.",
    "lineNumber": 40,
    "params": []
  },
  {
    "__docId__": 381,
    "kind": "method",
    "name": "_validation",
    "memberof": "src/Inputs/UUID.js~UUID",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/UUID.js~UUID#_validation",
    "access": "protected",
    "description": "Implements input's validations",
    "lineNumber": 56,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "value held by the input based on the current context (at)"
    }
  },
  {
    "__docId__": 382,
    "kind": "member",
    "name": "_uuidFormatRegEx",
    "memberof": "src/Inputs/UUID.js~UUID",
    "static": true,
    "longname": "src/Inputs/UUID.js~UUID._uuidFormatRegEx",
    "access": null,
    "description": null,
    "lineNumber": 73,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "undefined"
      ]
    }
  },
  {
    "__docId__": 383,
    "kind": "file",
    "name": "src/Inputs/Url.js",
    "content": "const util = require('util');\nconst path = require('path');\nconst url = require('url');\nconst http = require('http');\nconst https = require('https');\nconst TypeCheck = require('js-typecheck');\nconst Input = require('../Input');\nconst ValidationFail = require('../Errors/ValidationFail');\nconst BaseText = require('./BaseText');\n\n\n/**\n* Url Input.\n*\n* It supports the protocols: `http`, `https`\n*\n* ```javascript\n* const input = Input.create('myInput: url');\n* input.setValue('http://www.google.com');\n* ```\n*\n* <h2>Property Summary</h2>\n*\n* Property Name | Description | Defined&nbsp;by Default | Default Value\n* --- | --- | :---: | :---:\n* maxContentSize | maximum file size of url's content in bytes | ::on:: | `5242880` (5mb)\n* exists | checks if the url is valid | ::off:: | ::none::\n* allowedExtensions | specific list of extensions for the input \\\n* (this check is case insensitive) example: ['jpg', 'png'] | ::off:: | ::none::\n*\n* All properties including the inherited ones can be listed via\n* {@link registeredPropertyNames}\n*/\nclass Url extends BaseText{\n\n  /**\n   * Returns the url extension (for instance: jpg) or empty string\n   *\n   * @param {null|number} [at] - index used when input has been created as a vector that\n   * tells which value should be used\n   * @return {string}\n   */\n  extension(at=null){\n\n    if (!this._isCached('extension', at)){\n      let extension = '';\n      const value = this.valueAt(at);\n\n      // computing the value and caching it\n      if (TypeCheck.isString(value)){\n        this._parseUrl(at);\n\n        const ext = path.extname(this._getFromCache('urlParsed', at).pathname);\n        if (ext.length > 1){\n          extension = ext.slice(1);\n        }\n      }\n\n      this._setToCache('extension', extension, at);\n    }\n\n    return this._getFromCache('extension', at);\n  }\n\n  /**\n   * Returns the url protocol `http:` or `https:`\n   *\n   * @param {null|number} [at] - index used when input has been created as a vector that\n   * tells which value should be used\n   * @return {string}\n   */\n  protocol(at=null){\n\n    if (!this._isCached('protocol', at)){\n      let protocol = '';\n      const value = this.valueAt(at);\n\n      if (TypeCheck.isString(value)){\n        if (value.startsWith('http:')){\n          protocol = 'http:';\n        }\n\n        /* istanbul ignore next */\n        else if (value.startsWith('https:')){\n          protocol = 'https:';\n        }\n      }\n\n      this._setToCache('protocol', protocol, at);\n    }\n\n    return this._getFromCache('protocol', at);\n  }\n\n  /**\n   * Returns the headers\n   *\n   * @param {null|number} [at] - index used when input has been created as a vector that\n   * tells which value should be used\n   * @return {Promise<Object>}\n   */\n  headers(at=null){\n\n    // returning from cache\n    if (this._isCached('headers', at)){\n      return Promise.resolve(this._getFromCache('headers', at));\n    }\n\n    // otherwise processing headers\n    return new Promise((resolve, reject) => {\n\n      this._parseUrl(at);\n\n      const options = Object.create(null);\n      options.method = 'HEAD';\n      options.protocol = this._getFromCache('urlParsed', at).protocol;\n      options.host = this._getFromCache('urlParsed', at).hostname;\n      options.port = this._getFromCache('urlParsed', at).port;\n      options.path = this._getFromCache('urlParsed', at).path;\n\n      // checking the protocol\n      const protocol = this.protocol(at);\n      if (['http:', 'https:'].includes(protocol)){\n\n        /* istanbul ignore next */\n        const httpModule = (protocol === 'http:') ? http : https;\n\n        // doing the request\n        const request = httpModule.request(options, (response) => {\n\n          let errorStatus = null;\n          let headers = Object.create(null);\n          if (response.statusCode === 200){\n            headers = response.headers;\n          }\n          else{\n            errorStatus = new Error('Could not connect to the url');\n          }\n\n          if (errorStatus){\n            reject(errorStatus);\n          }\n          else{\n            this._setToCache('headers', headers, at);\n            resolve(headers);\n          }\n        });\n\n        /* istanbul ignore next */\n        request.on('error', (err) => {\n          reject(err);\n        });\n        request.end();\n      }\n      else{\n        reject(new Error('Invalid protocol'));\n      }\n    });\n  }\n\n  /**\n   * Parses the current url data\n   * @param {null|number} at - index used when input has been created as a vector that\n   * tells which value should be used\n   *\n   * @private\n   */\n  _parseUrl(at){\n    if (!this._isCached('urlParsed', at)){\n      const value = this.valueAt(at);\n      this._setToCache('urlParsed', url.parse(value), at);\n    }\n  }\n\n  /**\n   * Implements input's validations\n   *\n   * @param {null|number} at - index used when input has been created as a vector that\n   * tells which value should be used\n   * @return {Promise<*>} value held by the input based on the current context (at)\n   * @protected\n   */\n  async _validation(at){\n\n    // calling super class validations\n    // todo: babel does not support 'await' calling a method under 'super'\n    // https://github.com/babel/babel/issues/3930\n    // const value = await super._validation(at);\n    const value = await BaseText.prototype._validation.call(this, at);\n\n    // supported extensions check\n    if (this.property('allowedExtensions') && !this.property('allowedExtensions').map(x => x.toLowerCase()).includes(this.extension(at).toLowerCase())){\n      throw new ValidationFail(\n        util.format(\"Extension '%s' is not supported! (supported extensions: %s)\", this.extension(at), this.property('allowedExtensions')),\n        'fb833b76-2ebb-4f27-be45-dac510bda816',\n      );\n    }\n\n    // url exists & maximum content size\n    if (this.property('exists')){\n\n      let urlHeaders = null;\n      let err = null;\n\n      try{\n        urlHeaders = await this.headers(at);\n      }\n      catch(errr){\n        err = errr;\n      }\n\n      if (this.property('exists') && err){\n        err = new ValidationFail(\n          'Could not connect to the URL',\n          '8471d8f6-3902-45dc-81f7-802e1de73f69',\n        );\n      }\n      else if (!err && this.property('maxContentSize') && urlHeaders['content-length'] > this.property('maxContentSize')){\n        err = new ValidationFail(\n          util.format('URL content size (%.1f mb) exceeds the limit allowed (%.1f mb)', urlHeaders['content-length']/1024/1024, this.property('maxContentSize')/1024/1024),\n          '7d860f72-a562-4bb3-940d-15dd3bd8bed1',\n        );\n      }\n\n      if (err){\n        throw err;\n      }\n    }\n\n    return value;\n  }\n}\n\n// registering the input\nInput.register(Url);\n\n// registering properties\nInput.registerProperty(Url, 'exists', true);\nInput.registerProperty(Url, 'maxContentSize', 5 * 1024 * 1024);\nInput.registerProperty(Url, 'allowedExtensions');\n\nmodule.exports = Url;\n",
    "static": true,
    "longname": "src/Inputs/Url.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 384,
    "kind": "variable",
    "name": "__import_module__util",
    "memberof": "src/Inputs/Url.js",
    "static": true,
    "longname": "src/Inputs/Url.js~__import_module__util",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 385,
    "kind": "variable",
    "name": "__import_module__path",
    "memberof": "src/Inputs/Url.js",
    "static": true,
    "longname": "src/Inputs/Url.js~__import_module__path",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 386,
    "kind": "variable",
    "name": "__import_module__url",
    "memberof": "src/Inputs/Url.js",
    "static": true,
    "longname": "src/Inputs/Url.js~__import_module__url",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 387,
    "kind": "variable",
    "name": "__import_module__http",
    "memberof": "src/Inputs/Url.js",
    "static": true,
    "longname": "src/Inputs/Url.js~__import_module__http",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 388,
    "kind": "variable",
    "name": "__import_module__https",
    "memberof": "src/Inputs/Url.js",
    "static": true,
    "longname": "src/Inputs/Url.js~__import_module__https",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 389,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Inputs/Url.js",
    "static": true,
    "longname": "src/Inputs/Url.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 390,
    "kind": "variable",
    "name": "__import_module__Input",
    "memberof": "src/Inputs/Url.js",
    "static": true,
    "longname": "src/Inputs/Url.js~__import_module__Input",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 391,
    "kind": "variable",
    "name": "__import_module__ValidationFail",
    "memberof": "src/Inputs/Url.js",
    "static": true,
    "longname": "src/Inputs/Url.js~__import_module__ValidationFail",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 392,
    "kind": "variable",
    "name": "__import_module__BaseText",
    "memberof": "src/Inputs/Url.js",
    "static": true,
    "longname": "src/Inputs/Url.js~__import_module__BaseText",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 393,
    "kind": "class",
    "name": "Url",
    "memberof": "src/Inputs/Url.js",
    "static": true,
    "longname": "src/Inputs/Url.js~Url",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Inputs/Url.js",
    "importStyle": "Url",
    "description": "Url Input.\n\nIt supports the protocols: `http`, `https`\n\n```javascript\nconst input = Input.create('myInput: url');\ninput.setValue('http://www.google.com');\n```\n\n<h2>Property Summary</h2>\n\nProperty Name | Description | Defined&nbsp;by Default | Default Value\n--- | --- | :---: | :---:\nmaxContentSize | maximum file size of url's content in bytes | ::on:: | `5242880` (5mb)\nexists | checks if the url is valid | ::off:: | ::none::\nallowedExtensions | specific list of extensions for the input (this check is case insensitive) example: ['jpg', 'png'] | ::off:: | ::none::\n\nAll properties including the inherited ones can be listed via\n{@link registeredPropertyNames}",
    "lineNumber": 33,
    "interface": false,
    "extends": [
      "BaseText"
    ]
  },
  {
    "__docId__": 394,
    "kind": "method",
    "name": "extension",
    "memberof": "src/Inputs/Url.js~Url",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/Url.js~Url#extension",
    "access": null,
    "description": "Returns the url extension (for instance: jpg) or empty string",
    "lineNumber": 42,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 395,
    "kind": "method",
    "name": "protocol",
    "memberof": "src/Inputs/Url.js~Url",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/Url.js~Url#protocol",
    "access": null,
    "description": "Returns the url protocol `http:` or `https:`",
    "lineNumber": 71,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 396,
    "kind": "method",
    "name": "headers",
    "memberof": "src/Inputs/Url.js~Url",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/Url.js~Url#headers",
    "access": null,
    "description": "Returns the headers",
    "lineNumber": 101,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Object>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 397,
    "kind": "method",
    "name": "_parseUrl",
    "memberof": "src/Inputs/Url.js~Url",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/Url.js~Url#_parseUrl",
    "access": "private",
    "description": "Parses the current url data",
    "lineNumber": 167,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ]
  },
  {
    "__docId__": 398,
    "kind": "method",
    "name": "_validation",
    "memberof": "src/Inputs/Url.js~Url",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Inputs/Url.js~Url#_validation",
    "access": "protected",
    "description": "Implements input's validations",
    "lineNumber": 182,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "value held by the input based on the current context (at)"
    }
  },
  {
    "__docId__": 399,
    "kind": "file",
    "name": "src/Inputs/Version.js",
    "content": "const util = require('util');\nconst compareVersions = require('compare-versions');\nconst ValidationFail = require('../Errors/ValidationFail');\nconst Input = require('../Input');\nconst BaseText = require('./BaseText');\n\n\n/**\n * Version input.\n *\n * This input follows the semver convention.\n *\n * ```javascript\n * const input = Input.create('myInput: version');\n * input.setValue('2.2.1');\n * ```\n *\n * <h2>Property Summary</h2>\n *\n * Property Name | Description | Defined&nbsp;by Default | Default Value\n * --- | --- | :---: | :---:\n * minimumRequired | minimum version required | ::off:: | ::none::\n *\n * All properties including the inherited ones can be listed via\n * {@link registeredPropertyNames}\n *\n * @see http://semver.org\n */\nclass Version extends BaseText{\n\n  /**\n   * Implements input's validations\n   *\n   * @param {null|number} at - index used when input has been created as a vector that\n   * tells which value should be used\n   * @return {Promise<*>} value held by the input based on the current context (at)\n   * @protected\n   */\n  _validation(at){\n\n    // calling super class validations\n    return super._validation(at).then((value) => {\n\n      // minimumVersionRequired\n      if (this.property('minimumRequired') && compareVersions(value, this.property('minimumRequired')) === -1){\n        throw new ValidationFail(\n          util.format('Version is not compatible, minimum Version required: %s, current version %s', this.property('minimumRequired'), value),\n          '524f9ed1-44e8-43d8-83b1-72dc8d33788b',\n        );\n      }\n\n      return value;\n    });\n  }\n}\n\n// registering the input\nInput.register(Version);\n\n// registering properties\nInput.registerProperty(Version, 'minimumRequired');\n\nmodule.exports = Version;\n",
    "static": true,
    "longname": "src/Inputs/Version.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 400,
    "kind": "variable",
    "name": "__import_module__util",
    "memberof": "src/Inputs/Version.js",
    "static": true,
    "longname": "src/Inputs/Version.js~__import_module__util",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Version.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 401,
    "kind": "variable",
    "name": "__import_module__compareVersions",
    "memberof": "src/Inputs/Version.js",
    "static": true,
    "longname": "src/Inputs/Version.js~__import_module__compareVersions",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Version.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 402,
    "kind": "variable",
    "name": "__import_module__ValidationFail",
    "memberof": "src/Inputs/Version.js",
    "static": true,
    "longname": "src/Inputs/Version.js~__import_module__ValidationFail",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Version.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 403,
    "kind": "variable",
    "name": "__import_module__Input",
    "memberof": "src/Inputs/Version.js",
    "static": true,
    "longname": "src/Inputs/Version.js~__import_module__Input",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Version.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 404,
    "kind": "variable",
    "name": "__import_module__BaseText",
    "memberof": "src/Inputs/Version.js",
    "static": true,
    "longname": "src/Inputs/Version.js~__import_module__BaseText",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Inputs/Version.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 405,
    "kind": "class",
    "name": "Version",
    "memberof": "src/Inputs/Version.js",
    "static": true,
    "longname": "src/Inputs/Version.js~Version",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Inputs/Version.js",
    "importStyle": "Version",
    "description": "Version input.\n\nThis input follows the semver convention.\n\n```javascript\nconst input = Input.create('myInput: version');\ninput.setValue('2.2.1');\n```\n\n<h2>Property Summary</h2>\n\nProperty Name | Description | Defined&nbsp;by Default | Default Value\n--- | --- | :---: | :---:\nminimumRequired | minimum version required | ::off:: | ::none::\n\nAll properties including the inherited ones can be listed via\n{@link registeredPropertyNames}",
    "see": [
      "http://semver.org"
    ],
    "lineNumber": 29,
    "interface": false,
    "extends": [
      "BaseText"
    ]
  },
  {
    "__docId__": 406,
    "kind": "method",
    "name": "_validation",
    "memberof": "src/Inputs/Version.js~Version",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Inputs/Version.js~Version#_validation",
    "access": "protected",
    "description": "Implements input's validations",
    "lineNumber": 39,
    "params": [
      {
        "nullable": null,
        "types": [
          "null",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "at",
        "description": "index used when input has been created as a vector that\ntells which value should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "value held by the input based on the current context (at)"
    }
  },
  {
    "__docId__": 407,
    "kind": "file",
    "name": "src/Inputs/index.js",
    "content": "module.exports.Bool = require('./Bool');\nmodule.exports.BaseText = require('./BaseText');\nmodule.exports.Text = require('./Text');\nmodule.exports.Numeric = require('./Numeric');\nmodule.exports.Any = require('./Any');\nmodule.exports.Version = require('./Version');\nmodule.exports.FilePath = require('./FilePath');\nmodule.exports.Url = require('./Url');\nmodule.exports.Email = require('./Email');\nmodule.exports.Ip = require('./Ip');\nmodule.exports.UUID = require('./UUID');\nmodule.exports.Timestamp = require('./Timestamp');\nmodule.exports.Stream = require('./Stream');\nmodule.exports.Buf = require('./Buf');\nmodule.exports.Hex = require('./Hex');\nmodule.exports.Hash = require('./Hash');\n",
    "static": true,
    "longname": "src/Inputs/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 408,
    "kind": "file",
    "name": "src/Metadata.js",
    "content": "const assert = require('assert');\nconst TypeCheck = require('js-typecheck');\nconst Utils = require('./Utils');\n\n// symbols used for private instance variables to avoid any potential clashing\n// caused by re-implementations\nconst _collection = Symbol('collection');\n\n\n/**\n * Metadata provides a way for actions ({@link Action}) to control about how a\n * handler should perform the reading ({@link Reader}) and writing\n * ({@link Writer}) operations. Therefore, making possible handlers to perform\n * differently per action basis.\n *\n * This is done by defining {@link Reader} & {@link Writer} options through\n * the metadata. By doing that the options are passed from the action to the\n * handler during the handler's execution ({@link Handler.runAction}).\n *\n * You can define options by either using option variables or the full option location:\n *\n * **Option var (recommended):**\n * Eliminates the need of using convoluted long names to define the options by\n * simply using a variable that represents a full option location:\n *\n * Example:\n * ```\n * class MyAction extends Mebo.Action{\n *\n *    constructor(){\n *      super();\n *      // defining a custom uploadDirectory by using the `$webUploadDirectory` variable,\n *      // rather than the full option location (`handler.web.readOptions.uploadDirectory`)\n *      this.setMeta('$webUploadDirectory', '/tmp/customUploadDir');\n *    }\n *\n *    _perform(data){\n *      // ...\n *    }\n *\n *    _finalize(err, value){\n *      // defining a custom header that only affects the web handler\n *      // this call could be done inside of the _perform method. However, we\n *      // are defining it inside of the _finalize to keep _perform as\n *      // abstract as possible. Since, _finalize is always called (even during\n *      // an error) after the execution of the action, it provides a way to\n *      // hook and define custom metadata related with the result.\n *      if (!err){\n *        // defining a custom header by using the `$webHeaders` variable, rather\n *        // than the full option location (`handler.web.writeOptions.headers`)\n *        this.setMeta('$webHeaders', {\n *          someOption: 'foo',\n *        });\n *      }\n *\n *      return super._finalize(err, value);\n *    }\n * }\n * ```\n *\n * **Full option location:**\n * Uses a convention interpreted by the {@link Handler.metadata} to describe\n * where the option is localized:\n * ```\n * handler.<HANDLER_NAME>.<OPERATION>Options.<OPTION_NAME>\n * ```\n *\n * Example:\n * ```\n * class MyAction extends Mebo.Action{\n *    constructor(){\n *      super();\n *      this.setMeta('handler.web.readOptions.uploadDirectory', '/tmp/customUploadDir');\n *    }\n *\n *    _perform(data){\n *      // ...\n *    }\n *\n *    _finalize(err, value){\n *\n *      if (!err){\n *        // location (not recommended, see option var)\n *        this.setMeta('handler.web.writeOptions.headers', {\n *          someOption: 'foo',\n *        });\n *      }\n *\n *      return super._finalize(err, value);\n *    }\n * }\n * ```\n *\n * The complete list of the available option variables can be found bellow, it's\n * separated by handler type. Also, new variables can be assigned through\n * {@link Metadata.registerOptionVar}.\n *\n * <h2>Web Variables</h2>\n *\n * Variable name | Value | Value used by\n * --- | --- | ---\n * $web | `handler.web` |\n * $webUploadDirectory | `$web.readOptions.uploadDirectory` | {@link WebRequest}\n * $webUploadPreserveName | `$web.readOptions.uploadPreserveName` | {@link WebRequest}\n * $webUploadMaxFileSize | `$web.readOptions.uploadMaxFileSize` | {@link WebRequest}\n * $webMaxFields | `$web.readOptions.maxFields` | {@link WebRequest}\n * $webMaxFieldsSize | `$web.readOptions.maxFieldsSize` | {@link WebRequest}\n * $webHeaders | `$web.writeOptions.headers` | {@link WebResponse}\n * $webHeadersOnly | `$web.writeOptions.headersOnly`| {@link WebResponse}\n * $webResult | `$web.writeOptions.result`| {@link WebResponse}\n * $webRoot | `$web.writeOptions.root`| {@link WebResponse}\n * $webStatus | `$web.writeOptions.status`| {@link WebResponse}\n * $webResultLabel | `$web.writeOptions.resultLabel`| {@link WebResponse}\n *\n * <h2>Cli Variables</h2>\n *\n * Variable name | Value | Value used by\n * --- | --- | ---\n * $cli | `handler.cli` |\n * $cliDescription | `$cli.readOptions.description` | {@link CliArgs}\n * $cliResult | `$cli.writeOptions.result` | {@link CliOutput}\n */\nclass Metadata{\n\n  /**\n   * Creates a metadata\n   */\n  constructor(){\n    this[_collection] = new Utils.HierarchicalCollection();\n  }\n\n  /**\n   * Returns a value under the metadata.\n   *\n   * @param {string} path - path about where the value is localized (the levels\n   * must be separated by '.'). In case of empty string the entire metadata\n   * is returned.\n   * @param {*} [defaultValue] - default value returned in case a value was\n   * not found for the path\n   * @return {*}\n   */\n  value(path, defaultValue=undefined){\n    assert(TypeCheck.isString(path), 'path needs to be defined as string');\n\n    return this[_collection].query(Metadata._resolvePath(path), defaultValue);\n  }\n\n  /**\n   * Sets a value to the metadata.\n   *\n   * @param {string} path - path about where the value should be stored under the metadata\n   * (the levels must be separated by '.')\n   * @param {*} value - value that is going to be stored under the collection\n   * @param {boolean} [merge=true] - this option is used to decide in case of the\n   * last level is already existing under the collection, if the value should be\n   * either merged (default) or overridden.\n   */\n  setValue(path, value, merge=true){\n    assert(TypeCheck.isString(path), 'path needs to be defined as string');\n\n    this[_collection].insert(Metadata._resolvePath(path), value, merge);\n  }\n\n  /**\n   * Returns a list of the root levels under the metadata\n   *\n   * @return {Array<string>}\n   */\n  root(){\n    return this[_collection].root();\n  }\n\n  /**\n   * register an option variable under metadata\n   *\n   * The value of the variable can contain other pre-defined option variables,\n   * for instance:\n   * ```\n   * Mebo.Metadata.registerOptionVar('$myVar', '$otherVar.data')\n   * ```\n   *\n   * @param {string} name - name of the variable\n   * @param {string} value - value for the variable\n   */\n  static registerOptionVar(name, value){\n    assert(TypeCheck.isString(name), 'name needs to be defined as string');\n    assert(TypeCheck.isString(value), 'value needs to be defined as string');\n    assert((/^([\\w_\\$\\.\\-])+$/gi).test(value), `Illegal characters found variable (${name}) value: ${value}`); // eslint-disable-line no-useless-escape\n\n    this._validateOptionVarName(name);\n\n    // flushing cache\n    this._cachedOptionVariables = {};\n\n    // assigning variable\n    this._optionVariables[name] = value;\n  }\n\n  /**\n   * Returns the value for an option variable\n   *\n   * for instance:\n   * ```\n   * const myVariableValue = Mebo.Metadata.optionVar('$myVariable');\n   * console.log(myVariableValue)\n   * ```\n   *\n   * @param {string} name - name of the variable\n   * @param {boolean} [processValue=true] - process any variables that may be\n   * defined as part of the value\n   * @return {string}\n   *\n   * @throws {Error} throws an error if the var name is undefined\n   * under the metadata.\n   */\n  static optionVar(name, processValue=true){\n\n    this._validateOptionVarName(name);\n    if (!(name in this._optionVariables)){\n      throw new Error(`Option variable ${name} is undefined`);\n    }\n\n    if (processValue){\n      return this._resolveOptionVar(name);\n    }\n\n    return this._optionVariables[name];\n  }\n\n  /**\n   * Returns a boolean telling if the variable name is defined\n   *\n   * @param {string} name - variable name\n   * @return {boolean}\n   */\n  static hasOptionVar(name){\n    this._validateOptionVarName(name);\n\n    return (name in this._optionVariables);\n  }\n\n  /**\n   * Returns a list of the registered variable names under the metadata\n   *\n   * @return {Array<string>}\n   */\n  static registeredOptionVars(){\n    return Object.keys(this._optionVariables);\n  }\n\n  /**\n   * Returns the path resolved by processing any variables that may\n   * be defined as part of the path\n   *\n   * @param {string} path - path to be resolved\n   * @return {string}\n   */\n  static _resolvePath(path){\n\n    // if the path contains variables lets process it\n    if (path.indexOf('$') !== -1){\n      const processedPath = [];\n      for (const part of path.split('.')){\n        if (part.startsWith('$')){\n          processedPath.push(Metadata.optionVar(part));\n        }\n        else{\n          processedPath.push(part);\n        }\n      }\n\n      // processed path\n      return processedPath.join('.');\n    }\n\n    return path;\n  }\n\n  /**\n   * Returns the value of the variable by processing any variables\n   * that may be defined as part of the value\n   *\n   * @param {string} name - variable name\n   * @param {string} [rootName] - root variable name used to report the origin\n   * of the circular reference error\n   * @param {number} [depth=0] - deep used to identify max recursion caused\n   * by circular references\n   * @return {string}\n   * @private\n   */\n  static _resolveOptionVar(name, rootName, depth=0){\n\n    // detecting circular references\n    if (depth >= this._maxDepth){\n      const error = new Error(`Circular reference detected while processing the value for $${rootName}`);\n\n      // processing the stack of the error to get rid of the duplicated entries\n      // caused by the recursion (we don't need to show 1000+ lines of the same\n      // thing, the error explanation should be good enough)\n      const stackContents = error.stack.split('\\n');\n      error.stack = stackContents.slice(0, 2).concat(stackContents.slice(this._maxDepth + 1)).join('\\n');\n      throw error;\n    }\n\n    // processing value\n    const rawValue = this._optionVariables[name];\n\n    // in case the value is not under the cache, lets process it\n    if (!(name in this._cachedOptionVariables)){\n\n      // checking if the value contains any variable\n      let processedValue = rawValue;\n      if (rawValue.indexOf('$') !== -1){\n\n        // splitting the levels of the value that are separated by '.'\n        const processedValueParts = [];\n        for (const part of rawValue.split('.')){\n          let processedPartValue;\n\n          // in case of a variable\n          if (part.startsWith('$')){\n\n            this._validateOptionVarName(part);\n            // processing variable value\n            processedPartValue = this._resolveOptionVar(part, rootName || name, depth + 1);\n          }\n          // otherwise just use the part without any processing\n          else{\n            processedPartValue = part;\n          }\n          processedValueParts.push(processedPartValue);\n        }\n\n        // building back the structure of the value\n        processedValue = processedValueParts.join('.');\n      }\n\n      // adding processed value to the cache\n      this._cachedOptionVariables[name] = processedValue;\n    }\n\n    // returning value from cache\n    return this._cachedOptionVariables[name];\n  }\n\n  /**\n   * Check if the variable is defined using the proper syntax, otherwise in case\n   * of any issues an exception is raised\n   *\n   * @param {string} name - variable name\n   * @private\n   */\n  static _validateOptionVarName(name){\n    assert(TypeCheck.isString(name), 'name needs to be a string');\n\n    // check if variable name starts with $\n    if (!name.startsWith('$')){\n      throw new Error(`Option variable (${name}) needs to start with: $`);\n    }\n\n    // checking if variable is empty\n    const cleanVarName = name.slice(1);\n    if (!cleanVarName.length){\n      throw new Error('Option variable cannot be empty');\n    }\n\n    // checking for invalid syntax\n    else if (!(/^([\\w_])+$/gi).test(cleanVarName)){\n      throw new Error(`Option variable (${name}) contains invalid characters`);\n    }\n  }\n\n  static _optionVariables = {};\n\n  static _cachedOptionVariables = {};\n\n  static _maxDepth = 1000;\n}\n\nmodule.exports = Metadata;\n",
    "static": true,
    "longname": "src/Metadata.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 409,
    "kind": "variable",
    "name": "__import_module__assert",
    "memberof": "src/Metadata.js",
    "static": true,
    "longname": "src/Metadata.js~__import_module__assert",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Metadata.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 410,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Metadata.js",
    "static": true,
    "longname": "src/Metadata.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Metadata.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 411,
    "kind": "variable",
    "name": "__import_module__Utils",
    "memberof": "src/Metadata.js",
    "static": true,
    "longname": "src/Metadata.js~__import_module__Utils",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Metadata.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 412,
    "kind": "variable",
    "name": "_collection",
    "memberof": "src/Metadata.js",
    "static": true,
    "longname": "src/Metadata.js~_collection",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Metadata.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 413,
    "kind": "class",
    "name": "Metadata",
    "memberof": "src/Metadata.js",
    "static": true,
    "longname": "src/Metadata.js~Metadata",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Metadata.js",
    "importStyle": "Metadata",
    "description": "Metadata provides a way for actions ({@link Action}) to control about how a\nhandler should perform the reading ({@link Reader}) and writing\n({@link Writer}) operations. Therefore, making possible handlers to perform\ndifferently per action basis.\n\nThis is done by defining {@link Reader} & {@link Writer} options through\nthe metadata. By doing that the options are passed from the action to the\nhandler during the handler's execution ({@link Handler.runAction}).\n\nYou can define options by either using option variables or the full option location:\n\n**Option var (recommended):**\nEliminates the need of using convoluted long names to define the options by\nsimply using a variable that represents a full option location:\n\nExample:\n```\nclass MyAction extends Mebo.Action{\n\n   constructor(){\n     super();\n     // defining a custom uploadDirectory by using the `$webUploadDirectory` variable,\n     // rather than the full option location (`handler.web.readOptions.uploadDirectory`)\n     this.setMeta('$webUploadDirectory', '/tmp/customUploadDir');\n   }\n\n   _perform(data){\n     // ...\n   }\n\n   _finalize(err, value){\n     // defining a custom header that only affects the web handler\n     // this call could be done inside of the _perform method. However, we\n     // are defining it inside of the _finalize to keep _perform as\n     // abstract as possible. Since, _finalize is always called (even during\n     // an error) after the execution of the action, it provides a way to\n     // hook and define custom metadata related with the result.\n     if (!err){\n       // defining a custom header by using the `$webHeaders` variable, rather\n       // than the full option location (`handler.web.writeOptions.headers`)\n       this.setMeta('$webHeaders', {\n         someOption: 'foo',\n       });\n     }\n\n     return super._finalize(err, value);\n   }\n}\n```\n\n**Full option location:**\nUses a convention interpreted by the {@link Handler.metadata} to describe\nwhere the option is localized:\n```\nhandler.<HANDLER_NAME>.<OPERATION>Options.<OPTION_NAME>\n```\n\nExample:\n```\nclass MyAction extends Mebo.Action{\n   constructor(){\n     super();\n     this.setMeta('handler.web.readOptions.uploadDirectory', '/tmp/customUploadDir');\n   }\n\n   _perform(data){\n     // ...\n   }\n\n   _finalize(err, value){\n\n     if (!err){\n       // location (not recommended, see option var)\n       this.setMeta('handler.web.writeOptions.headers', {\n         someOption: 'foo',\n       });\n     }\n\n     return super._finalize(err, value);\n   }\n}\n```\n\nThe complete list of the available option variables can be found bellow, it's\nseparated by handler type. Also, new variables can be assigned through\n{@link Metadata.registerOptionVar}.\n\n<h2>Web Variables</h2>\n\nVariable name | Value | Value used by\n--- | --- | ---\n$web | `handler.web` |\n$webUploadDirectory | `$web.readOptions.uploadDirectory` | {@link WebRequest}\n$webUploadPreserveName | `$web.readOptions.uploadPreserveName` | {@link WebRequest}\n$webUploadMaxFileSize | `$web.readOptions.uploadMaxFileSize` | {@link WebRequest}\n$webMaxFields | `$web.readOptions.maxFields` | {@link WebRequest}\n$webMaxFieldsSize | `$web.readOptions.maxFieldsSize` | {@link WebRequest}\n$webHeaders | `$web.writeOptions.headers` | {@link WebResponse}\n$webHeadersOnly | `$web.writeOptions.headersOnly`| {@link WebResponse}\n$webResult | `$web.writeOptions.result`| {@link WebResponse}\n$webRoot | `$web.writeOptions.root`| {@link WebResponse}\n$webStatus | `$web.writeOptions.status`| {@link WebResponse}\n$webResultLabel | `$web.writeOptions.resultLabel`| {@link WebResponse}\n\n<h2>Cli Variables</h2>\n\nVariable name | Value | Value used by\n--- | --- | ---\n$cli | `handler.cli` |\n$cliDescription | `$cli.readOptions.description` | {@link CliArgs}\n$cliResult | `$cli.writeOptions.result` | {@link CliOutput}",
    "lineNumber": 123,
    "interface": false
  },
  {
    "__docId__": 414,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Metadata.js~Metadata",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Metadata.js~Metadata#constructor",
    "access": null,
    "description": "Creates a metadata",
    "lineNumber": 128,
    "params": []
  },
  {
    "__docId__": 415,
    "kind": "member",
    "name": "[_collection]",
    "memberof": "src/Metadata.js~Metadata",
    "static": false,
    "longname": "src/Metadata.js~Metadata#[_collection]",
    "access": null,
    "description": null,
    "lineNumber": 129,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 416,
    "kind": "method",
    "name": "value",
    "memberof": "src/Metadata.js~Metadata",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Metadata.js~Metadata#value",
    "access": null,
    "description": "Returns a value under the metadata.",
    "lineNumber": 142,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "path about where the value is localized (the levels\nmust be separated by '.'). In case of empty string the entire metadata\nis returned."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "defaultValue",
        "description": "default value returned in case a value was\nnot found for the path"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 417,
    "kind": "method",
    "name": "setValue",
    "memberof": "src/Metadata.js~Metadata",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Metadata.js~Metadata#setValue",
    "access": null,
    "description": "Sets a value to the metadata.",
    "lineNumber": 158,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "path about where the value should be stored under the metadata\n(the levels must be separated by '.')"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value that is going to be stored under the collection"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "merge",
        "description": "this option is used to decide in case of the\nlast level is already existing under the collection, if the value should be\neither merged (default) or overridden."
      }
    ]
  },
  {
    "__docId__": 418,
    "kind": "method",
    "name": "root",
    "memberof": "src/Metadata.js~Metadata",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Metadata.js~Metadata#root",
    "access": null,
    "description": "Returns a list of the root levels under the metadata",
    "lineNumber": 169,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 419,
    "kind": "method",
    "name": "registerOptionVar",
    "memberof": "src/Metadata.js~Metadata",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Metadata.js~Metadata.registerOptionVar",
    "access": null,
    "description": "register an option variable under metadata\n\nThe value of the variable can contain other pre-defined option variables,\nfor instance:\n```\nMebo.Metadata.registerOptionVar('$myVar', '$otherVar.data')\n```",
    "lineNumber": 185,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "name of the variable"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value for the variable"
      }
    ]
  },
  {
    "__docId__": 420,
    "kind": "member",
    "name": "_cachedOptionVariables",
    "memberof": "src/Metadata.js~Metadata",
    "static": true,
    "longname": "src/Metadata.js~Metadata._cachedOptionVariables",
    "access": null,
    "description": null,
    "lineNumber": 193,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 421,
    "kind": "method",
    "name": "optionVar",
    "memberof": "src/Metadata.js~Metadata",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Metadata.js~Metadata.optionVar",
    "access": null,
    "description": "Returns the value for an option variable\n\nfor instance:\n```\nconst myVariableValue = Mebo.Metadata.optionVar('$myVariable');\nconsole.log(myVariableValue)\n```",
    "lineNumber": 216,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "name of the variable"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "processValue",
        "description": "process any variables that may be\ndefined as part of the value"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "throws an error if the var name is undefined\nunder the metadata."
      }
    ]
  },
  {
    "__docId__": 422,
    "kind": "method",
    "name": "hasOptionVar",
    "memberof": "src/Metadata.js~Metadata",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Metadata.js~Metadata.hasOptionVar",
    "access": null,
    "description": "Returns a boolean telling if the variable name is defined",
    "lineNumber": 236,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "variable name"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 423,
    "kind": "method",
    "name": "registeredOptionVars",
    "memberof": "src/Metadata.js~Metadata",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Metadata.js~Metadata.registeredOptionVars",
    "access": null,
    "description": "Returns a list of the registered variable names under the metadata",
    "lineNumber": 247,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 424,
    "kind": "method",
    "name": "_resolvePath",
    "memberof": "src/Metadata.js~Metadata",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Metadata.js~Metadata._resolvePath",
    "access": null,
    "description": "Returns the path resolved by processing any variables that may\nbe defined as part of the path",
    "lineNumber": 258,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "path to be resolved"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 425,
    "kind": "method",
    "name": "_resolveOptionVar",
    "memberof": "src/Metadata.js~Metadata",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Metadata.js~Metadata._resolveOptionVar",
    "access": "private",
    "description": "Returns the value of the variable by processing any variables\nthat may be defined as part of the value",
    "lineNumber": 291,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "variable name"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "rootName",
        "description": "root variable name used to report the origin\nof the circular reference error"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "depth",
        "description": "deep used to identify max recursion caused\nby circular references"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 426,
    "kind": "method",
    "name": "_validateOptionVarName",
    "memberof": "src/Metadata.js~Metadata",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Metadata.js~Metadata._validateOptionVarName",
    "access": "private",
    "description": "Check if the variable is defined using the proper syntax, otherwise in case\nof any issues an exception is raised",
    "lineNumber": 353,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "variable name"
      }
    ]
  },
  {
    "__docId__": 427,
    "kind": "member",
    "name": "_optionVariables",
    "memberof": "src/Metadata.js~Metadata",
    "static": true,
    "longname": "src/Metadata.js~Metadata._optionVariables",
    "access": null,
    "description": null,
    "lineNumber": 373,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 428,
    "kind": "member",
    "name": "_cachedOptionVariables",
    "memberof": "src/Metadata.js~Metadata",
    "static": true,
    "longname": "src/Metadata.js~Metadata._cachedOptionVariables",
    "access": null,
    "description": null,
    "lineNumber": 375,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 429,
    "kind": "member",
    "name": "_maxDepth",
    "memberof": "src/Metadata.js~Metadata",
    "static": true,
    "longname": "src/Metadata.js~Metadata._maxDepth",
    "access": null,
    "description": null,
    "lineNumber": 377,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 430,
    "kind": "file",
    "name": "src/Reader.js",
    "content": "const assert = require('assert');\nconst TypeCheck = require('js-typecheck');\nconst Action = require('./Action');\nconst Utils = require('./Utils');\n\n// symbols used for private instance variables to avoid any potential clashing\n// caused by re-implementations\nconst _action = Symbol('action');\nconst _options = Symbol('options');\nconst _result = Symbol('result');\n\n\n/**\n * A reader is used by the handler during the execution ({@link Handler.runAction})\n * to query the {@link Input} and {@link Session} information that is going be used\n * during the execution of the action.\n *\n * In case of new implements it's expected to implement the {@link Reader._perform}.\n *\n * When a value is found for an input it's decoded using {@link Input.parseValue}\n * where each input implementation has its own way of parsing the serialized data,\n * to find out about how a value is serialized for an specific input type you could simply\n * set an arbitrary value to an input then query it back through\n * {@link Input.serializeValue}. The reference bellow shows the basic serialization\n * for the inputs blundled with Mebo:\n *\n * Input Type | Scalar Serialization | Vector Serialization (compatible with JSON)\n * --- | --- | ---\n * {@link Text} | `'value'` | `'[\"valueA\",\"valueB\"]'`\n * {@link FilePath} | `'/tmp/a.txt'` | `'[\"/tmp/a.txt\",\"/tmp/b.txt\"]'`\n * {@link Bool} | `'true`' or `'1'` | `'[true,false]'` or `'[1,0]'`\n * {@link Numeric} | `'20'` | `'[20,30]'`\n * {@link Email} | `'test@email.com'` | `'[\"test@email.com\",\"test2@email.com\"]'`\n * {@link Ip} | `'192.168.0.1'` | `'[\"192.168.0.1\",\"192.168.0.2\"]'`\n * {@link Timestamp} | `'2017-02-02T22:26:30.431Z'` | \\\n * `'[\"2017-02-02T22:26:30.431Z\",\"2017-02-02T22:27:19.066Z\"]'`\n * {@link Url} | `'#http#://www.google.com'` | \\\n * `'[\"#http#://www.google.com\",\"#http#://www.wikipedia.com\"]'`\n * {@link Version} | `'10.1.1'` | `'[\"10.1.1\",\"10.2\"]'`\n * {@link Buf} | `'aGVsbG8='` | `'[\"aGVsbG8=\",\"d29ybGQ=\"]'`\n * {@link Hex} | `'ffff00'` | `'[\"ffff00\",\"ff\"]'`\n * {@link Hash} | `'d65709ab'` | `'[\"d65709ab\",\"b94d6fe4\"]'`\n * {@link UUID} | `'075054e0-810a-11e6-8c1d-e5fb28c699ca'` | \\\n * `'[\"075054e0-810a-11e6-8c1d-e5fb28c699ca\",\"98e631d3-6255-402a-88bd-66056e1ca9df\"]'`\n *\n * <br/>**Options:**\n * Custom options can be assigned to readers ({@link Reader.setOption}). They are\n * passed from the handler to the reader during the handler's execution\n * ({@link Handler.runAction}).\n *\n * ```\n * const myHandler = Mebo.Handler.create('someHandler');\n *\n * // setting reading options\n * myHandler.runAction('myAction', {\n *  someOption: 10,\n * });\n * ```\n *\n * When an action is executed through a handler it can define options via\n * the {@link Metadata} support. Detailed information about that can be found\n * at {@link Metadata}:\n *\n * ```\n * class MyAction extends Mebo.Action{\n *    constructor(){\n *      super();\n *\n *      // defining a custom reading option\n *      this.setMeta('$myOption', {\n *        someOption: 10,\n *      });\n *\n *      // ...\n *    }\n * }\n * Mebo.Action.register(MyAction, 'myAction');\n * ```\n *\n * **Hiding inputs from readers:**\n * A reader only sees inputs that are capable of serialization\n * ({@link Input.isSerializable}) or visible inputs. Therefore, any input assigned\n * with the property `hidden` is not visible by readers, for instance:\n *\n * ```\n * class Example extends Mebo.Action{\n *   constructor(){\n *     super();\n *     this.createInput('readerCantSeeMe: numeric', {hidden: true});\n *     this.createInput('readerSeeMe: numeric');\n *   }\n * }\n * ```\n */\nclass Reader{\n\n  /**\n   * Creates a reader.\n   *\n   * @param {Action} action - action used for the querying the values\n   */\n  constructor(action){\n\n    // note: currently reader & writer are completely separated entities that don't\n    // have a common parent class (aka HandlerOperation). The reason for\n    // that is currently they are so distinctive from each other that the only member in\n    // common is the option. In case they start to share more characteristics in common\n    // then a base class should be created.\n\n    this._setAction(action);\n    this[_result] = null;\n    this[_options] = new Utils.HierarchicalCollection();\n  }\n\n  /**\n   * Returns the action associated with the reader.\n   *\n   * @return {Action}\n   */\n  action(){\n    return this[_action];\n  }\n\n  /**\n   * Returns an option\n   *\n   * @param {string} path - path about where the option is localized (the levels\n   * must be separated by '.'). In case of an empty string it returns the\n   * entire options\n   * @param {*} [defaultValue] - default value returned in case a value was\n   * not found for the path\n   * @return {*}\n   */\n  option(path, defaultValue=undefined){\n    assert(TypeCheck.isString(path), 'path needs to be defined as string');\n    return this[_options].query(path, defaultValue);\n  }\n\n  /**\n   * Sets a value under the options\n   *\n   * @param {string} path - path about where the option should be stored under\n   * the options (the levels must be separated by '.')\n   * @param {*} value - value that is going to be stored under the collection\n   * @param {boolean} [merge=true] - this option is used to decide in case of the\n   * last level is already existing under the collection, if the value should be\n   * either merged (default) or overridden.\n   */\n  setOption(path, value, merge=true){\n    assert(TypeCheck.isString(path), 'path needs to be defined as string');\n\n    this[_options].insert(path, value, merge);\n  }\n\n  /**\n   * Returns a list of valid input names that should be used for the parsing.\n   * This avoids hidden inputs to get exposed in the parsing.\n   *\n   * @return {Array<string>}\n   */\n  validInputNames(){\n\n    const inputs = [];\n    for (const inputName of this[_action].inputNames()){\n      const input = this[_action].input(inputName);\n\n      if (input.isSerializable() && !input.property('hidden')){\n        inputs.push(input);\n      }\n    }\n\n    return inputs;\n  }\n\n  /**\n   * Reads the input values and returns it through a plain object.\n   *\n   * @return {Promise<object>}\n   */\n  async inputValues(){\n\n    if (!this[_result]){\n      await this._parse();\n    }\n\n    return this[_result];\n  }\n\n  /**\n   * Reads the autofill information and returns it through a plain object.\n   *\n   * If the autofill information is already assigned under autofill ({@link Action.session})\n   * then that information is skipped otherwise it adds the parsed information the result.\n   *\n   * @return {Promise<Object>}\n   */\n  async autofillValues(){\n    if (!this[_result]){\n      await this._parse();\n    }\n\n    const result = Object.create(null);\n    const action = this.action();\n    const session = action.session();\n    for (const inputName in this[_result]){\n\n      const autofillName = action.input(inputName).property('autofill');\n\n      if (autofillName){\n\n        // if the input name is already under autofill (assigned previously\n        // then not overriding them)\n        if (session && session.hasAutofill(autofillName)){\n          continue;\n        }\n        result[autofillName] = this[_result][inputName];\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * This method should be re-implemented by derived classes to perform the handler parsing.\n   *\n   * It should return a plain object containing the input name and the value for that.\n   * Where any input value from either String or Array types are considered valid values that\n   * are later ({@link Reader.inputValues}, {@link Reader.autofillValues})\n   * used to parse the value of the input ({@link Input.parseValue}), otherwise the value\n   * is ignored.\n   *\n   * Only return the ones that were found by the parsing. Also, in case of any error\n   * during the parsing then an exception should be raised.\n   *\n   * @param {Array<Input>} inputList - Valid list of inputs that should be used for\n   * the parsing\n   * @return {Promise<Object>}\n   *\n   * @protected\n   */\n  _perform(inputList){\n    return Promise.reject(new Error('Not implemented'));\n  }\n\n  /**\n   * Sets the action associated with the reader.\n   *\n   * @param {Action} value - action instance\n   */\n  _setAction(value){\n    assert(value instanceof Action, 'Invalid action');\n\n    this[_action] = value;\n  }\n\n  /**\n   * Auxiliary method that triggers the parsing if needed (in case it has not been\n   * triggered yet).\n   *\n   * @return {Promise}\n   * @private\n   */\n  async _parse(){\n    if (!this._parsed){\n      this[_result] = await this._perform(this.validInputNames());\n      const action = this.action();\n\n      // decoding the values if needed\n      for (const inputName in this[_result]){\n        const input = action.input(inputName);\n        const value = this[_result][inputName];\n\n        if (TypeCheck.isString(value)){\n          this[_result][inputName] = input.parseValue(value, false);\n        }\n        else if (TypeCheck.isList(value)){\n          // currently it's converting any array to a JSON string which is supported\n          // by the input parsing. Lets keep an eye on this for now, since it may cause\n          // an overhead\n          this[_result][inputName] = input.parseValue(JSON.stringify(value), false);\n        }\n      }\n    }\n\n    return this[_result];\n  }\n}\n\nmodule.exports = Reader;\n",
    "static": true,
    "longname": "src/Reader.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 431,
    "kind": "variable",
    "name": "__import_module__assert",
    "memberof": "src/Reader.js",
    "static": true,
    "longname": "src/Reader.js~__import_module__assert",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Reader.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 432,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Reader.js",
    "static": true,
    "longname": "src/Reader.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Reader.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 433,
    "kind": "variable",
    "name": "__import_module__Action",
    "memberof": "src/Reader.js",
    "static": true,
    "longname": "src/Reader.js~__import_module__Action",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Reader.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 434,
    "kind": "variable",
    "name": "__import_module__Utils",
    "memberof": "src/Reader.js",
    "static": true,
    "longname": "src/Reader.js~__import_module__Utils",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Reader.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 435,
    "kind": "variable",
    "name": "_action",
    "memberof": "src/Reader.js",
    "static": true,
    "longname": "src/Reader.js~_action",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Reader.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 436,
    "kind": "variable",
    "name": "_options",
    "memberof": "src/Reader.js",
    "static": true,
    "longname": "src/Reader.js~_options",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Reader.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 437,
    "kind": "variable",
    "name": "_result",
    "memberof": "src/Reader.js",
    "static": true,
    "longname": "src/Reader.js~_result",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Reader.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 438,
    "kind": "class",
    "name": "Reader",
    "memberof": "src/Reader.js",
    "static": true,
    "longname": "src/Reader.js~Reader",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Reader.js",
    "importStyle": "Reader",
    "description": "A reader is used by the handler during the execution ({@link Handler.runAction})\nto query the {@link Input} and {@link Session} information that is going be used\nduring the execution of the action.\n\nIn case of new implements it's expected to implement the {@link Reader._perform}.\n\nWhen a value is found for an input it's decoded using {@link Input.parseValue}\nwhere each input implementation has its own way of parsing the serialized data,\nto find out about how a value is serialized for an specific input type you could simply\nset an arbitrary value to an input then query it back through\n{@link Input.serializeValue}. The reference bellow shows the basic serialization\nfor the inputs blundled with Mebo:\n\nInput Type | Scalar Serialization | Vector Serialization (compatible with JSON)\n--- | --- | ---\n{@link Text} | `'value'` | `'[\"valueA\",\"valueB\"]'`\n{@link FilePath} | `'/tmp/a.txt'` | `'[\"/tmp/a.txt\",\"/tmp/b.txt\"]'`\n{@link Bool} | `'true`' or `'1'` | `'[true,false]'` or `'[1,0]'`\n{@link Numeric} | `'20'` | `'[20,30]'`\n{@link Email} | `'test@email.com'` | `'[\"test@email.com\",\"test2@email.com\"]'`\n{@link Ip} | `'192.168.0.1'` | `'[\"192.168.0.1\",\"192.168.0.2\"]'`\n{@link Timestamp} | `'2017-02-02T22:26:30.431Z'` |  `'[\"2017-02-02T22:26:30.431Z\",\"2017-02-02T22:27:19.066Z\"]'`\n{@link Url} | `'#http#://www.google.com'` |  `'[\"#http#://www.google.com\",\"#http#://www.wikipedia.com\"]'`\n{@link Version} | `'10.1.1'` | `'[\"10.1.1\",\"10.2\"]'`\n{@link Buf} | `'aGVsbG8='` | `'[\"aGVsbG8=\",\"d29ybGQ=\"]'`\n{@link Hex} | `'ffff00'` | `'[\"ffff00\",\"ff\"]'`\n{@link Hash} | `'d65709ab'` | `'[\"d65709ab\",\"b94d6fe4\"]'`\n{@link UUID} | `'075054e0-810a-11e6-8c1d-e5fb28c699ca'` |  `'[\"075054e0-810a-11e6-8c1d-e5fb28c699ca\",\"98e631d3-6255-402a-88bd-66056e1ca9df\"]'`\n\n<br/>**Options:**\nCustom options can be assigned to readers ({@link Reader.setOption}). They are\npassed from the handler to the reader during the handler's execution\n({@link Handler.runAction}).\n\n```\nconst myHandler = Mebo.Handler.create('someHandler');\n\n// setting reading options\nmyHandler.runAction('myAction', {\n someOption: 10,\n});\n```\n\nWhen an action is executed through a handler it can define options via\nthe {@link Metadata} support. Detailed information about that can be found\nat {@link Metadata}:\n\n```\nclass MyAction extends Mebo.Action{\n   constructor(){\n     super();\n\n     // defining a custom reading option\n     this.setMeta('$myOption', {\n       someOption: 10,\n     });\n\n     // ...\n   }\n}\nMebo.Action.register(MyAction, 'myAction');\n```\n\n**Hiding inputs from readers:**\nA reader only sees inputs that are capable of serialization\n({@link Input.isSerializable}) or visible inputs. Therefore, any input assigned\nwith the property `hidden` is not visible by readers, for instance:\n\n```\nclass Example extends Mebo.Action{\n  constructor(){\n    super();\n    this.createInput('readerCantSeeMe: numeric', {hidden: true});\n    this.createInput('readerSeeMe: numeric');\n  }\n}\n```",
    "lineNumber": 92,
    "interface": false
  },
  {
    "__docId__": 439,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Reader.js~Reader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Reader.js~Reader#constructor",
    "access": null,
    "description": "Creates a reader.",
    "lineNumber": 99,
    "params": [
      {
        "nullable": null,
        "types": [
          "Action"
        ],
        "spread": false,
        "optional": false,
        "name": "action",
        "description": "action used for the querying the values"
      }
    ]
  },
  {
    "__docId__": 440,
    "kind": "member",
    "name": "[_result]",
    "memberof": "src/Reader.js~Reader",
    "static": false,
    "longname": "src/Reader.js~Reader#[_result]",
    "access": null,
    "description": null,
    "lineNumber": 108,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 441,
    "kind": "member",
    "name": "[_options]",
    "memberof": "src/Reader.js~Reader",
    "static": false,
    "longname": "src/Reader.js~Reader#[_options]",
    "access": null,
    "description": null,
    "lineNumber": 109,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 442,
    "kind": "method",
    "name": "action",
    "memberof": "src/Reader.js~Reader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Reader.js~Reader#action",
    "access": null,
    "description": "Returns the action associated with the reader.",
    "lineNumber": 117,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Action"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 443,
    "kind": "method",
    "name": "option",
    "memberof": "src/Reader.js~Reader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Reader.js~Reader#option",
    "access": null,
    "description": "Returns an option",
    "lineNumber": 131,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "path about where the option is localized (the levels\nmust be separated by '.'). In case of an empty string it returns the\nentire options"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "defaultValue",
        "description": "default value returned in case a value was\nnot found for the path"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 444,
    "kind": "method",
    "name": "setOption",
    "memberof": "src/Reader.js~Reader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Reader.js~Reader#setOption",
    "access": null,
    "description": "Sets a value under the options",
    "lineNumber": 146,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "path about where the option should be stored under\nthe options (the levels must be separated by '.')"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value that is going to be stored under the collection"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "merge",
        "description": "this option is used to decide in case of the\nlast level is already existing under the collection, if the value should be\neither merged (default) or overridden."
      }
    ]
  },
  {
    "__docId__": 445,
    "kind": "method",
    "name": "validInputNames",
    "memberof": "src/Reader.js~Reader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Reader.js~Reader#validInputNames",
    "access": null,
    "description": "Returns a list of valid input names that should be used for the parsing.\nThis avoids hidden inputs to get exposed in the parsing.",
    "lineNumber": 158,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 446,
    "kind": "method",
    "name": "inputValues",
    "memberof": "src/Reader.js~Reader",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Reader.js~Reader#inputValues",
    "access": null,
    "description": "Reads the input values and returns it through a plain object.",
    "lineNumber": 177,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise<object>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 447,
    "kind": "method",
    "name": "autofillValues",
    "memberof": "src/Reader.js~Reader",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Reader.js~Reader#autofillValues",
    "access": null,
    "description": "Reads the autofill information and returns it through a plain object.\n\nIf the autofill information is already assigned under autofill ({@link Action.session})\nthen that information is skipped otherwise it adds the parsed information the result.",
    "lineNumber": 194,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Object>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 448,
    "kind": "method",
    "name": "_perform",
    "memberof": "src/Reader.js~Reader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Reader.js~Reader#_perform",
    "access": "protected",
    "description": "This method should be re-implemented by derived classes to perform the handler parsing.\n\nIt should return a plain object containing the input name and the value for that.\nWhere any input value from either String or Array types are considered valid values that\nare later ({@link Reader.inputValues}, {@link Reader.autofillValues})\nused to parse the value of the input ({@link Input.parseValue}), otherwise the value\nis ignored.\n\nOnly return the ones that were found by the parsing. Also, in case of any error\nduring the parsing then an exception should be raised.",
    "lineNumber": 238,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<Input>"
        ],
        "spread": false,
        "optional": false,
        "name": "inputList",
        "description": "Valid list of inputs that should be used for\nthe parsing"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Object>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 449,
    "kind": "method",
    "name": "_setAction",
    "memberof": "src/Reader.js~Reader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Reader.js~Reader#_setAction",
    "access": null,
    "description": "Sets the action associated with the reader.",
    "lineNumber": 247,
    "params": [
      {
        "nullable": null,
        "types": [
          "Action"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "action instance"
      }
    ]
  },
  {
    "__docId__": 450,
    "kind": "member",
    "name": "[_action]",
    "memberof": "src/Reader.js~Reader",
    "static": false,
    "longname": "src/Reader.js~Reader#[_action]",
    "access": null,
    "description": null,
    "lineNumber": 250,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 451,
    "kind": "method",
    "name": "_parse",
    "memberof": "src/Reader.js~Reader",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Reader.js~Reader#_parse",
    "access": "private",
    "description": "Auxiliary method that triggers the parsing if needed (in case it has not been\ntriggered yet).",
    "lineNumber": 260,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 452,
    "kind": "member",
    "name": "[_result]",
    "memberof": "src/Reader.js~Reader",
    "static": false,
    "longname": "src/Reader.js~Reader#[_result]",
    "access": null,
    "description": null,
    "lineNumber": 262,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 453,
    "kind": "file",
    "name": "src/Readers/CliArgs.js",
    "content": "const path = require('path');\nconst neodoc = require('neodoc');\nconst assert = require('assert');\nconst TypeCheck = require('js-typecheck');\nconst Inputs = require('../Inputs');\nconst Settings = require('../Settings');\nconst Handler = require('../Handler');\nconst Reader = require('../Reader');\n\n\n// symbols used for private instance variables to avoid any potential clashing\n// caused by re-implementations\nconst _args = Symbol('args');\n\n/**\n * command-line arguments reader.\n *\n * This reader is used by the {@link Cli} handler. It supports most of\n * the docopt specification. Also, if the reader finds an error it's capable of\n * reporting it in user-friendly way. This is used to report `-h/--help` and\n * missing arguments.\n *\n * All serializable inputs are supported by this handler, they can be displayed\n * either as `argument` or `option` element. This is done by setting the input\n * property `elementType` (option is the default one).\n *\n * You can define the description displayed in the help of the element by\n * setting the input property `description`.\n *\n * The `option` elements support `short option` by setting the input property\n * `shortOption`.\n *\n * In order to accommodate how vector values are represented in a command-line\n * interface, this reader expects vector elements to be separated by\n * the space character.\n *\n * Any {@link Bool} input specified as an `option` element behaves in a\n * special mode, since it's treated as a toogle option in command-line.\n * Therefore if the Bool input is assigned with a `true` then the option\n * gets the prefix `no-`.\n *\n * When a value is found for the input, it gets loaded via {@link Input.parseValue}\n * where each input implementation has its own way of parsing the serialized data,\n * to find out about how a value is serialized for an specific input type you could simply\n * set an arbitrary value to the input you are interested then query it back through\n * {@link Input.serializeValue}. Also, Mebo provides a reference datasheet\n * about the serialization forms for the inputs bundled with it, found at {@link Reader}.\n *\n * <h2>Options Summary</h2>\n *\n * Option Name | Description | Default Value\n * --- | --- | :---:\n * description | description about the program displayed at the header of the help \\\n * | ::none::\n * parsingErrorStatusCode | Custom error status code used to identify when the \\\n * app args could not be parsed | `700`\n *\n * @see http://docopt.org\n */\nclass CliArgs extends Reader{\n\n  /**\n   * Creates an args reader\n   *\n   * @param {Action} action - action that should be used by the reader\n   * @param {Array<string>} argv - list of arguments that should be used by\n   * the reader\n   */\n  constructor(action, argv){\n    super(action);\n\n    this._setArgs(argv);\n\n    // default options\n    this.setOption('description', '');\n    this.setOption('parsingErrorStatusCode', 700);\n  }\n\n  /**\n   * Returns a list of args used by the reader, by default it uses\n   * `process.argv`.\n   *\n   * @return {Array<string>}\n   */\n  args(){\n    return this[_args];\n  }\n\n  /**\n   * Returns the executable name based on the args\n   *\n   * @return {string}\n   */\n  executableName(){\n    return path.basename(this.args()[1]);\n  }\n\n  /**\n   * Implements the reader\n   *\n   * @param {Array<Input>} inputList - Valid list of inputs that should be used for\n   * the parsing\n   * @return {Promise<Object>}\n   * @protected\n   */\n  async _perform(inputList){\n    const helpElements = await this.constructor._helpElements(inputList);\n    const helpString = await this._helpInterface(helpElements);\n\n    let parsedArgs = Object.create(null);\n    // it thrown an exception if something went wrong (like missing a required parameter)\n    try{\n      parsedArgs = neodoc.run(helpString, {\n        argv: (this.args().includes('--help') || this.args().includes('-h')) ? ['-h'] : this.args().slice(2),\n        dontExit: true,\n        smartOptions: true,\n        repeatableOptions: true,\n        version: Settings.get('apiVersion'),\n      });\n    }\n    catch(err){\n      // adding a custom status code for the parsing error\n      // the error does not come as an instance of error, for this reason\n      // creating a new error and copying the contents\n      const error = Object.assign(new Error(), err);\n      error.status = this.option('parsingErrorStatusCode');\n      throw error;\n    }\n\n    // however when the user asks for the help it does not raises an exception\n    if ('.help' in parsedArgs){\n      const error = new Error(parsedArgs['.help']);\n      error.status = this.option('parsingErrorStatusCode');\n      throw error;\n    }\n\n    for (const input of inputList){\n      if (input instanceof Inputs.Bool && !input.isVector()){\n        input.setValue(Boolean(input.value()));\n      }\n    }\n\n    const alreadyParsed = [];\n    const result = Object.create(null);\n\n    // collecting the input values\n    for (const elementName in parsedArgs){\n      let foundInputName;\n\n      // finding the input name\n      for (const elementType in helpElements){\n        for (const inputName in helpElements[elementType]){\n          const inputData = helpElements[elementType][inputName];\n          if (inputData.usageDisplay.split('=')[0] === elementName || inputData.shortOption === elementName){\n            foundInputName = inputName;\n            break;\n          }\n        }\n\n        if (foundInputName){\n          break;\n        }\n      }\n\n      // querying the input value\n      const inputNames = inputList.map(x => x.name());\n      if (foundInputName && !alreadyParsed.includes(foundInputName)){\n        alreadyParsed.push(foundInputName);\n\n        const input = inputList[inputNames.indexOf(foundInputName)];\n\n        let value;\n        if (TypeCheck.isBool(parsedArgs[elementName]) && !input.isVector()){\n          value = String(!input.value());\n        }\n        else{\n          if (input.isVector() && !TypeCheck.isList(parsedArgs[elementName])){\n            value = [parsedArgs[elementName]];\n          }\n          else{\n            value = parsedArgs[elementName];\n          }\n        }\n        result[foundInputName] = value;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Sets a list of argument values used by the reader. It must follow\n   * the same pattern found at `process.argv`\n   *\n   * @param {Array<string>} value - argument list\n   * @private\n   */\n  _setArgs(value){\n    assert(TypeCheck.isList(value), 'value needs to be a list');\n    assert(value.length >= 2, 'missing first argument process.execPath and second argument javaScript file being executed');\n\n    this[_args] = value.slice(0);\n  }\n\n  /**\n   * Returns an object containing the elements that can be used by the command\n   *\n   * @param {Array<Input>} inputList - list of input that should be used to build\n   * query the help\n   * @return {Object}\n   * @private\n   */\n  static async _helpElements(inputList){\n\n    const elements = {\n      argument: {},\n      option: {},\n    };\n\n    // building inputs\n    const addedArgs = [];\n    const descriptions = await Promise.all(inputList.map(x => this._computeInfoDisplay(x)));\n\n    let currentIndex = 0;\n    for (const input of inputList){\n\n      const inputName = input.name();\n      let argName = this._camelCaseToArgument(inputName);\n\n      // in case of a boolean input that is true by default adding\n      // the `no` prefix to the input name automatically. For boolean inputs they\n      // work as toggles when represented through the command line\n      if (input instanceof Inputs.Bool && !input.isVector() && input.value()){\n        argName = `no-${argName}`;\n      }\n\n      assert(!addedArgs.includes(argName), `Ambiguous argument name (${argName}), used multiple times!`);\n      addedArgs.push(argName);\n\n      const elementType = input.property('elementType');\n\n      const inputData = Object.create(null);\n      inputData.description = descriptions[currentIndex];\n      inputData.elementDisplay = this._elementDisplay(argName, input);\n      inputData.usageDisplay = this._usageDisplay(argName, input);\n      inputData.required = ((input.isRequired() && input.isEmpty()) && !(input instanceof Inputs.Bool && !input.isVector()));\n      inputData.vector = input.isVector();\n\n      if (elementType === 'option'){\n        inputData.shortOptionDisplay = this._shortOptionDisplay(input);\n        inputData.shortOption = this._shortOption(input);\n      }\n\n      elements[elementType][inputName] = inputData;\n\n      currentIndex++;\n    }\n\n    return elements;\n  }\n\n  /**\n   * Returns the help interface displayed when `-h\\--help` is required\n   *\n   * @param {Object} elements - elements holder object\n   * @return {string}\n   * @private\n   */\n  _helpInterface(elements){\n    let output = '';\n    output += this._buildDescription(elements);\n    output += this._buildUsage(elements);\n    output += this.constructor._buildColumns(elements);\n\n    return output;\n  }\n\n  /**\n   * Returns a string containing the full assembled info for the input\n   *\n   * @param {Input} input - input that should be used\n   * @return {Promise<string>}\n   * @private\n   */\n  static async _computeInfoDisplay(input){\n\n    const inputTypeName = input.property('type');\n\n    // adding the value type to the argument\n    const isBoolInput = input instanceof Inputs.Bool;\n    let description = input.property('description') || '';\n\n    if ((isBoolInput && input.isVector()) || !isBoolInput){\n\n      // adding the default value as part of the description\n      if (!input.isEmpty()){\n        let serializedValue = await input.serializeValue();\n        serializedValue = (input.isVector()) ? JSON.parse(serializedValue) : [serializedValue];\n        const defaultValue = [];\n\n        for (const value of serializedValue){\n\n          if (TypeCheck.isString(value) && Number.isNaN(Number(value))){\n            const scapedValue = value.replace(new RegExp('\"', 'g'), '\\\\\"');\n            defaultValue.push(`\"${scapedValue}\"`);\n          }\n          else{\n            defaultValue.push(value);\n          }\n        }\n\n        if (description.length){\n          description += ' ';\n        }\n        description += `[default: ${defaultValue.join(' ')}]`;\n      }\n    }\n\n    const inputTypeDisplay = input.isVector() ? `${inputTypeName}[]` : inputTypeName;\n\n    if (description.length){\n      description += ' ';\n    }\n    description += `(${inputTypeDisplay} type).`;\n\n    return description;\n  }\n\n  /**\n   * Returns a string containing the full element display for either an option\n   * or argument\n   *\n   * @param {string} name - element given name\n   * @param {Input} input - input that should be used\n   * @return {string}\n   * @private\n   */\n  static _elementDisplay(name, input){\n\n    let result = '';\n\n    if (input.property('elementType') === 'option'){\n      const shortOption = this._shortOptionDisplay(input);\n\n      const isBoolInput = input instanceof Inputs.Bool;\n      if ((isBoolInput && input.isVector()) || !isBoolInput){\n\n        // adding short option\n        if (shortOption){\n          result += shortOption;\n\n          if (input.isVector()){\n            result += '...';\n          }\n\n          result += ', ';\n        }\n\n        result += this._usageDisplay(name, input);\n\n        if (input.isVector()){\n          result += '...';\n        }\n      }\n      else{\n        if (shortOption){\n          result += shortOption;\n          result += ', ';\n        }\n\n        result += this._usageDisplay(name, input);\n      }\n    }\n    else{\n      result = name;\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns a string containing the usage display for either\n   * the option or argument\n   *\n   * @param {string} name - how the element should be called\n   * @param {Input} input - input that should be used\n   * @return {string}\n   * @private\n   */\n  static _usageDisplay(name, input){\n    let result = '';\n\n    if (input.property('elementType') === 'option'){\n      // adding long option\n      result = `--${name}`;\n\n      const isBoolInput = input instanceof Inputs.Bool;\n      if ((isBoolInput && input.isVector()) || !isBoolInput){\n        result = `${result}=<value>`;\n      }\n    }\n    else{\n      result = `<${name}>`;\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns a string containing the the short option, in case the input\n   * does not have a short option property defined then an empty string\n   * is returned instead\n   *\n   * @param {Input} input - input that should be used\n   * @return {string}\n   * @private\n   */\n  static _shortOption(input){\n    const shortOption = input.property('shortOption');\n    if (shortOption){\n      return `-${shortOption}`;\n    }\n\n    return '';\n  }\n\n  /**\n   * Returns a string containing the display of the short option,\n   * This is used when listing the element options\n   *\n   * @param {Input} input - input that should be used\n   * @return {string}\n   * @private\n   */\n  static _shortOptionDisplay(input){\n    let result = this._shortOption(input);\n    if (result.length && !(input instanceof Inputs.Bool && !input.isVector())){\n      result = `${result}=<value>`;\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns a string containing the description of the command\n   *\n   * @param {Object} elements - elements holder object\n   * @return {string}\n   * @private\n   */\n  _buildDescription(elements){\n    let output = '';\n    const description = this.option('description');\n    if (description.length){\n      output += description;\n      if (!description.endsWith('.')){\n        output += '.';\n      }\n      output += '\\n\\n';\n    }\n\n    return output;\n  }\n\n  /**\n   * Builds a string containing the usage\n   *\n   * @param {Object} elements - elements holder object\n   * @return {string}\n   * @private\n   */\n  _buildUsage(elements){\n    let output = `Usage: ${this.executableName()} `;\n\n    const requiredArguments = Object.create(null);\n    const optionalArguments = Object.create(null);\n    const requiredOptions = Object.keys(elements.option).filter(x => elements.option[x].required);\n    let requiredArgumentsOrder = [];\n    let optionalArgumentsOrder = [];\n\n    if (requiredOptions.length){\n      output += requiredOptions.map(x => elements.option[x].usageDisplay).join(' ');\n      output += ' ';\n    }\n    output += '[options]';\n\n    // building arguments\n    if (Object.keys(elements.argument).length){\n      for (const inputName in elements.argument){\n        if (elements.argument[inputName].required){\n          requiredArguments[inputName] = elements.argument[inputName];\n        }\n        else{\n          optionalArguments[inputName] = elements.argument[inputName];\n        }\n      }\n\n      const requiredArgumentNames = Object.keys(requiredArguments);\n      requiredArgumentsOrder = requiredArgumentNames.filter(x => !requiredArguments[x].vector);\n      requiredArgumentsOrder = requiredArgumentsOrder.concat(requiredArgumentNames.filter(x => !requiredArgumentsOrder.includes(x)));\n\n      // first adding the required arguments\n      let hasVectorRequiredArgument = false;\n      for (const inputName of requiredArgumentsOrder){\n        output += ' ';\n        output += requiredArguments[inputName].usageDisplay;\n\n        if (requiredArguments[inputName].vector && Object.keys(optionalArguments).length === 0){\n          if (requiredArgumentsOrder.indexOf(inputName) === requiredArgumentsOrder.length - 1){\n            output += '...';\n            hasVectorRequiredArgument = true;\n          }\n        }\n      }\n\n      // then adding the optional ones\n      const optionalArgumentNames = Object.keys(optionalArguments);\n      optionalArgumentsOrder = optionalArgumentNames.filter(x => !optionalArguments[x].vector);\n      optionalArgumentsOrder = optionalArgumentsOrder.concat(optionalArgumentNames.filter(x => !optionalArgumentsOrder.includes(x)));\n\n      for (const inputName in optionalArguments){\n        output += ' [';\n        output += optionalArguments[inputName].usageDisplay;\n        output += ']';\n\n        if (optionalArguments[inputName].vector && !hasVectorRequiredArgument){\n          if (optionalArgumentsOrder.indexOf(inputName) === optionalArgumentsOrder.length - 1){\n            output += '...';\n          }\n        }\n      }\n    }\n\n    output += this._buildUsageVectorOptions(elements, requiredArgumentsOrder, requiredOptions);\n\n    return output;\n  }\n\n  /**\n   * Builds a string containing the usage for the vector options\n   *\n   * @param {Object} elements - elements holder object\n   * @param {Array<string>} argumentNames - list of argument names\n   * @param {Array<string>} requiredOptionNames - list of required option names\n   * @return {string}\n   * @private\n   */\n  _buildUsageVectorOptions(elements, argumentNames, requiredOptionNames){\n    let output = '';\n\n    // adding the usage for the vector options\n    for (const inputName in elements.option){\n\n      if (elements.option[inputName].vector){\n        output += `\\n       ${this.executableName()} `;\n\n        for (const requiredArg of argumentNames){\n          output += elements.argument[requiredArg].usageDisplay;\n          output += ' ';\n        }\n\n        output += '[options] ';\n        if (requiredOptionNames.length){\n          output += requiredOptionNames.filter(y => y !== inputName).map(x => elements.option[x].usageDisplay).join(' ');\n          output += ' ';\n        }\n\n        if (!requiredOptionNames.includes(inputName)){\n          output += '[';\n        }\n\n        output += elements.option[inputName].usageDisplay;\n        output += '...';\n\n        if (!requiredOptionNames.includes(inputName)){\n          output += ']';\n        }\n      }\n    }\n\n    return output;\n  }\n\n  /**\n   * Builds a string containing the columns displayed by the arguments and options\n   *\n   * @param {Object} elements - elements holder object\n   * @return {string}\n   * @private\n   */\n  static _buildColumns(elements){\n    let columns = '\\n';\n    const elementTypeDisplayName = Object.create(null);\n    elementTypeDisplayName.option = 'Options:';\n    elementTypeDisplayName.argument = 'Arguments:';\n\n    // figuring out the element column width\n    const elementTypeWidth = this._computeElementsWidth(elements);\n\n    for (const element in elements){\n\n      if (Object.keys(elements[element]).length){\n        columns += '\\n';\n        columns += elementTypeDisplayName[element];\n        columns += '\\n';\n\n        for (const inputName in elements[element]){\n\n          const elementData = elements[element][inputName];\n\n          // element\n          columns += '  ';\n          columns += elementData.elementDisplay;\n          columns += ' '.repeat(elementTypeWidth[element] - elementData.elementDisplay.length);\n\n          // description\n          // the second separator is actually a `hair space` char, this is necessary to separate\n          // the element from the description in neodoc\n          columns += ' ';\n          columns += elementData.description;\n          columns += '\\n';\n        }\n      }\n    }\n\n    return columns;\n  }\n\n  /**\n   * Returns a plain object containing the width for each of the element types\n   * (argument and option)\n   *\n   * @param {Object} elements - elements holder object\n   * @return {Object}\n   * @private\n   */\n  static _computeElementsWidth(elements){\n    const elementTypeWidth = Object.create(null);\n    for (const elementType in elements){\n      for (const inputName in elements[elementType]){\n        elementTypeWidth[elementType] = Math.max(elementTypeWidth[elementType] || 0,\n          elements[elementType][inputName].elementDisplay.length);\n      }\n    }\n\n    return elementTypeWidth;\n  }\n\n  /**\n   * Converts the input text from camelCase to dash-convention used\n   * in CLI applications\n   *\n   * @param {string} text - text that should be converted\n   * @return {string}\n   * @private\n   */\n  static _camelCaseToArgument(text){\n    return text.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n  }\n}\n\n// registering reader\nHandler.registerReader(CliArgs, 'cli');\n\nmodule.exports = CliArgs;\n",
    "static": true,
    "longname": "src/Readers/CliArgs.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 454,
    "kind": "variable",
    "name": "__import_module__path",
    "memberof": "src/Readers/CliArgs.js",
    "static": true,
    "longname": "src/Readers/CliArgs.js~__import_module__path",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Readers/CliArgs.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 455,
    "kind": "variable",
    "name": "__import_module__neodoc",
    "memberof": "src/Readers/CliArgs.js",
    "static": true,
    "longname": "src/Readers/CliArgs.js~__import_module__neodoc",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Readers/CliArgs.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 456,
    "kind": "variable",
    "name": "__import_module__assert",
    "memberof": "src/Readers/CliArgs.js",
    "static": true,
    "longname": "src/Readers/CliArgs.js~__import_module__assert",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Readers/CliArgs.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 457,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Readers/CliArgs.js",
    "static": true,
    "longname": "src/Readers/CliArgs.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Readers/CliArgs.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 458,
    "kind": "variable",
    "name": "__import_module__Inputs",
    "memberof": "src/Readers/CliArgs.js",
    "static": true,
    "longname": "src/Readers/CliArgs.js~__import_module__Inputs",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Readers/CliArgs.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 459,
    "kind": "variable",
    "name": "__import_module__Settings",
    "memberof": "src/Readers/CliArgs.js",
    "static": true,
    "longname": "src/Readers/CliArgs.js~__import_module__Settings",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Readers/CliArgs.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 460,
    "kind": "variable",
    "name": "__import_module__Handler",
    "memberof": "src/Readers/CliArgs.js",
    "static": true,
    "longname": "src/Readers/CliArgs.js~__import_module__Handler",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Readers/CliArgs.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 461,
    "kind": "variable",
    "name": "__import_module__Reader",
    "memberof": "src/Readers/CliArgs.js",
    "static": true,
    "longname": "src/Readers/CliArgs.js~__import_module__Reader",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Readers/CliArgs.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 462,
    "kind": "variable",
    "name": "_args",
    "memberof": "src/Readers/CliArgs.js",
    "static": true,
    "longname": "src/Readers/CliArgs.js~_args",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Readers/CliArgs.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 463,
    "kind": "class",
    "name": "CliArgs",
    "memberof": "src/Readers/CliArgs.js",
    "static": true,
    "longname": "src/Readers/CliArgs.js~CliArgs",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Readers/CliArgs.js",
    "importStyle": "CliArgs",
    "description": "command-line arguments reader.\n\nThis reader is used by the {@link Cli} handler. It supports most of\nthe docopt specification. Also, if the reader finds an error it's capable of\nreporting it in user-friendly way. This is used to report `-h/--help` and\nmissing arguments.\n\nAll serializable inputs are supported by this handler, they can be displayed\neither as `argument` or `option` element. This is done by setting the input\nproperty `elementType` (option is the default one).\n\nYou can define the description displayed in the help of the element by\nsetting the input property `description`.\n\nThe `option` elements support `short option` by setting the input property\n`shortOption`.\n\nIn order to accommodate how vector values are represented in a command-line\ninterface, this reader expects vector elements to be separated by\nthe space character.\n\nAny {@link Bool} input specified as an `option` element behaves in a\nspecial mode, since it's treated as a toogle option in command-line.\nTherefore if the Bool input is assigned with a `true` then the option\ngets the prefix `no-`.\n\nWhen a value is found for the input, it gets loaded via {@link Input.parseValue}\nwhere each input implementation has its own way of parsing the serialized data,\nto find out about how a value is serialized for an specific input type you could simply\nset an arbitrary value to the input you are interested then query it back through\n{@link Input.serializeValue}. Also, Mebo provides a reference datasheet\nabout the serialization forms for the inputs bundled with it, found at {@link Reader}.\n\n<h2>Options Summary</h2>\n\nOption Name | Description | Default Value\n--- | --- | :---:\ndescription | description about the program displayed at the header of the help  | ::none::\nparsingErrorStatusCode | Custom error status code used to identify when the  app args could not be parsed | `700`",
    "see": [
      "http://docopt.org"
    ],
    "lineNumber": 58,
    "interface": false,
    "extends": [
      "Reader"
    ]
  },
  {
    "__docId__": 464,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Readers/CliArgs.js~CliArgs",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Readers/CliArgs.js~CliArgs#constructor",
    "access": null,
    "description": "Creates an args reader",
    "lineNumber": 67,
    "params": [
      {
        "nullable": null,
        "types": [
          "Action"
        ],
        "spread": false,
        "optional": false,
        "name": "action",
        "description": "action that should be used by the reader"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "argv",
        "description": "list of arguments that should be used by\nthe reader"
      }
    ]
  },
  {
    "__docId__": 465,
    "kind": "method",
    "name": "args",
    "memberof": "src/Readers/CliArgs.js~CliArgs",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Readers/CliArgs.js~CliArgs#args",
    "access": null,
    "description": "Returns a list of args used by the reader, by default it uses\n`process.argv`.",
    "lineNumber": 83,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 466,
    "kind": "method",
    "name": "executableName",
    "memberof": "src/Readers/CliArgs.js~CliArgs",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Readers/CliArgs.js~CliArgs#executableName",
    "access": null,
    "description": "Returns the executable name based on the args",
    "lineNumber": 92,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 467,
    "kind": "method",
    "name": "_perform",
    "memberof": "src/Readers/CliArgs.js~CliArgs",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Readers/CliArgs.js~CliArgs#_perform",
    "access": "protected",
    "description": "Implements the reader",
    "lineNumber": 104,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<Input>"
        ],
        "spread": false,
        "optional": false,
        "name": "inputList",
        "description": "Valid list of inputs that should be used for\nthe parsing"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Object>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 468,
    "kind": "method",
    "name": "_setArgs",
    "memberof": "src/Readers/CliArgs.js~CliArgs",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Readers/CliArgs.js~CliArgs#_setArgs",
    "access": "private",
    "description": "Sets a list of argument values used by the reader. It must follow\nthe same pattern found at `process.argv`",
    "lineNumber": 196,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "argument list"
      }
    ]
  },
  {
    "__docId__": 469,
    "kind": "member",
    "name": "[_args]",
    "memberof": "src/Readers/CliArgs.js~CliArgs",
    "static": false,
    "longname": "src/Readers/CliArgs.js~CliArgs#[_args]",
    "access": null,
    "description": null,
    "lineNumber": 200,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 470,
    "kind": "method",
    "name": "_helpElements",
    "memberof": "src/Readers/CliArgs.js~CliArgs",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/Readers/CliArgs.js~CliArgs._helpElements",
    "access": "private",
    "description": "Returns an object containing the elements that can be used by the command",
    "lineNumber": 211,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<Input>"
        ],
        "spread": false,
        "optional": false,
        "name": "inputList",
        "description": "list of input that should be used to build\nquery the help"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 471,
    "kind": "method",
    "name": "_helpInterface",
    "memberof": "src/Readers/CliArgs.js~CliArgs",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Readers/CliArgs.js~CliArgs#_helpInterface",
    "access": "private",
    "description": "Returns the help interface displayed when `-h\\--help` is required",
    "lineNumber": 267,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "elements",
        "description": "elements holder object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 472,
    "kind": "method",
    "name": "_computeInfoDisplay",
    "memberof": "src/Readers/CliArgs.js~CliArgs",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/Readers/CliArgs.js~CliArgs._computeInfoDisplay",
    "access": "private",
    "description": "Returns a string containing the full assembled info for the input",
    "lineNumber": 283,
    "params": [
      {
        "nullable": null,
        "types": [
          "Input"
        ],
        "spread": false,
        "optional": false,
        "name": "input",
        "description": "input that should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 473,
    "kind": "method",
    "name": "_elementDisplay",
    "memberof": "src/Readers/CliArgs.js~CliArgs",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Readers/CliArgs.js~CliArgs._elementDisplay",
    "access": "private",
    "description": "Returns a string containing the full element display for either an option\nor argument",
    "lineNumber": 336,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "element given name"
      },
      {
        "nullable": null,
        "types": [
          "Input"
        ],
        "spread": false,
        "optional": false,
        "name": "input",
        "description": "input that should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 474,
    "kind": "method",
    "name": "_usageDisplay",
    "memberof": "src/Readers/CliArgs.js~CliArgs",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Readers/CliArgs.js~CliArgs._usageDisplay",
    "access": "private",
    "description": "Returns a string containing the usage display for either\nthe option or argument",
    "lineNumber": 388,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "how the element should be called"
      },
      {
        "nullable": null,
        "types": [
          "Input"
        ],
        "spread": false,
        "optional": false,
        "name": "input",
        "description": "input that should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 475,
    "kind": "method",
    "name": "_shortOption",
    "memberof": "src/Readers/CliArgs.js~CliArgs",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Readers/CliArgs.js~CliArgs._shortOption",
    "access": "private",
    "description": "Returns a string containing the the short option, in case the input\ndoes not have a short option property defined then an empty string\nis returned instead",
    "lineNumber": 416,
    "params": [
      {
        "nullable": null,
        "types": [
          "Input"
        ],
        "spread": false,
        "optional": false,
        "name": "input",
        "description": "input that should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 476,
    "kind": "method",
    "name": "_shortOptionDisplay",
    "memberof": "src/Readers/CliArgs.js~CliArgs",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Readers/CliArgs.js~CliArgs._shortOptionDisplay",
    "access": "private",
    "description": "Returns a string containing the display of the short option,\nThis is used when listing the element options",
    "lineNumber": 433,
    "params": [
      {
        "nullable": null,
        "types": [
          "Input"
        ],
        "spread": false,
        "optional": false,
        "name": "input",
        "description": "input that should be used"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 477,
    "kind": "method",
    "name": "_buildDescription",
    "memberof": "src/Readers/CliArgs.js~CliArgs",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Readers/CliArgs.js~CliArgs#_buildDescription",
    "access": "private",
    "description": "Returns a string containing the description of the command",
    "lineNumber": 449,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "elements",
        "description": "elements holder object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 478,
    "kind": "method",
    "name": "_buildUsage",
    "memberof": "src/Readers/CliArgs.js~CliArgs",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Readers/CliArgs.js~CliArgs#_buildUsage",
    "access": "private",
    "description": "Builds a string containing the usage",
    "lineNumber": 470,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "elements",
        "description": "elements holder object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 479,
    "kind": "method",
    "name": "_buildUsageVectorOptions",
    "memberof": "src/Readers/CliArgs.js~CliArgs",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Readers/CliArgs.js~CliArgs#_buildUsageVectorOptions",
    "access": "private",
    "description": "Builds a string containing the usage for the vector options",
    "lineNumber": 546,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "elements",
        "description": "elements holder object"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "argumentNames",
        "description": "list of argument names"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "requiredOptionNames",
        "description": "list of required option names"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 480,
    "kind": "method",
    "name": "_buildColumns",
    "memberof": "src/Readers/CliArgs.js~CliArgs",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Readers/CliArgs.js~CliArgs._buildColumns",
    "access": "private",
    "description": "Builds a string containing the columns displayed by the arguments and options",
    "lineNumber": 589,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "elements",
        "description": "elements holder object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 481,
    "kind": "method",
    "name": "_computeElementsWidth",
    "memberof": "src/Readers/CliArgs.js~CliArgs",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Readers/CliArgs.js~CliArgs._computeElementsWidth",
    "access": "private",
    "description": "Returns a plain object containing the width for each of the element types\n(argument and option)",
    "lineNumber": 635,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "elements",
        "description": "elements holder object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 482,
    "kind": "method",
    "name": "_camelCaseToArgument",
    "memberof": "src/Readers/CliArgs.js~CliArgs",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Readers/CliArgs.js~CliArgs._camelCaseToArgument",
    "access": "private",
    "description": "Converts the input text from camelCase to dash-convention used\nin CLI applications",
    "lineNumber": 655,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "text that should be converted"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 483,
    "kind": "file",
    "name": "src/Readers/WebRequest.js",
    "content": "const os = require('os');\nconst fs = require('fs');\nconst util = require('util');\nconst path = require('path');\nconst assert = require('assert');\nconst formidable = require('formidable');\nconst TypeCheck = require('js-typecheck');\nconst Settings = require('../Settings');\nconst Handler = require('../Handler');\nconst Reader = require('../Reader');\nconst Utils = require('../Utils');\n\n// promisifying\nconst mkdtemp = util.promisify(fs.mkdtemp);\nconst rename = util.promisify(fs.rename);\nconst stat = util.promisify(fs.stat);\nconst rmdir = util.promisify(fs.rmdir);\n\n// symbols used for private instance variables to avoid any potential clashing\n// caused by re-implementations\nconst _temporaryFolders = Symbol('temporaryFolders');\nconst _request = Symbol('request');\n\n\n/**\n * Web request reader.\n *\n * This reader is used by the {@link Web} handler to query values from a request.\n *\n * This reader supports all serializable inputs. It deals with file uploads\n * automatically; therefore any {@link FilePath} input becomes a potential\n * upload field. When that is the case the input gets assigned with the file path\n * about where the file has been uploaded to. By default it tries to keep the original\n * uploaded file name by replacing any illegal character with underscore, however you can\n * control this behavior via `uploadPreserveName` (if disabled each uploaded file\n * gets named with an unique name).\n *\n * This reader works by looking for the input names in the request, for instance:\n *\n * `http://.../?myInput=10&myOtherInput=20`\n *\n * ```\n * class MyAction extends Mebo.Action {\n *   constructor(){\n *     super();\n *     this.createInput('myInput: numeric');\n *     this.createInput('myOtherInput: numeric');\n *   }\n * }\n * ```\n *\n * When a value is found for the input, it gets loaded via {@link Input.parseValue}\n * where each input implementation has its own way of parsing the serialized data,\n * to find out about how a value is serialized for an specific input type you could simply\n * set an arbitrary value to the input you are interested then query it back through\n * {@link Input.serializeValue}. Also, Mebo provides a reference datasheet\n * about the serialization forms for the inputs bundled with it, found at {@link Reader}.\n *\n * **Route parameters:**\n * If an webfied action contains route parameters defined (`/users/:userId/books/:bookId`)\n * this reader is going to try to find them under the action input names.\n * Therefore when a route parameter matches to the name of an input then the value of\n * the parameter is loaded to the input.\n *\n * **Vector Inputs:**\n * Supported conventions for array parameters:\n *\n * - *Serialized vector value (JSON Style)*\n * ```\n * http://.../?vectorInput=[\"a\", \"b\", \"c\"]\n * ```\n *\n * - *Repeated param names*\n * ```\n * http://.../?vectorInput[]=a&vectorInput[]=b&vectorInput[]=c\n * ```\n * *or*\n * ```\n * http://.../?vectorInput=a&vectorInput=b&vectorInput=c\n * ```\n *\n * <h2>Options Summary</h2>\n *\n * Option Name | Description\n * --- | ---\n * uploadDirectory | directory used for placing file uploads in, default value\\\n * (`TMP_DIR/upload`) driven by:\\\n * <br>`Settings.get('reader/webRequest/uploadDirectory')`\n * uploadPreserveName | enabled by default it tries to keep the original final name of \\\n * uploads, any illegal character is replaced by underscore, otherwise if disabled \\\n * it gives a random name to the upload, default value driven by: \\\n * <br>`Settings.get('reader/webRequest/uploadPreserveName')`\n * uploadMaxFileSize | total maximum file size about all uploads in bytes, \\\n * default value (`4 mb`) driven by: \\\n * <br>`Settings.get('reader/webRequest/uploadMaxFileSize')`\n * maxFields | Limits the number of fields that the querystring parser will decode, \\\n * default value (`1000`) driven by: \\\n * <br>`Settings.get('reader/webRequest/maxFields')`\n * maxFieldsSize | Limits the amount of memory all fields together (except files) can\\\n * allocate in bytes, default value (`2 mb`) driven by:\\\n * <br>`Settings.get('reader/webRequest/maxFieldsSize')` [`2 mb`]\n *\n * <br/>Example about defining a custom `uploadMaxFileSize` option from inside of an\n * action through the metadata support:\n *\n * ```\n * class MyAction extends Mebo.Action{\n *    constructor(){\n *      super();\n *\n *      // 'uploadMaxFileSize' option\n *      this.setMeta('handler.web.readOptions', {\n *        uploadMaxFileSize: 10 * 1024 * 1024,\n *      });\n *    }\n * }\n * ```\n */\nclass WebRequest extends Reader{\n\n  /**\n   * Creates a web request reader\n   *\n   * @param {Action} action - action that should be used by the reader\n   * @param {Object} req - request object created by express-js\n   */\n  constructor(action, req){\n    super(action);\n\n    this._setRequest(req);\n\n    // default options\n    this.setOption('uploadDirectory', Settings.get('reader/webRequest/uploadDirectory'));\n    this.setOption('uploadPreserveName', Settings.get('reader/webRequest/uploadPreserveName'));\n    this.setOption('uploadMaxFileSize', Settings.get('reader/webRequest/uploadMaxFileSize'));\n    this.setOption('maxFields', Settings.get('reader/webRequest/maxFields'));\n    this.setOption('maxFieldsSize', Settings.get('reader/webRequest/maxFieldsSize'));\n\n    this[_temporaryFolders] = [];\n  }\n\n  /**\n   * Returns the request object created by express\n   *\n   * @return {Object}\n   * @see http://expressjs.com/en/api.html#req\n   */\n  request(){\n    return this[_request];\n  }\n\n  /**\n   * Implements the web request reader\n   *\n   * @param {Array<Input>} inputList - Valid list of inputs that should be used for\n   * the parsing\n   * @return {Promise<Object>}\n   * @protected\n   */\n  async _perform(inputList){\n    const result = Object.create(null);\n    const request = this.request();\n\n    // handling body fields\n    let bodyFields = null;\n    if (['POST', 'PUT', 'PATCH'].includes(request.method)){\n      bodyFields = await this._bodyFields(inputList);\n    }\n\n    // setting the action inputs based on the request parameters\n    for (const input of inputList){\n      const inputName = input.name();\n\n      // value set by the request\n      let requestInputValue;\n      const restrictWebAccess = input.hasProperty('restrictWebAccess') ? input.property('restrictWebAccess') : false;\n\n      // mapping param to input names\n      if (!restrictWebAccess && inputName in request.params){\n        requestInputValue = request.params[inputName];\n      }\n      // body fields\n      else if (bodyFields !== null){\n        if (restrictWebAccess && inputName in bodyFields.files){\n          requestInputValue = bodyFields.files[inputName];\n        }\n        else if (!restrictWebAccess){\n\n          if (inputName in bodyFields.files){\n            requestInputValue = bodyFields.files[inputName];\n          }\n          else if (inputName in bodyFields.fields){\n            requestInputValue = bodyFields.fields[inputName];\n          }\n        }\n      }\n\n      // GET, DELETE ...\n      else if (!restrictWebAccess && inputName in request.query){\n        requestInputValue = request.query[inputName];\n      }\n\n      if (requestInputValue !== undefined){\n        result[inputName] = requestInputValue;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Sets the request object created by express\n   *\n   * @param {Object} value - req object\n   * @see http://expressjs.com/en/api.html#req\n   * @private\n   */\n  _setRequest(value){\n    assert(TypeCheck.isObject(value) && value.method, 'Invalid request object');\n\n    this[_request] = value;\n  }\n\n  /**\n   * Returns an object containing the processed body fields parsed, this object separates\n   * the fields from the files\n   *\n   * @return {Promise<Object>}\n   * @private\n   */\n  async _bodyFields(){\n\n    // making sure the upload directory exists\n    const uploadDirectory = this.option('uploadDirectory');\n    if (uploadDirectory && !WebRequest._checkedUploadDirectories.includes(uploadDirectory)){\n\n      // in case the stat fails it will try to recreate the folders\n      let needsToCreate = false;\n      try{\n        await stat(uploadDirectory);\n      }\n      // otherwise tries to create it\n      catch(err){\n\n        // file not found\n        if (err.code === 'ENOENT'){\n          needsToCreate = true;\n        }\n        else{\n          /* istanbul ignore next */\n          throw err;\n        }\n      }\n\n      if (needsToCreate){\n        await Utils.mkdirs(uploadDirectory);\n      }\n\n      WebRequest._checkedUploadDirectories.push(uploadDirectory);\n    }\n\n    // parsing the body fields\n    const bodyFields = await this._parseForm();\n\n    // normalizing multiple values for the fields\n    this._normalizeFieldMultipleValues(bodyFields);\n\n    // handling the uploaded files\n    await this._handleUploadedFiles(bodyFields);\n\n    return bodyFields;\n  }\n\n  /**\n   * Normalizing multiple values for the fields by adding the values to an array\n   * followed by the name of the field (field=[value1, value2...]) rather than\n   * having an individual field entry for each of the indexes of the array\n   * (field[0]=value1, field[1]=value2...)\n   *\n   * @param {Object} bodyFields - parsed body object\n   * @private\n   */\n  _normalizeFieldMultipleValues(bodyFields){\n\n    const multipleValueFields = Object.create(null);\n\n    for (const inputName in bodyFields.fields){\n\n      // checking if there is any array field if so extracting their name and value\n      if (inputName.endsWith(']')){\n        const inputParts = inputName.split('[');\n        if (inputParts.length === 2){\n          if (!(inputParts[0] in multipleValueFields)){\n            multipleValueFields[inputParts[0]] = [];\n          }\n\n          multipleValueFields[inputParts[0]].push(bodyFields.fields[inputName]);\n        }\n      }\n    }\n\n    // merging the normalized multiple values to the original fields\n    Object.assign(bodyFields.fields, multipleValueFields);\n  }\n\n  /**\n   * Handles the uploaded files (changes bodyFields in-place)\n   *\n   * @param {Object} bodyFields - parsed body object\n   * @private\n   */\n  async _handleUploadedFiles(bodyFields){\n    const keepOrignalNamePromises = new Map();\n\n    const preserveFileName = this.option('uploadPreserveName');\n    for (const inputName in bodyFields.files){\n      // multiple files\n      if (TypeCheck.isList(bodyFields.files[inputName])){\n\n        for (const index in bodyFields.files[inputName]){\n          if (preserveFileName){\n            keepOrignalNamePromises.set([inputName, index], this._keepOriginalUploadName(bodyFields.files[inputName][index]));\n          }\n          else{\n            bodyFields.files[inputName][index] = bodyFields.files[inputName][index].path;\n          }\n        }\n      }\n\n      // single file\n      else{\n        if (preserveFileName){\n          keepOrignalNamePromises.set([inputName], this._keepOriginalUploadName(bodyFields.files[inputName]));\n        }\n        else{\n          bodyFields.files[inputName] = bodyFields.files[inputName].path;\n        }\n      }\n    }\n\n    // 'keep original name' is done in parallel for all files at once\n    if (keepOrignalNamePromises.size){\n      const originalNameKeys = Array.from(keepOrignalNamePromises.keys());\n      const originalNameValues = await Promise.all(keepOrignalNamePromises.values());\n\n      for (let i=0, len=keepOrignalNamePromises.size; i < len; ++i){\n        // single\n        if (originalNameKeys[i].length === 1){\n          bodyFields.files[originalNameKeys[i][0]] = originalNameValues[i];\n        }\n        // multi\n        else{\n          bodyFields.files[originalNameKeys[i][0]][originalNameKeys[i][1]] = originalNameValues[i];\n        }\n      }\n    }\n\n    // adding the cleanup temporary folders to the wrapup tasks\n    if (this[_temporaryFolders].length){\n      this.action().session().wrapup().addWrappedPromise(\n        this._cleanupTemporaryFolders.bind(this),\n        {\n          priority: 1000,\n        },\n      );\n    }\n  }\n\n  /**\n   * Auxiliary method used to promisify formidable's form.parse call\n   *\n   * @return {Promise<Object>}\n   * @private\n   */\n  _parseForm(){\n    return new Promise((resolve, reject) => {\n\n      const form = new formidable.IncomingForm();\n\n      // formidable settings\n      form.uploadDir = this.option('uploadDirectory');\n      form.maxFileSize = this.option('uploadMaxFileSize');\n      form.keepExtensions = true;\n      form.multiples = true;\n      form.encoding = 'utf-8';\n      form.maxFields = this.option('maxFields');\n      form.maxFieldsSize = this.option('maxFieldsSize');\n\n      form.parse(this.request(), (err, formFields, formFiles) => {\n\n        // in case of any error\n        /* istanbul ignore next */\n        if (err){\n          err.status = err.status || 500;\n          reject(err);\n          return;\n        }\n\n        const result = Object.create(null);\n        result.files = formFiles;\n        result.fields = formFields;\n\n        resolve(result);\n      });\n    });\n  }\n\n  /**\n   * Renames the uploaded file names which receive random unique names to the original uploaded file name,\n   * this is done by creating an intermediated unique name folder for each of the upload files then\n   * renaming them back to the original name.\n   * This method is called when `uploadPreserveName` returns true\n   *\n   * @param {string} uploadFile - input file name\n   * @return {string} output file name\n   * @private\n   */\n  async _keepOriginalUploadName(uploadFile){\n    const uploadFolder = await mkdtemp(path.join(this.option('uploadDirectory'), 'file-'));\n    const finalName = path.join(uploadFolder, uploadFile.name.replace(/[^a-zA-Z0-9 _.-]/g, '_'));\n    await rename(uploadFile.path, finalName);\n\n    // temporary folders removed at the end of the request\n    this[_temporaryFolders].push(uploadFolder);\n\n    return finalName;\n  }\n\n  /**\n   * Promise based method that removes the temporary folders that are created\n   * when `uploadPreserveName` is enabled\n   *\n   * @return {Promise}\n   * @private\n   */\n  _cleanupTemporaryFolders(){\n    const result = Promise.all(\n      this[_temporaryFolders].map(x => this._deleteTemporaryFolder(x)),\n    );\n\n    // theoretically this method can be called multiple times by handler.run\n    // for the same request\n    this[_temporaryFolders] = [];\n\n    return result;\n  }\n\n  /**\n   * Deletes a temporary folder\n   *\n   * @param {string} folder - folder to be deleted\n   * @return {Promise}\n   * @private\n   */\n  _deleteTemporaryFolder(folder){\n    return rmdir(folder).then((result) => {\n      // runaway promise\n      return null;\n    }).catch(/* istanbul ignore next */ (err) => {\n      if (!(['ENOTEMPTY', 'ENOENT'].includes(err.code))){\n        throw err;\n      }\n    });\n  }\n\n  static _checkedUploadDirectories = [];\n}\n\n// default settings\nSettings.set('reader/webRequest/uploadDirectory', path.join(os.tmpdir(), 'upload'));\nSettings.set('reader/webRequest/uploadMaxFileSize', 4 * 1024 * 1024);\nSettings.set('reader/webRequest/uploadPreserveName', true);\nSettings.set('reader/webRequest/maxFields', 1000);\nSettings.set('reader/webRequest/maxFieldsSize', 2 * 1024 * 1024);\n\n// registering reader\nHandler.registerReader(WebRequest, 'web');\n\nmodule.exports = WebRequest;\n",
    "static": true,
    "longname": "src/Readers/WebRequest.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 484,
    "kind": "variable",
    "name": "__import_module__os",
    "memberof": "src/Readers/WebRequest.js",
    "static": true,
    "longname": "src/Readers/WebRequest.js~__import_module__os",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Readers/WebRequest.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 485,
    "kind": "variable",
    "name": "__import_module__fs",
    "memberof": "src/Readers/WebRequest.js",
    "static": true,
    "longname": "src/Readers/WebRequest.js~__import_module__fs",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Readers/WebRequest.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 486,
    "kind": "variable",
    "name": "__import_module__util",
    "memberof": "src/Readers/WebRequest.js",
    "static": true,
    "longname": "src/Readers/WebRequest.js~__import_module__util",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Readers/WebRequest.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 487,
    "kind": "variable",
    "name": "__import_module__path",
    "memberof": "src/Readers/WebRequest.js",
    "static": true,
    "longname": "src/Readers/WebRequest.js~__import_module__path",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Readers/WebRequest.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 488,
    "kind": "variable",
    "name": "__import_module__assert",
    "memberof": "src/Readers/WebRequest.js",
    "static": true,
    "longname": "src/Readers/WebRequest.js~__import_module__assert",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Readers/WebRequest.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 489,
    "kind": "variable",
    "name": "__import_module__formidable",
    "memberof": "src/Readers/WebRequest.js",
    "static": true,
    "longname": "src/Readers/WebRequest.js~__import_module__formidable",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Readers/WebRequest.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 490,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Readers/WebRequest.js",
    "static": true,
    "longname": "src/Readers/WebRequest.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Readers/WebRequest.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 491,
    "kind": "variable",
    "name": "__import_module__Settings",
    "memberof": "src/Readers/WebRequest.js",
    "static": true,
    "longname": "src/Readers/WebRequest.js~__import_module__Settings",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Readers/WebRequest.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 492,
    "kind": "variable",
    "name": "__import_module__Handler",
    "memberof": "src/Readers/WebRequest.js",
    "static": true,
    "longname": "src/Readers/WebRequest.js~__import_module__Handler",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Readers/WebRequest.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 493,
    "kind": "variable",
    "name": "__import_module__Reader",
    "memberof": "src/Readers/WebRequest.js",
    "static": true,
    "longname": "src/Readers/WebRequest.js~__import_module__Reader",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Readers/WebRequest.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 494,
    "kind": "variable",
    "name": "__import_module__Utils",
    "memberof": "src/Readers/WebRequest.js",
    "static": true,
    "longname": "src/Readers/WebRequest.js~__import_module__Utils",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Readers/WebRequest.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 495,
    "kind": "variable",
    "name": "mkdtemp",
    "memberof": "src/Readers/WebRequest.js",
    "static": true,
    "longname": "src/Readers/WebRequest.js~mkdtemp",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Readers/WebRequest.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 496,
    "kind": "variable",
    "name": "rename",
    "memberof": "src/Readers/WebRequest.js",
    "static": true,
    "longname": "src/Readers/WebRequest.js~rename",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Readers/WebRequest.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 497,
    "kind": "variable",
    "name": "stat",
    "memberof": "src/Readers/WebRequest.js",
    "static": true,
    "longname": "src/Readers/WebRequest.js~stat",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Readers/WebRequest.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 498,
    "kind": "variable",
    "name": "rmdir",
    "memberof": "src/Readers/WebRequest.js",
    "static": true,
    "longname": "src/Readers/WebRequest.js~rmdir",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Readers/WebRequest.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 499,
    "kind": "variable",
    "name": "_temporaryFolders",
    "memberof": "src/Readers/WebRequest.js",
    "static": true,
    "longname": "src/Readers/WebRequest.js~_temporaryFolders",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Readers/WebRequest.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 500,
    "kind": "variable",
    "name": "_request",
    "memberof": "src/Readers/WebRequest.js",
    "static": true,
    "longname": "src/Readers/WebRequest.js~_request",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Readers/WebRequest.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 501,
    "kind": "class",
    "name": "WebRequest",
    "memberof": "src/Readers/WebRequest.js",
    "static": true,
    "longname": "src/Readers/WebRequest.js~WebRequest",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Readers/WebRequest.js",
    "importStyle": "WebRequest",
    "description": "Web request reader.\n\nThis reader is used by the {@link Web} handler to query values from a request.\n\nThis reader supports all serializable inputs. It deals with file uploads\nautomatically; therefore any {@link FilePath} input becomes a potential\nupload field. When that is the case the input gets assigned with the file path\nabout where the file has been uploaded to. By default it tries to keep the original\nuploaded file name by replacing any illegal character with underscore, however you can\ncontrol this behavior via `uploadPreserveName` (if disabled each uploaded file\ngets named with an unique name).\n\nThis reader works by looking for the input names in the request, for instance:\n\n`http://.../?myInput=10&myOtherInput=20`\n\n```\nclass MyAction extends Mebo.Action {\n  constructor(){\n    super();\n    this.createInput('myInput: numeric');\n    this.createInput('myOtherInput: numeric');\n  }\n}\n```\n\nWhen a value is found for the input, it gets loaded via {@link Input.parseValue}\nwhere each input implementation has its own way of parsing the serialized data,\nto find out about how a value is serialized for an specific input type you could simply\nset an arbitrary value to the input you are interested then query it back through\n{@link Input.serializeValue}. Also, Mebo provides a reference datasheet\nabout the serialization forms for the inputs bundled with it, found at {@link Reader}.\n\n**Route parameters:**\nIf an webfied action contains route parameters defined (`/users/:userId/books/:bookId`)\nthis reader is going to try to find them under the action input names.\nTherefore when a route parameter matches to the name of an input then the value of\nthe parameter is loaded to the input.\n\n**Vector Inputs:**\nSupported conventions for array parameters:\n\n- *Serialized vector value (JSON Style)*\n```\nhttp://.../?vectorInput=[\"a\", \"b\", \"c\"]\n```\n\n- *Repeated param names*\n```\nhttp://.../?vectorInput[]=a&vectorInput[]=b&vectorInput[]=c\n```\n*or*\n```\nhttp://.../?vectorInput=a&vectorInput=b&vectorInput=c\n```\n\n<h2>Options Summary</h2>\n\nOption Name | Description\n--- | ---\nuploadDirectory | directory used for placing file uploads in, default value (`TMP_DIR/upload`) driven by: <br>`Settings.get('reader/webRequest/uploadDirectory')`\nuploadPreserveName | enabled by default it tries to keep the original final name of  uploads, any illegal character is replaced by underscore, otherwise if disabled  it gives a random name to the upload, default value driven by:  <br>`Settings.get('reader/webRequest/uploadPreserveName')`\nuploadMaxFileSize | total maximum file size about all uploads in bytes,  default value (`4 mb`) driven by:  <br>`Settings.get('reader/webRequest/uploadMaxFileSize')`\nmaxFields | Limits the number of fields that the querystring parser will decode,  default value (`1000`) driven by:  <br>`Settings.get('reader/webRequest/maxFields')`\nmaxFieldsSize | Limits the amount of memory all fields together (except files) can allocate in bytes, default value (`2 mb`) driven by: <br>`Settings.get('reader/webRequest/maxFieldsSize')` [`2 mb`]\n\n<br/>Example about defining a custom `uploadMaxFileSize` option from inside of an\naction through the metadata support:\n\n```\nclass MyAction extends Mebo.Action{\n   constructor(){\n     super();\n\n     // 'uploadMaxFileSize' option\n     this.setMeta('handler.web.readOptions', {\n       uploadMaxFileSize: 10 * 1024 * 1024,\n     });\n   }\n}\n```",
    "lineNumber": 108,
    "interface": false,
    "extends": [
      "Reader"
    ]
  },
  {
    "__docId__": 502,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Readers/WebRequest.js~WebRequest",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Readers/WebRequest.js~WebRequest#constructor",
    "access": null,
    "description": "Creates a web request reader",
    "lineNumber": 116,
    "params": [
      {
        "nullable": null,
        "types": [
          "Action"
        ],
        "spread": false,
        "optional": false,
        "name": "action",
        "description": "action that should be used by the reader"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "req",
        "description": "request object created by express-js"
      }
    ]
  },
  {
    "__docId__": 503,
    "kind": "member",
    "name": "[_temporaryFolders]",
    "memberof": "src/Readers/WebRequest.js~WebRequest",
    "static": false,
    "longname": "src/Readers/WebRequest.js~WebRequest#[_temporaryFolders]",
    "access": null,
    "description": null,
    "lineNumber": 128,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 504,
    "kind": "method",
    "name": "request",
    "memberof": "src/Readers/WebRequest.js~WebRequest",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Readers/WebRequest.js~WebRequest#request",
    "access": null,
    "description": "Returns the request object created by express",
    "see": [
      "http://expressjs.com/en/api.html#req"
    ],
    "lineNumber": 137,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 505,
    "kind": "method",
    "name": "_perform",
    "memberof": "src/Readers/WebRequest.js~WebRequest",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Readers/WebRequest.js~WebRequest#_perform",
    "access": "protected",
    "description": "Implements the web request reader",
    "lineNumber": 149,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<Input>"
        ],
        "spread": false,
        "optional": false,
        "name": "inputList",
        "description": "Valid list of inputs that should be used for\nthe parsing"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Object>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 506,
    "kind": "method",
    "name": "_setRequest",
    "memberof": "src/Readers/WebRequest.js~WebRequest",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Readers/WebRequest.js~WebRequest#_setRequest",
    "access": "private",
    "description": "Sets the request object created by express",
    "see": [
      "http://expressjs.com/en/api.html#req"
    ],
    "lineNumber": 207,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "req object"
      }
    ]
  },
  {
    "__docId__": 507,
    "kind": "member",
    "name": "[_request]",
    "memberof": "src/Readers/WebRequest.js~WebRequest",
    "static": false,
    "longname": "src/Readers/WebRequest.js~WebRequest#[_request]",
    "access": null,
    "description": null,
    "lineNumber": 210,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 508,
    "kind": "method",
    "name": "_bodyFields",
    "memberof": "src/Readers/WebRequest.js~WebRequest",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Readers/WebRequest.js~WebRequest#_bodyFields",
    "access": "private",
    "description": "Returns an object containing the processed body fields parsed, this object separates\nthe fields from the files",
    "lineNumber": 220,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Object>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 509,
    "kind": "method",
    "name": "_normalizeFieldMultipleValues",
    "memberof": "src/Readers/WebRequest.js~WebRequest",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Readers/WebRequest.js~WebRequest#_normalizeFieldMultipleValues",
    "access": "private",
    "description": "Normalizing multiple values for the fields by adding the values to an array\nfollowed by the name of the field (field=[value1, value2...]) rather than\nhaving an individual field entry for each of the indexes of the array\n(field[0]=value1, field[1]=value2...)",
    "lineNumber": 272,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "bodyFields",
        "description": "parsed body object"
      }
    ]
  },
  {
    "__docId__": 510,
    "kind": "method",
    "name": "_handleUploadedFiles",
    "memberof": "src/Readers/WebRequest.js~WebRequest",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Readers/WebRequest.js~WebRequest#_handleUploadedFiles",
    "access": "private",
    "description": "Handles the uploaded files (changes bodyFields in-place)",
    "lineNumber": 301,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "bodyFields",
        "description": "parsed body object"
      }
    ]
  },
  {
    "__docId__": 511,
    "kind": "method",
    "name": "_parseForm",
    "memberof": "src/Readers/WebRequest.js~WebRequest",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Readers/WebRequest.js~WebRequest#_parseForm",
    "access": "private",
    "description": "Auxiliary method used to promisify formidable's form.parse call",
    "lineNumber": 364,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Object>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 512,
    "kind": "method",
    "name": "_keepOriginalUploadName",
    "memberof": "src/Readers/WebRequest.js~WebRequest",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Readers/WebRequest.js~WebRequest#_keepOriginalUploadName",
    "access": "private",
    "description": "Renames the uploaded file names which receive random unique names to the original uploaded file name,\nthis is done by creating an intermediated unique name folder for each of the upload files then\nrenaming them back to the original name.\nThis method is called when `uploadPreserveName` returns true",
    "lineNumber": 407,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "uploadFile",
        "description": "input file name"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "output file name"
    }
  },
  {
    "__docId__": 513,
    "kind": "method",
    "name": "_cleanupTemporaryFolders",
    "memberof": "src/Readers/WebRequest.js~WebRequest",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Readers/WebRequest.js~WebRequest#_cleanupTemporaryFolders",
    "access": "private",
    "description": "Promise based method that removes the temporary folders that are created\nwhen `uploadPreserveName` is enabled",
    "lineNumber": 425,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 514,
    "kind": "member",
    "name": "[_temporaryFolders]",
    "memberof": "src/Readers/WebRequest.js~WebRequest",
    "static": false,
    "longname": "src/Readers/WebRequest.js~WebRequest#[_temporaryFolders]",
    "access": null,
    "description": null,
    "lineNumber": 432,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 515,
    "kind": "method",
    "name": "_deleteTemporaryFolder",
    "memberof": "src/Readers/WebRequest.js~WebRequest",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Readers/WebRequest.js~WebRequest#_deleteTemporaryFolder",
    "access": "private",
    "description": "Deletes a temporary folder",
    "lineNumber": 444,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "folder",
        "description": "folder to be deleted"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 516,
    "kind": "member",
    "name": "_checkedUploadDirectories",
    "memberof": "src/Readers/WebRequest.js~WebRequest",
    "static": true,
    "longname": "src/Readers/WebRequest.js~WebRequest._checkedUploadDirectories",
    "access": null,
    "description": null,
    "lineNumber": 455,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 517,
    "kind": "file",
    "name": "src/Readers/index.js",
    "content": "module.exports.CliArgs = require('./CliArgs');\nmodule.exports.WebRequest = require('./WebRequest');\n",
    "static": true,
    "longname": "src/Readers/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 518,
    "kind": "file",
    "name": "src/Session.js",
    "content": "const assert = require('assert');\nconst TypeCheck = require('js-typecheck');\nconst Tasks = require('./Tasks');\n\n// symbols used for private instance variables to avoid any potential clashing\n// caused by re-implementations\nconst _arbitraryData = Symbol('arbitraryData');\nconst _autofill = Symbol('autofill');\nconst _wrapup = Symbol('wrapup');\nconst _terminated = Symbol('terminated');\n\n\n/**\n * A session is used to store the data shared between actions.\n *\n * This object is created automatically by {@link Handler.create} and\n * {@link Action.create}.\n */\nclass Session{\n\n  /**\n   * Creates a session\n   *\n   * @param {Tasks} [wrapup] - task object used to hold actions and promises that are triggered\n   * when finalizing ({@link finalize}) the session\n   */\n  constructor(wrapup=null){\n\n    assert(wrapup === null || wrapup instanceof Tasks, 'wrapup needs to defined with a Tasks object or null');\n\n    this[_wrapup] = wrapup || new Tasks();\n    this[_terminated] = false;\n\n    // container used to store autofill values inside of the session\n    this[_autofill] = {};\n\n    // generic container used to store arbitrary inside of the session\n    this[_arbitraryData] = {};\n  }\n\n  /**\n   * Returns the tasks object used to hold actions and promises that are triggered\n   * when finalizing ({@link finalize}) the session. Wrapup actions can be used to avoid\n   * the execution of an action that may be triggered multiple times across\n   * nested actions where ideally it should be executed only once in the end,\n   * after all nested actions are done.\n   *\n   * @return {Tasks}\n   */\n  wrapup(){\n    return this[_wrapup];\n  }\n\n  /**\n   * Returns a value under the autofill data.\n   *\n   * This feature is used to set the initial input value for inputs that contain the `autofill`\n   * property. It works by looking if the value of the autofill input's property is under the\n   * {@link Session.autofill} then if found it sets the input value with the value of the\n   * {@link Session.autofill}. This process occurs when a session is assigned to the action\n   * ({@link Action.setSession}).\n   *\n   * When inputs that contain the property `autofill` are initialized through the\n   * {@link Handler} they will try to find their values under the autofill,\n   * however if a value is not defined for them they will assign their input value\n   * to the autofill data automatically.\n   *\n   * @param {string} key - key name used to query the autofill value\n   * @param {*} [defaultValue] - optional default value returned in case\n   * the key does not exist\n   * @return {*}\n   */\n  autofill(key, defaultValue=undefined){\n    assert(TypeCheck.isString(key), 'key needs to defined as string');\n\n    if (key in this[_autofill]){\n      return this[_autofill][key];\n    }\n\n    return defaultValue;\n  }\n\n  /**\n   * Returns a boolean telling if the key exists under the autofill data.\n   *\n   * @param {string} key - key name\n   * @return {boolean}\n   */\n  hasAutofill(key){\n    return (key in this[_autofill]);\n  }\n\n  /**\n   * Sets a key & value under the autofill data\n   *\n   * @param {string} key - key name\n   * @param {*} value - value associated with the key\n   *\n   * @see {@link Session.autofill}\n   */\n  setAutofill(key, value){\n    assert(TypeCheck.isString(key), 'key needs to defined as string');\n\n    this[_autofill][key] = value;\n  }\n\n  /**\n   * Returns the keys included in the autofill data\n   *\n   * @return {Array<string>}\n   */\n  autofillKeys(){\n    return Object.keys(this[_autofill]);\n  }\n\n  /**\n   * Sets a key & value under the arbitrary data. This is used to store data\n   * that may be only available in specific handlers, for instance the\n   * request object created by express is assigned to the session through this\n   * method by the web handler.\n   *\n   * @param {string} key - name of the key\n   * @param {*} value - value for the key\n   */\n  set(key, value){\n    assert(TypeCheck.isString(key), 'key needs to defined as string');\n\n    this[_arbitraryData][key] = value;\n  }\n\n  /**\n   * Returns an value assigned for the key inside of the arbitrary data\n   *\n   * @param {string} key - name of the key\n   * @param {*} [defaultValue] - optional value returned when the key is not assigned\n   * @return {*}\n   */\n  get(key, defaultValue=undefined){\n    if (key in this[_arbitraryData]){\n      return this[_arbitraryData][key];\n    }\n\n    return defaultValue;\n  }\n\n  /**\n   * Returns a boolean telling if the input key is under the arbitrary data\n   *\n   * @param {string} key - key name\n   * @return {boolean}\n   */\n  has(key){\n    return (key in this[_arbitraryData]);\n  }\n\n  /**\n   * Returns the keys included in the arbitrary data\n   *\n   * @return {Array<string>}\n   */\n  keys(){\n    return Object.keys(this[_arbitraryData]);\n  }\n\n  /**\n   * Terminates the session by executing the {@link wrapup}\n   * tasks.\n   *\n   * This is called by the {@link Handler} during the execution of\n   * {@link Handler.output}.\n   *\n   * @return {Promise}\n   */\n  async finalize(){\n\n    const wrapup = this.wrapup();\n    if (!wrapup.isEmpty()){\n\n      await wrapup.run();\n      wrapup.clear();\n    }\n\n    return true;\n  }\n\n  /**\n   * Returns a cloned version of the current session where all autofill\n   * and arbitrary data are transferred to the cloned version.\n   *\n   * This feature is used by the actions during the session assignment\n   * ({@link Action.setSession}) to prevent that modifications done in the session\n   * of nested actions reflect back in the session used by the parent actions.\n   * Therefore, acting as scope for changes in the autofill & arbitrary data.\n   *\n   * The current wrapup is also assigned to the cloned version.\n   *\n   * @return {Session}\n   */\n  clone(){\n    const result = new Session(this.wrapup());\n\n    // transferring autofill data\n    for (const autofillKey in this[_autofill]){\n      result.setAutofill(autofillKey, this[_autofill][autofillKey]);\n    }\n\n    // transferring arbitrary data\n    for (const arbitraryKey in this[_arbitraryData]){\n      result.set(arbitraryKey, this[_arbitraryData][arbitraryKey]);\n    }\n\n    return result;\n  }\n}\n\nmodule.exports = Session;\n",
    "static": true,
    "longname": "src/Session.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 519,
    "kind": "variable",
    "name": "__import_module__assert",
    "memberof": "src/Session.js",
    "static": true,
    "longname": "src/Session.js~__import_module__assert",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Session.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 520,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Session.js",
    "static": true,
    "longname": "src/Session.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Session.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 521,
    "kind": "variable",
    "name": "__import_module__Tasks",
    "memberof": "src/Session.js",
    "static": true,
    "longname": "src/Session.js~__import_module__Tasks",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Session.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 522,
    "kind": "variable",
    "name": "_arbitraryData",
    "memberof": "src/Session.js",
    "static": true,
    "longname": "src/Session.js~_arbitraryData",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Session.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 523,
    "kind": "variable",
    "name": "_autofill",
    "memberof": "src/Session.js",
    "static": true,
    "longname": "src/Session.js~_autofill",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Session.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 524,
    "kind": "variable",
    "name": "_wrapup",
    "memberof": "src/Session.js",
    "static": true,
    "longname": "src/Session.js~_wrapup",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Session.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 525,
    "kind": "variable",
    "name": "_terminated",
    "memberof": "src/Session.js",
    "static": true,
    "longname": "src/Session.js~_terminated",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Session.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 526,
    "kind": "class",
    "name": "Session",
    "memberof": "src/Session.js",
    "static": true,
    "longname": "src/Session.js~Session",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Session.js",
    "importStyle": "Session",
    "description": "A session is used to store the data shared between actions.\n\nThis object is created automatically by {@link Handler.create} and\n{@link Action.create}.",
    "lineNumber": 19,
    "interface": false
  },
  {
    "__docId__": 527,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Session.js~Session",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Session.js~Session#constructor",
    "access": null,
    "description": "Creates a session",
    "lineNumber": 27,
    "params": [
      {
        "nullable": null,
        "types": [
          "Tasks"
        ],
        "spread": false,
        "optional": true,
        "name": "wrapup",
        "description": "task object used to hold actions and promises that are triggered\nwhen finalizing ({@link finalize}) the session"
      }
    ]
  },
  {
    "__docId__": 528,
    "kind": "member",
    "name": "[_wrapup]",
    "memberof": "src/Session.js~Session",
    "static": false,
    "longname": "src/Session.js~Session#[_wrapup]",
    "access": null,
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 529,
    "kind": "member",
    "name": "[_terminated]",
    "memberof": "src/Session.js~Session",
    "static": false,
    "longname": "src/Session.js~Session#[_terminated]",
    "access": null,
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 530,
    "kind": "member",
    "name": "[_autofill]",
    "memberof": "src/Session.js~Session",
    "static": false,
    "longname": "src/Session.js~Session#[_autofill]",
    "access": null,
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 531,
    "kind": "member",
    "name": "[_arbitraryData]",
    "memberof": "src/Session.js~Session",
    "static": false,
    "longname": "src/Session.js~Session#[_arbitraryData]",
    "access": null,
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 532,
    "kind": "method",
    "name": "wrapup",
    "memberof": "src/Session.js~Session",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Session.js~Session#wrapup",
    "access": null,
    "description": "Returns the tasks object used to hold actions and promises that are triggered\nwhen finalizing ({@link finalize}) the session. Wrapup actions can be used to avoid\nthe execution of an action that may be triggered multiple times across\nnested actions where ideally it should be executed only once in the end,\nafter all nested actions are done.",
    "lineNumber": 50,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Tasks"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 533,
    "kind": "method",
    "name": "autofill",
    "memberof": "src/Session.js~Session",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Session.js~Session#autofill",
    "access": null,
    "description": "Returns a value under the autofill data.\n\nThis feature is used to set the initial input value for inputs that contain the `autofill`\nproperty. It works by looking if the value of the autofill input's property is under the\n{@link Session.autofill} then if found it sets the input value with the value of the\n{@link Session.autofill}. This process occurs when a session is assigned to the action\n({@link Action.setSession}).\n\nWhen inputs that contain the property `autofill` are initialized through the\n{@link Handler} they will try to find their values under the autofill,\nhowever if a value is not defined for them they will assign their input value\nto the autofill data automatically.",
    "lineNumber": 73,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "key name used to query the autofill value"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "defaultValue",
        "description": "optional default value returned in case\nthe key does not exist"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 534,
    "kind": "method",
    "name": "hasAutofill",
    "memberof": "src/Session.js~Session",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Session.js~Session#hasAutofill",
    "access": null,
    "description": "Returns a boolean telling if the key exists under the autofill data.",
    "lineNumber": 89,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "key name"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 535,
    "kind": "method",
    "name": "setAutofill",
    "memberof": "src/Session.js~Session",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Session.js~Session#setAutofill",
    "access": null,
    "description": "Sets a key & value under the autofill data",
    "see": [
      "{@link Session.autofill}"
    ],
    "lineNumber": 101,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "key name"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value associated with the key"
      }
    ]
  },
  {
    "__docId__": 536,
    "kind": "method",
    "name": "autofillKeys",
    "memberof": "src/Session.js~Session",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Session.js~Session#autofillKeys",
    "access": null,
    "description": "Returns the keys included in the autofill data",
    "lineNumber": 112,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 537,
    "kind": "method",
    "name": "set",
    "memberof": "src/Session.js~Session",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Session.js~Session#set",
    "access": null,
    "description": "Sets a key & value under the arbitrary data. This is used to store data\nthat may be only available in specific handlers, for instance the\nrequest object created by express is assigned to the session through this\nmethod by the web handler.",
    "lineNumber": 125,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "name of the key"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value for the key"
      }
    ]
  },
  {
    "__docId__": 538,
    "kind": "method",
    "name": "get",
    "memberof": "src/Session.js~Session",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Session.js~Session#get",
    "access": null,
    "description": "Returns an value assigned for the key inside of the arbitrary data",
    "lineNumber": 138,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "name of the key"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "defaultValue",
        "description": "optional value returned when the key is not assigned"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 539,
    "kind": "method",
    "name": "has",
    "memberof": "src/Session.js~Session",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Session.js~Session#has",
    "access": null,
    "description": "Returns a boolean telling if the input key is under the arbitrary data",
    "lineNumber": 152,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "key name"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 540,
    "kind": "method",
    "name": "keys",
    "memberof": "src/Session.js~Session",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Session.js~Session#keys",
    "access": null,
    "description": "Returns the keys included in the arbitrary data",
    "lineNumber": 161,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 541,
    "kind": "method",
    "name": "finalize",
    "memberof": "src/Session.js~Session",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Session.js~Session#finalize",
    "access": null,
    "description": "Terminates the session by executing the {@link wrapup}\ntasks.\n\nThis is called by the {@link Handler} during the execution of\n{@link Handler.output}.",
    "lineNumber": 174,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 542,
    "kind": "method",
    "name": "clone",
    "memberof": "src/Session.js~Session",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Session.js~Session#clone",
    "access": null,
    "description": "Returns a cloned version of the current session where all autofill\nand arbitrary data are transferred to the cloned version.\n\nThis feature is used by the actions during the session assignment\n({@link Action.setSession}) to prevent that modifications done in the session\nof nested actions reflect back in the session used by the parent actions.\nTherefore, acting as scope for changes in the autofill & arbitrary data.\n\nThe current wrapup is also assigned to the cloned version.",
    "lineNumber": 199,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Session"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 543,
    "kind": "file",
    "name": "src/Settings.js",
    "content": "const assert = require('assert');\nconst debug = require('debug')('Mebo');\nconst TypeCheck = require('js-typecheck');\nconst path = require('path');\n\n\n/**\n * Provides access to the general configuration used across Mebo.\n *\n * ```javascript\n * const Mebo = require('mebo');\n *\n * // listing the available settings\n * console.log(Mebo.Settings.keys());\n * ```\n */\nclass Settings{\n\n  /**\n   * Sets a value based on key & value under the settings\n   *\n   * @param {string} key - name of the key\n   * @param {*} value - value for the key\n   */\n  static set(key, value){\n    assert(TypeCheck.isString(key), 'key needs to be defined as string');\n\n    this._data[key] = value;\n  }\n\n  /**\n   * Returns the value assigned for the key\n   *\n   * @param {string} key - name of the key\n   * @param {*} [defaultValue] - optional value returned when the key is not assigned\n   * @return {*}\n   */\n  static get(key, defaultValue=undefined){\n    if (key in this._data){\n      return this._data[key];\n    }\n\n    return defaultValue;\n  }\n\n  /**\n   * Returns a boolean telling if the input key is under the arbitrary data\n   *\n   * @param {string} key - key name\n   * @return {boolean}\n   */\n  static has(key){\n    return (key in this._data);\n  }\n\n  /**\n   * Returns the keys included under the settings\n   *\n   * @return {Array<string>}\n   */\n  static keys(){\n    return Object.keys(this._data).sort();\n  }\n\n  static _data = Object.create(null);\n}\n\n// default settings:\n// apiVersion\n// Sets the api version about the application that is using this library, this information\n// is used as part of the request response (default: version found inside of `CWD/package.json`)\n// @see http://semver.org\ntry{\n  Settings.set('apiVersion', require(path.join(process.cwd(), 'package.json')).version); // eslint-disable-line\n}\ncatch(err)/* istanbul ignore next */{\n  debug('Unable to find package.json under the CWD');\n  Settings.set('apiVersion', '');\n}\n\n// exporting the module\nmodule.exports = Settings;\n",
    "static": true,
    "longname": "src/Settings.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 544,
    "kind": "variable",
    "name": "__import_module__assert",
    "memberof": "src/Settings.js",
    "static": true,
    "longname": "src/Settings.js~__import_module__assert",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Settings.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 545,
    "kind": "variable",
    "name": "__import_module__debug",
    "memberof": "src/Settings.js",
    "static": true,
    "longname": "src/Settings.js~__import_module__debug",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Settings.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 546,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Settings.js",
    "static": true,
    "longname": "src/Settings.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Settings.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 547,
    "kind": "variable",
    "name": "__import_module__path",
    "memberof": "src/Settings.js",
    "static": true,
    "longname": "src/Settings.js~__import_module__path",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Settings.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 548,
    "kind": "class",
    "name": "Settings",
    "memberof": "src/Settings.js",
    "static": true,
    "longname": "src/Settings.js~Settings",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Settings.js",
    "importStyle": "Settings",
    "description": "Provides access to the general configuration used across Mebo.\n\n```javascript\nconst __import_module__Mebo = require('mebo');\n\n// listing the available settings\nconsole.log(Mebo.Settings.keys());\n```",
    "lineNumber": 17,
    "interface": false
  },
  {
    "__docId__": 549,
    "kind": "method",
    "name": "set",
    "memberof": "src/Settings.js~Settings",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Settings.js~Settings.set",
    "access": null,
    "description": "Sets a value based on key & value under the settings",
    "lineNumber": 25,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "name of the key"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value for the key"
      }
    ]
  },
  {
    "__docId__": 550,
    "kind": "method",
    "name": "get",
    "memberof": "src/Settings.js~Settings",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Settings.js~Settings.get",
    "access": null,
    "description": "Returns the value assigned for the key",
    "lineNumber": 38,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "name of the key"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "defaultValue",
        "description": "optional value returned when the key is not assigned"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 551,
    "kind": "method",
    "name": "has",
    "memberof": "src/Settings.js~Settings",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Settings.js~Settings.has",
    "access": null,
    "description": "Returns a boolean telling if the input key is under the arbitrary data",
    "lineNumber": 52,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "key name"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 552,
    "kind": "method",
    "name": "keys",
    "memberof": "src/Settings.js~Settings",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Settings.js~Settings.keys",
    "access": null,
    "description": "Returns the keys included under the settings",
    "lineNumber": 61,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 553,
    "kind": "member",
    "name": "_data",
    "memberof": "src/Settings.js~Settings",
    "static": true,
    "longname": "src/Settings.js~Settings._data",
    "access": null,
    "description": null,
    "lineNumber": 65,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 554,
    "kind": "file",
    "name": "src/Tasks.js",
    "content": "const assert = require('assert');\nconst TypeCheck = require('js-typecheck');\n\n// symbols used for private instance variables to avoid any potential clashing\n// caused by re-implementations\nconst _contents = Symbol('contents');\nconst _executedCount = Symbol('executedIndex');\n\n\n/**\n * Object that holds actions and promises, which are executed at specific events.\n *\n * Inside Mebo tasks are used by the {@link Session.wrapup} to hold actions and\n * promises that are triggered when a {@link Session} is about to be terminated\n * ({@link Session.finalize}).\n */\nclass Tasks{\n\n  /**\n   * Creates a new instance\n   */\n  constructor(){\n    this[_contents] = [];\n    this[_executedCount] = 0;\n  }\n\n  /**\n   * Adds an action to the tasks\n   *\n   * `runOnlyOnce` can be used to avoid the execution of an action that may be triggered\n   * multiple times across nested actions where ideally it should be executed only once,\n   * it's done by using the action's id ({@link Action.id}).\n   *\n   * @param {Action} action - action instance that should be executed in the wrap up\n   * @param {Object} options - custom options\n   * @param {boolean} [options.runOnlyOnce=true] - tells if the action should be ignore in case\n   * it has already been executed previously (it's done by matching the {@link Action.id})\n   * @param {number} [options.priority=100] - tells the priority of the action, this affects\n   * the execution order where a lower numeric value means a higher priority.\n   */\n  addAction(action, {runOnlyOnce=true, priority=100}={}){\n    assert(TypeCheck.isCallable(action.run), 'Invalid Action');\n\n    this[_contents].push({\n      type: 'action',\n      item: action,\n      onlyOnce: runOnlyOnce,\n      execPriority: priority,\n    });\n  }\n\n  /**\n   * Adds a wrapped promise to the tasks\n   *\n   * @param {function} wrappedPromise - function that should return a promise, ex:\n   * ```javascript\n   * tasks.addWrappedPromise(() => Promise.resolve(3))\n   * ```\n   * @param {Object} options - custom options\n   * @param {number} [options.priority=100] - tells the priority of the action, this affects\n   * the execution order where a lower numeric value means a higher priority.\n   */\n  addWrappedPromise(wrappedPromise, {priority=100}={}){\n    assert(TypeCheck.isCallable(wrappedPromise), 'Promise needs to wrapped into a function');\n\n    this[_contents].push({\n      type: 'promise',\n      item: wrappedPromise,\n      execPriority: priority,\n    });\n  }\n\n  /**\n   * Returns a list sorted by priority and inclusion order about the actions and\n   * promises that are executed through {@link execute}\n   *\n   * @param {boolean} [actions=true] - tells if the result should return the actions\n   * @param {boolean} [promises=true] - tells if the result should return the promises\n   * @return {Promise<Array>}\n   */\n  async contents(actions=true, promises=true){\n    const result = [];\n\n    const taskOrder = this[_contents].map((data, index) => {\n      return {\n        i: index,\n        contents: data,\n      };\n    });\n\n    taskOrder.sort((a, b) => {\n      if (a.contents.execPriority < b.contents.execPriority) return -1;\n      if (a.contents.execPriority > b.contents.execPriority) return 1;\n      return a.i - b.i;\n    });\n\n    const finalTaskOrder = taskOrder.map(x => x.contents);\n\n    let resultIndex = 0;\n    const actionIdMap = new Map();\n    for (const task of finalTaskOrder){\n      // actions\n      if (actions && task.type === 'action'){\n        actionIdMap.set(resultIndex, task.item.id());\n        result.push(task.item);\n      }\n\n      // promises\n      else if (promises && task.type === 'promise'){\n        result.push(task.item);\n      }\n\n      resultIndex++;\n    }\n\n    // the process bellow executes the ids in parallel and removes the duplicated\n    // action id for any action marked as run onlyOnce from the final result\n    const actionIndexes = Array.from(actionIdMap.keys());\n    const actionIdResults = await Promise.all(actionIdMap.values());\n    const alreadyAddedIds = [];\n\n    let keyIndex = 0;\n    let removedCount = 0;\n    for (const actionIndex of actionIndexes){\n\n      const actionId = actionIdResults[keyIndex];\n      const alreadyIncluded = alreadyAddedIds.includes(actionId);\n\n      if (alreadyIncluded && this[_contents][actionIndex].onlyOnce){\n        result.splice(actionIndex - removedCount, 1);\n\n        removedCount++;\n      }\n      else if (!alreadyIncluded){\n        alreadyAddedIds.push(actionId);\n      }\n\n      keyIndex++;\n    }\n\n    return result;\n  }\n\n  /**\n   * Tells if there are no tasks\n   *\n   * @return {boolean}\n   */\n  isEmpty(){\n    return this[_contents].length === 0;\n  }\n\n  /**\n   * Resets the tasks by cleaning all actions and promises\n   *\n   */\n  clear(){\n    this[_contents].length = 0;\n    this[_executedCount] = 0;\n  }\n\n  /**\n   * Executes the actions and promises inside of the tasks\n   * (provided by {@link contents}). All tasks get executed even if an error occurs\n   * during the execution of an specific task. In case this method is triggered\n   * multiple times it ensures each task is only executed once.\n   *\n   * Failed tasks are reported through an exception raised after all tasks have been executed,\n   * this error provides the `taskErrors` member that contains a list about the errors raised\n   * during the execution of the tasks.\n   *\n   * @return {Promise<Array>} Returns an array containing each result of the tasks\n   */\n  async run(){\n\n    const contents = await this.contents();\n    const taskErrors = [];\n    const result = [];\n\n    let currentIndex = 0;\n    for (const task of contents){\n\n      // skipping tasks that have been executed previously\n      currentIndex++;\n      if (this[_executedCount] >= currentIndex){\n        continue;\n      }\n      else{\n        this[_executedCount]++;\n      }\n\n      // executing task\n      try{\n        result.push(\n          await ((TypeCheck.isCallable(task)) ? task() : task.run()), // eslint-disable-line no-await-in-loop\n        );\n      }\n      catch(err){\n        taskErrors.push(err);\n      }\n\n    }\n\n    // throwing a new exception about the failed tasks\n    if (taskErrors.length){\n      const error = new Error(`Failed to execute ${taskErrors.length} tasks (out of ${contents.length})`);\n\n      // including the stack trace information from the failed tasks (debugging purposes)\n      for (const taskError of taskErrors){\n        error.stack += `\\n\\nTask stack trace:\\n${taskError.stack}`;\n      }\n\n      // also, including the task errors to the error itself (debugging purposes)\n      error.taskErrors = taskErrors;\n\n      throw error;\n    }\n\n    return result;\n  }\n}\n\nmodule.exports = Tasks;\n",
    "static": true,
    "longname": "src/Tasks.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 555,
    "kind": "variable",
    "name": "__import_module__assert",
    "memberof": "src/Tasks.js",
    "static": true,
    "longname": "src/Tasks.js~__import_module__assert",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Tasks.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 556,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Tasks.js",
    "static": true,
    "longname": "src/Tasks.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Tasks.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 557,
    "kind": "variable",
    "name": "_contents",
    "memberof": "src/Tasks.js",
    "static": true,
    "longname": "src/Tasks.js~_contents",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Tasks.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 558,
    "kind": "variable",
    "name": "_executedCount",
    "memberof": "src/Tasks.js",
    "static": true,
    "longname": "src/Tasks.js~_executedCount",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Tasks.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 559,
    "kind": "class",
    "name": "Tasks",
    "memberof": "src/Tasks.js",
    "static": true,
    "longname": "src/Tasks.js~Tasks",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Tasks.js",
    "importStyle": "Tasks",
    "description": "Object that holds actions and promises, which are executed at specific events.\n\nInside Mebo tasks are used by the {@link Session.wrapup} to hold actions and\npromises that are triggered when a {@link Session} is about to be terminated\n({@link Session.finalize}).",
    "lineNumber": 17,
    "interface": false
  },
  {
    "__docId__": 560,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Tasks.js~Tasks",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Tasks.js~Tasks#constructor",
    "access": null,
    "description": "Creates a new instance",
    "lineNumber": 22,
    "params": []
  },
  {
    "__docId__": 561,
    "kind": "member",
    "name": "[_contents]",
    "memberof": "src/Tasks.js~Tasks",
    "static": false,
    "longname": "src/Tasks.js~Tasks#[_contents]",
    "access": null,
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 562,
    "kind": "member",
    "name": "[_executedCount]",
    "memberof": "src/Tasks.js~Tasks",
    "static": false,
    "longname": "src/Tasks.js~Tasks#[_executedCount]",
    "access": null,
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 563,
    "kind": "method",
    "name": "addAction",
    "memberof": "src/Tasks.js~Tasks",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Tasks.js~Tasks#addAction",
    "access": null,
    "description": "Adds an action to the tasks\n\n`runOnlyOnce` can be used to avoid the execution of an action that may be triggered\nmultiple times across nested actions where ideally it should be executed only once,\nit's done by using the action's id ({@link Action.id}).",
    "lineNumber": 41,
    "params": [
      {
        "nullable": null,
        "types": [
          "Action"
        ],
        "spread": false,
        "optional": false,
        "name": "action",
        "description": "action instance that should be executed in the wrap up"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "custom options"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.runOnlyOnce",
        "description": "tells if the action should be ignore in case\nit has already been executed previously (it's done by matching the {@link Action.id})"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "100",
        "defaultRaw": 100,
        "name": "options.priority",
        "description": "tells the priority of the action, this affects\nthe execution order where a lower numeric value means a higher priority."
      }
    ]
  },
  {
    "__docId__": 564,
    "kind": "method",
    "name": "addWrappedPromise",
    "memberof": "src/Tasks.js~Tasks",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Tasks.js~Tasks#addWrappedPromise",
    "access": null,
    "description": "Adds a wrapped promise to the tasks",
    "lineNumber": 63,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "wrappedPromise",
        "description": "function that should return a promise, ex:\n```javascript\ntasks.addWrappedPromise(() => Promise.resolve(3))\n```"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "custom options"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "100",
        "defaultRaw": 100,
        "name": "options.priority",
        "description": "tells the priority of the action, this affects\nthe execution order where a lower numeric value means a higher priority."
      }
    ]
  },
  {
    "__docId__": 565,
    "kind": "method",
    "name": "contents",
    "memberof": "src/Tasks.js~Tasks",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Tasks.js~Tasks#contents",
    "access": null,
    "description": "Returns a list sorted by priority and inclusion order about the actions and\npromises that are executed through {@link execute}",
    "lineNumber": 81,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "actions",
        "description": "tells if the result should return the actions"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "promises",
        "description": "tells if the result should return the promises"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Array>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 566,
    "kind": "method",
    "name": "isEmpty",
    "memberof": "src/Tasks.js~Tasks",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Tasks.js~Tasks#isEmpty",
    "access": null,
    "description": "Tells if there are no tasks",
    "lineNumber": 149,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 567,
    "kind": "method",
    "name": "clear",
    "memberof": "src/Tasks.js~Tasks",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Tasks.js~Tasks#clear",
    "access": null,
    "description": "Resets the tasks by cleaning all actions and promises",
    "lineNumber": 157,
    "params": []
  },
  {
    "__docId__": 568,
    "kind": "member",
    "name": "[_executedCount]",
    "memberof": "src/Tasks.js~Tasks",
    "static": false,
    "longname": "src/Tasks.js~Tasks#[_executedCount]",
    "access": null,
    "description": null,
    "lineNumber": 159,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 569,
    "kind": "method",
    "name": "run",
    "memberof": "src/Tasks.js~Tasks",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Tasks.js~Tasks#run",
    "access": null,
    "description": "Executes the actions and promises inside of the tasks\n(provided by {@link contents}). All tasks get executed even if an error occurs\nduring the execution of an specific task. In case this method is triggered\nmultiple times it ensures each task is only executed once.\n\nFailed tasks are reported through an exception raised after all tasks have been executed,\nthis error provides the `taskErrors` member that contains a list about the errors raised\nduring the execution of the tasks.",
    "lineNumber": 174,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Array>"
      ],
      "spread": false,
      "description": "Returns an array containing each result of the tasks"
    }
  },
  {
    "__docId__": 570,
    "kind": "file",
    "name": "src/Utils/HierarchicalCollection.js",
    "content": "const assert = require('assert');\nconst TypeCheck = require('js-typecheck');\nconst deepMerge = require('./deepMerge');\n\n// symbols used for private instance variables to avoid any potential clashing\n// caused by re-implementations\nconst _collection = Symbol('collection');\n\n\n/**\n * Provides an interface to deal with data in a multi dimension plain object.\n *\n * It automatically creates the intermediate levels when assigning a value under\n * nested levels to the collection. Also, if the value already exists\n * under the collection then it allows the value to be merged with the\n * existing values.\n * @private\n */\nclass HierarchicalCollection{\n\n  /**\n   * Creates a new instance\n   */\n  constructor(){\n    this[_collection] = {};\n  }\n\n  /**\n   * Inserts a new value to the collection\n   *\n   * @param {string} path - path about where the value should be stored (the levels\n   * must be separated by '.').\n   * @param {*} value - value that is going to be stored under the collection\n   * @param {boolean} [merge=true] - this option is used to decide in case of the\n   * last level is already existing under the collection, if the value should be\n   * either merged (default) or overridden.\n   */\n  insert(path, value, merge=true){\n    assert(TypeCheck.isString(path), 'path needs to be defined as string');\n    assert(path.length, 'path cannot be empty');\n    assert((/^([\\w_\\.\\-])+$/gi).test(path), `Illegal path name: ${path}`); // eslint-disable-line no-useless-escape\n\n    let currentLevel = this[_collection];\n    let finalLevel = path;\n\n    // building the intermediate levels if necessary\n    if (path.indexOf('.') !== -1){\n      const levels = path.split('.');\n      for (const level of levels.slice(0, -1)){\n        if (!(level in currentLevel)){\n          currentLevel[level] = {};\n        }\n\n        currentLevel = currentLevel[level];\n      }\n      finalLevel = levels.slice(-1)[0];\n    }\n\n    // assigning value\n    if (merge && TypeCheck.isPlainObject(value) && finalLevel in currentLevel){\n      const merged = deepMerge(currentLevel[finalLevel], value);\n      Object.assign(currentLevel[finalLevel], merged);\n    }\n    else{\n      currentLevel[finalLevel] = value;\n    }\n  }\n\n  /**\n   * Returns a value under the collection\n   *\n   * @param {string} path - path about where the value is localized (the levels\n   * must be separated by '.'). In case of empty string the entire collection\n   * is returned.\n   * @param {*} [defaultValue] - default value returned in case a value was\n   * not found for the path\n   * @return {*}\n   */\n  query(path, defaultValue=undefined){\n    assert(TypeCheck.isString(path), 'path needs to be defined as string');\n\n    let currentLevel = this[_collection];\n\n    // returning the entire collection\n    if (!path.length){\n      return currentLevel;\n    }\n\n    // no intermediate levels\n    if (path.indexOf('.') === -1){\n      if (!(path in currentLevel)){\n        return defaultValue;\n      }\n      return currentLevel[path];\n    }\n\n    // otherwise find the value going through the intermediate levels\n    const levels = path.split('.');\n    for (const level of levels){\n      if (!(level in currentLevel)){\n        return defaultValue;\n      }\n\n      currentLevel = currentLevel[level];\n    }\n\n    return currentLevel;\n  }\n\n  /**\n   * Returns a list of the root levels\n   *\n   * @return {Array<string>}\n   */\n  root(){\n    return Object.keys(this[_collection]);\n  }\n}\n\nmodule.exports = HierarchicalCollection;\n",
    "static": true,
    "longname": "src/Utils/HierarchicalCollection.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 571,
    "kind": "variable",
    "name": "__import_module__assert",
    "memberof": "src/Utils/HierarchicalCollection.js",
    "static": true,
    "longname": "src/Utils/HierarchicalCollection.js~__import_module__assert",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Utils/HierarchicalCollection.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 572,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Utils/HierarchicalCollection.js",
    "static": true,
    "longname": "src/Utils/HierarchicalCollection.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Utils/HierarchicalCollection.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 573,
    "kind": "variable",
    "name": "__import_module__deepMerge",
    "memberof": "src/Utils/HierarchicalCollection.js",
    "static": true,
    "longname": "src/Utils/HierarchicalCollection.js~__import_module__deepMerge",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Utils/HierarchicalCollection.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 574,
    "kind": "variable",
    "name": "_collection",
    "memberof": "src/Utils/HierarchicalCollection.js",
    "static": true,
    "longname": "src/Utils/HierarchicalCollection.js~_collection",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Utils/HierarchicalCollection.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 575,
    "kind": "class",
    "name": "HierarchicalCollection",
    "memberof": "src/Utils/HierarchicalCollection.js",
    "static": true,
    "longname": "src/Utils/HierarchicalCollection.js~HierarchicalCollection",
    "access": "private",
    "export": true,
    "importPath": "mebo/src/Utils/HierarchicalCollection.js",
    "importStyle": "HierarchicalCollection",
    "description": "Provides an interface to deal with data in a multi dimension plain object.\n\nIt automatically creates the intermediate levels when assigning a value under\nnested levels to the collection. Also, if the value already exists\nunder the collection then it allows the value to be merged with the\nexisting values.",
    "lineNumber": 19,
    "interface": false
  },
  {
    "__docId__": 576,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Utils/HierarchicalCollection.js~HierarchicalCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Utils/HierarchicalCollection.js~HierarchicalCollection#constructor",
    "access": null,
    "description": "Creates a new instance",
    "lineNumber": 24,
    "params": []
  },
  {
    "__docId__": 577,
    "kind": "member",
    "name": "[_collection]",
    "memberof": "src/Utils/HierarchicalCollection.js~HierarchicalCollection",
    "static": false,
    "longname": "src/Utils/HierarchicalCollection.js~HierarchicalCollection#[_collection]",
    "access": null,
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 578,
    "kind": "method",
    "name": "insert",
    "memberof": "src/Utils/HierarchicalCollection.js~HierarchicalCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Utils/HierarchicalCollection.js~HierarchicalCollection#insert",
    "access": null,
    "description": "Inserts a new value to the collection",
    "lineNumber": 38,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "path about where the value should be stored (the levels\nmust be separated by '.')."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value that is going to be stored under the collection"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "merge",
        "description": "this option is used to decide in case of the\nlast level is already existing under the collection, if the value should be\neither merged (default) or overridden."
      }
    ]
  },
  {
    "__docId__": 579,
    "kind": "method",
    "name": "query",
    "memberof": "src/Utils/HierarchicalCollection.js~HierarchicalCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Utils/HierarchicalCollection.js~HierarchicalCollection#query",
    "access": null,
    "description": "Returns a value under the collection",
    "lineNumber": 79,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "path about where the value is localized (the levels\nmust be separated by '.'). In case of empty string the entire collection\nis returned."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "defaultValue",
        "description": "default value returned in case a value was\nnot found for the path"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 580,
    "kind": "method",
    "name": "root",
    "memberof": "src/Utils/HierarchicalCollection.js~HierarchicalCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Utils/HierarchicalCollection.js~HierarchicalCollection#root",
    "access": null,
    "description": "Returns a list of the root levels",
    "lineNumber": 115,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 581,
    "kind": "file",
    "name": "src/Utils/ImmutableMap.js",
    "content": "const TypeCheck = require('js-typecheck');\n\n\n/**\n * Map implementation designed to hold immutable data.\n *\n * This object makes sure that values held by the map cannot have their data\n * modified.\n */\nclass ImmutableMap extends Map{\n\n  /**\n   * Sets a key and value to the map\n   *\n   * @param {*} key - key associated with the value\n   * @param {*} value - value that will be stored immutable\n   */\n  set(key, value){\n    super.set(key, this._deepFreeze(value));\n  }\n\n  /**\n   * Auxiliary method that recursively makes the input object immutable\n   *\n   * @param {object} value - object that should become immutable\n   * @return {object}\n   * @private\n   */\n  _deepFreeze(value){\n\n    if (TypeCheck.isNone(value) || value instanceof Buffer){\n      return value;\n    }\n\n    // freezing all properties\n    for (const propertyName of Object.getOwnPropertyNames(value)){\n      const property = value[propertyName];\n\n      // freeze prop if it is an object\n      if (TypeCheck.isObject(property)){\n        this._deepFreeze(property);\n      }\n    }\n\n    return Object.freeze(value);\n  }\n}\n\nmodule.exports = ImmutableMap;\n",
    "static": true,
    "longname": "src/Utils/ImmutableMap.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 582,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Utils/ImmutableMap.js",
    "static": true,
    "longname": "src/Utils/ImmutableMap.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Utils/ImmutableMap.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 583,
    "kind": "class",
    "name": "ImmutableMap",
    "memberof": "src/Utils/ImmutableMap.js",
    "static": true,
    "longname": "src/Utils/ImmutableMap.js~ImmutableMap",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Utils/ImmutableMap.js",
    "importStyle": "ImmutableMap",
    "description": "Map implementation designed to hold immutable data.\n\nThis object makes sure that values held by the map cannot have their data\nmodified.",
    "lineNumber": 10,
    "interface": false,
    "extends": [
      "Map"
    ]
  },
  {
    "__docId__": 584,
    "kind": "method",
    "name": "set",
    "memberof": "src/Utils/ImmutableMap.js~ImmutableMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Utils/ImmutableMap.js~ImmutableMap#set",
    "access": null,
    "description": "Sets a key and value to the map",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "key associated with the value"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value that will be stored immutable"
      }
    ]
  },
  {
    "__docId__": 585,
    "kind": "method",
    "name": "_deepFreeze",
    "memberof": "src/Utils/ImmutableMap.js~ImmutableMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Utils/ImmutableMap.js~ImmutableMap#_deepFreeze",
    "access": "private",
    "description": "Auxiliary method that recursively makes the input object immutable",
    "lineNumber": 29,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "object that should become immutable"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 586,
    "kind": "file",
    "name": "src/Utils/LruCache.js",
    "content": "const assert = require('assert');\nconst TypeCheck = require('js-typecheck');\nconst LruCacheBase = require('lru-cache');\nconst sizeof = require('object-sizeof');\n\n// symbols used for private instance variables to avoid any potential clashing\n// caused by re-implementations\nconst _size = Symbol('size');\nconst _lifespan = Symbol('lifespan');\nconst _cache = Symbol('cache');\n\n\n/**\n * A cache that discards the least recently used items first.\n *\n * This feature is used by the {@link Session} to store the result of\n * cacheable actions ({@link Action.isCacheable}).\n */\nclass LruCache{\n\n  /**\n   * Creates an LruCache\n   *\n   * @param {number} size - Sets in bytes the maximum size of the cache\n   * @param {number} lifespan - Lifespan in milliseconds about amount of time that\n   * an item under LRU cache should be kept alive\n   */\n  constructor(size, lifespan){\n\n    assert(TypeCheck.isNumber(size), 'size requires a number value');\n    assert(TypeCheck.isNumber(lifespan), 'lifespan requires a number value');\n\n    this[_size] = size;\n    this[_lifespan] = lifespan;\n\n    // lazy creation\n    this[_cache] = null;\n  }\n\n  /**\n   * Returns the size of the cache in bytes\n   *\n   * @type {number}\n   */\n  get size(){\n    return this[_size];\n  }\n\n  /**\n   * Returns the lifespan for the values held by the cache in seconds\n   *\n   * @type {number}\n   */\n  get lifespan(){\n    return this[_lifespan];\n  }\n\n  /**\n   * Resets the cache by flushing it\n   *\n   * @param {string} [key] - id associated with the value otherwise flushes the whole\n   * cache\n   */\n  flush(key=null){\n\n    if (this[_cache] === null){\n      return;\n    }\n\n    if (key){\n      this[_cache].del(key);\n    }\n    else{\n      this[_cache].reset();\n    }\n  }\n\n  /**\n   * Returns a list containing the keys of the values held by the cache\n   *\n   * @return {Array<string>}\n   */\n  keys(){\n    return (this[_cache] === null) ? [] : this[_cache].keys();\n  }\n\n  /**\n   * Returns the number of items held by the cache\n   *\n   * @type {number}\n   */\n  get length(){\n    return this.keys().length;\n  }\n\n  /**\n   * Returns a boolean telling if the input key is under the cache\n   *\n   * @param {string} key - id associated with the value\n   * @return {boolean}\n   */\n  has(key){\n    return (this[_cache] !== null && this[_cache].has(key));\n  }\n\n  /**\n   * Returns the value from the lru cache based on the input {@link Action.id},\n   * otherwise if the id is not found under the cache then returns undefined\n   *\n   * @param {string} key - id associated with the value\n   * @param {*} [defaultValue=undefined] - value returned in case the key does not exist\n   * @return {*}\n   */\n  get(key, defaultValue=undefined){\n    assert(TypeCheck.isString(key), 'Invalid action key!');\n\n    return (this.has(key)) ? this[_cache].get(key).data : defaultValue;\n  }\n\n  /**\n   * Sets a result value to the lru cache, this value is associated with the {@link Action.id}\n   *\n   * @param {string} key - id associated with the value\n   * @param {*} value - value that should be store by the cache\n   */\n  set(key, value){\n    assert(TypeCheck.isString(key), 'Invalid action key!');\n\n    if (this[_cache] === null){\n      this[_cache] = new LruCacheBase({\n        max: this[_size],\n        maxAge: this[_lifespan],\n        length: (n, k) => {\n          return n.memorySize;\n        },\n      });\n    }\n\n    const resultHolder = Object.create(null);\n    resultHolder.memorySize = sizeof(value);\n    resultHolder.data = value;\n\n    this[_cache].set(key, resultHolder);\n  }\n}\n\nmodule.exports = LruCache;\n",
    "static": true,
    "longname": "src/Utils/LruCache.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 587,
    "kind": "variable",
    "name": "__import_module__assert",
    "memberof": "src/Utils/LruCache.js",
    "static": true,
    "longname": "src/Utils/LruCache.js~__import_module__assert",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Utils/LruCache.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 588,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Utils/LruCache.js",
    "static": true,
    "longname": "src/Utils/LruCache.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Utils/LruCache.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 589,
    "kind": "variable",
    "name": "__import_module__LruCacheBase",
    "memberof": "src/Utils/LruCache.js",
    "static": true,
    "longname": "src/Utils/LruCache.js~__import_module__LruCacheBase",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Utils/LruCache.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 590,
    "kind": "variable",
    "name": "__import_module__sizeof",
    "memberof": "src/Utils/LruCache.js",
    "static": true,
    "longname": "src/Utils/LruCache.js~__import_module__sizeof",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Utils/LruCache.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 591,
    "kind": "variable",
    "name": "_size",
    "memberof": "src/Utils/LruCache.js",
    "static": true,
    "longname": "src/Utils/LruCache.js~_size",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Utils/LruCache.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 592,
    "kind": "variable",
    "name": "_lifespan",
    "memberof": "src/Utils/LruCache.js",
    "static": true,
    "longname": "src/Utils/LruCache.js~_lifespan",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Utils/LruCache.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 593,
    "kind": "variable",
    "name": "_cache",
    "memberof": "src/Utils/LruCache.js",
    "static": true,
    "longname": "src/Utils/LruCache.js~_cache",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Utils/LruCache.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 594,
    "kind": "class",
    "name": "LruCache",
    "memberof": "src/Utils/LruCache.js",
    "static": true,
    "longname": "src/Utils/LruCache.js~LruCache",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Utils/LruCache.js",
    "importStyle": "LruCache",
    "description": "A cache that discards the least recently used items first.\n\nThis feature is used by the {@link Session} to store the result of\ncacheable actions ({@link Action.isCacheable}).",
    "lineNumber": 19,
    "interface": false
  },
  {
    "__docId__": 595,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Utils/LruCache.js~LruCache",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Utils/LruCache.js~LruCache#constructor",
    "access": null,
    "description": "Creates an LruCache",
    "lineNumber": 28,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "size",
        "description": "Sets in bytes the maximum size of the cache"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "lifespan",
        "description": "Lifespan in milliseconds about amount of time that\nan item under LRU cache should be kept alive"
      }
    ]
  },
  {
    "__docId__": 596,
    "kind": "member",
    "name": "[_size]",
    "memberof": "src/Utils/LruCache.js~LruCache",
    "static": false,
    "longname": "src/Utils/LruCache.js~LruCache#[_size]",
    "access": null,
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 597,
    "kind": "member",
    "name": "[_lifespan]",
    "memberof": "src/Utils/LruCache.js~LruCache",
    "static": false,
    "longname": "src/Utils/LruCache.js~LruCache#[_lifespan]",
    "access": null,
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 598,
    "kind": "member",
    "name": "[_cache]",
    "memberof": "src/Utils/LruCache.js~LruCache",
    "static": false,
    "longname": "src/Utils/LruCache.js~LruCache#[_cache]",
    "access": null,
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 599,
    "kind": "get",
    "name": "size",
    "memberof": "src/Utils/LruCache.js~LruCache",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Utils/LruCache.js~LruCache#size",
    "access": null,
    "description": "Returns the size of the cache in bytes",
    "lineNumber": 45,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 600,
    "kind": "get",
    "name": "lifespan",
    "memberof": "src/Utils/LruCache.js~LruCache",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Utils/LruCache.js~LruCache#lifespan",
    "access": null,
    "description": "Returns the lifespan for the values held by the cache in seconds",
    "lineNumber": 54,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 601,
    "kind": "method",
    "name": "flush",
    "memberof": "src/Utils/LruCache.js~LruCache",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Utils/LruCache.js~LruCache#flush",
    "access": null,
    "description": "Resets the cache by flushing it",
    "lineNumber": 64,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "key",
        "description": "id associated with the value otherwise flushes the whole\ncache"
      }
    ]
  },
  {
    "__docId__": 602,
    "kind": "method",
    "name": "keys",
    "memberof": "src/Utils/LruCache.js~LruCache",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Utils/LruCache.js~LruCache#keys",
    "access": null,
    "description": "Returns a list containing the keys of the values held by the cache",
    "lineNumber": 83,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 603,
    "kind": "get",
    "name": "length",
    "memberof": "src/Utils/LruCache.js~LruCache",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Utils/LruCache.js~LruCache#length",
    "access": null,
    "description": "Returns the number of items held by the cache",
    "lineNumber": 92,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 604,
    "kind": "method",
    "name": "has",
    "memberof": "src/Utils/LruCache.js~LruCache",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Utils/LruCache.js~LruCache#has",
    "access": null,
    "description": "Returns a boolean telling if the input key is under the cache",
    "lineNumber": 102,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "id associated with the value"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 605,
    "kind": "method",
    "name": "get",
    "memberof": "src/Utils/LruCache.js~LruCache",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Utils/LruCache.js~LruCache#get",
    "access": null,
    "description": "Returns the value from the lru cache based on the input {@link Action.id},\notherwise if the id is not found under the cache then returns undefined",
    "lineNumber": 114,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "id associated with the value"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "undefined",
        "defaultRaw": "undefined",
        "name": "defaultValue",
        "description": "value returned in case the key does not exist"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 606,
    "kind": "method",
    "name": "set",
    "memberof": "src/Utils/LruCache.js~LruCache",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Utils/LruCache.js~LruCache#set",
    "access": null,
    "description": "Sets a result value to the lru cache, this value is associated with the {@link Action.id}",
    "lineNumber": 126,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "id associated with the value"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value that should be store by the cache"
      }
    ]
  },
  {
    "__docId__": 607,
    "kind": "member",
    "name": "[_cache]",
    "memberof": "src/Utils/LruCache.js~LruCache",
    "static": false,
    "longname": "src/Utils/LruCache.js~LruCache#[_cache]",
    "access": null,
    "description": null,
    "lineNumber": 130,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 608,
    "kind": "file",
    "name": "src/Utils/deepMerge.js",
    "content": "const assert = require('assert');\nconst TypeCheck = require('js-typecheck');\n\n\n/**\n * Merges two plain objects recursively and returns a new one\n *\n * @param {Object} objectA - plain object a\n * @param {Object} objectB - plain object b\n * @return {Object}\n * @private\n */\nfunction deepMerge(objectA, objectB){\n\n  assert(TypeCheck.isPlainObject(objectA), 'objectA needs to be a plain object');\n  assert(TypeCheck.isPlainObject(objectB), 'objectB needs to be a plain object');\n\n  const result = Object.assign({}, objectA);\n\n  for (const key in objectB){\n\n    // merging objects\n    if (TypeCheck.isPlainObject(objectB[key]) && key in objectA){\n      result[key] = deepMerge(objectA[key], objectB[key]);\n    }\n    // overriding / assigning\n    else{\n      result[key] = objectB[key];\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = deepMerge;\n",
    "static": true,
    "longname": "src/Utils/deepMerge.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 609,
    "kind": "variable",
    "name": "__import_module__assert",
    "memberof": "src/Utils/deepMerge.js",
    "static": true,
    "longname": "src/Utils/deepMerge.js~__import_module__assert",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Utils/deepMerge.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 610,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Utils/deepMerge.js",
    "static": true,
    "longname": "src/Utils/deepMerge.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Utils/deepMerge.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 611,
    "kind": "function",
    "name": "deepMerge",
    "memberof": "src/Utils/deepMerge.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/deepMerge.js~deepMerge",
    "access": "private",
    "export": true,
    "importPath": "mebo/src/Utils/deepMerge.js",
    "importStyle": "deepMerge",
    "description": "Merges two plain objects recursively and returns a new one",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "objectA",
        "description": "plain object a"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "objectB",
        "description": "plain object b"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 612,
    "kind": "file",
    "name": "src/Utils/hash.js",
    "content": "const debug = require('debug')('Mebo');\nconst assert = require('assert');\nconst crypto = require('crypto');\n\n// optional dependency (requires node-gyp)\nlet xxhash = null;\ntry{\n  xxhash = require('xxhash'); // eslint-disable-line\n}\ncatch(err){\n  /* istanbul ignore next */\n  debug('xxHash not available');\n}\n\n\n/**\n * Returns a non-cryptographic hash for the buffer. By default it tries to\n * use xxHash, however if it's not available (node-gyp) then it uses SHA256\n * as fallback.\n *\n * @param {Buffer} value - buffer value that should be used to generate the hash\n * @param {Object} options - custom options\n * @param {boolean} [options.forceFallback=false] - when enabled forces to use the\n * fallback hash\n * @param {number} [options.seed=0xA] - seed used by the xxHash\n * @return {string}\n * @private\n */\nfunction hash(value, {forceFallback=false, seed=0xA}={}){\n  assert(value instanceof Buffer, 'Invalid buffer instance');\n\n  let result;\n\n  // whenever possible lets use xxHash\n  if (!forceFallback && xxhash){\n    result = xxhash.XXHash64.hash(value, seed).toString('hex');\n  }\n  // otherwise fallback to sha256\n  else{\n    result = crypto.createHash('sha256').update(value).digest('hex');\n  }\n\n  return result;\n}\n\nmodule.exports = hash;\n",
    "static": true,
    "longname": "src/Utils/hash.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 613,
    "kind": "variable",
    "name": "__import_module__debug",
    "memberof": "src/Utils/hash.js",
    "static": true,
    "longname": "src/Utils/hash.js~__import_module__debug",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Utils/hash.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 614,
    "kind": "variable",
    "name": "__import_module__assert",
    "memberof": "src/Utils/hash.js",
    "static": true,
    "longname": "src/Utils/hash.js~__import_module__assert",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Utils/hash.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 615,
    "kind": "variable",
    "name": "__import_module__crypto",
    "memberof": "src/Utils/hash.js",
    "static": true,
    "longname": "src/Utils/hash.js~__import_module__crypto",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Utils/hash.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 616,
    "kind": "variable",
    "name": "xxhash",
    "memberof": "src/Utils/hash.js",
    "static": true,
    "longname": "src/Utils/hash.js~xxhash",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Utils/hash.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 617,
    "kind": "function",
    "name": "hash",
    "memberof": "src/Utils/hash.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/hash.js~hash",
    "access": "private",
    "export": true,
    "importPath": "mebo/src/Utils/hash.js",
    "importStyle": "hash",
    "description": "Returns a non-cryptographic hash for the buffer. By default it tries to\nuse xxHash, however if it's not available (node-gyp) then it uses SHA256\nas fallback.",
    "lineNumber": 29,
    "params": [
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "buffer value that should be used to generate the hash"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "custom options"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.forceFallback",
        "description": "when enabled forces to use the\nfallback hash"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0xA",
        "defaultRaw": "0xA",
        "name": "options.seed",
        "description": "seed used by the xxHash"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 618,
    "kind": "file",
    "name": "src/Utils/index.js",
    "content": "module.exports.ImmutableMap = require('./ImmutableMap');\nmodule.exports.LruCache = require('./LruCache');\n\n// the following modules are used internally (not exposed by\n// the docgen). Eventually they may become external dependencies\nmodule.exports.hash = require('./hash');\nmodule.exports.mkdirs = require('./mkdirs');\nmodule.exports.deepMerge = require('./deepMerge');\nmodule.exports.HierarchicalCollection = require('./HierarchicalCollection');\n",
    "static": true,
    "longname": "src/Utils/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 619,
    "kind": "file",
    "name": "src/Utils/mkdirs.js",
    "content": "const fs = require('fs');\nconst path = require('path');\nconst util = require('util');\n\n// promisifying\nconst stat = util.promisify(fs.stat);\nconst mkdir = util.promisify(fs.mkdir);\n\n\n/**\n * Creates folders recursively, in case a level already exist then the level is skipped\n *\n * @param {string} fullPath - path that should be created\n * @param {number} [mode] - optional octal value about the permission mode for the created\n * folders\n * @private\n */\nasync function mkdirs(fullPath, mode=0o777){\n  let needsToCreate = false;\n  // in case the stat fails it will try to recreate the folders\n  try{\n    await stat(fullPath);\n  }\n  // otherwise tries to create it\n  catch(err){\n\n    // not found\n    if (err.code === 'ENOENT'){\n      needsToCreate = true;\n    }\n    else{\n      throw err;\n    }\n  }\n\n  // going through all levels and creating them if necessary\n  if (needsToCreate){\n    const pathLevels = path.normalize(fullPath).split(path.sep);\n    const currentLevels = [];\n\n    for (const level of pathLevels){\n      if (level === '' && currentLevels.length === 0){\n        currentLevels.push(path.sep);\n      }\n      else if (level !== ''){\n        currentLevels.push(level);\n        const currentPath = currentLevels.join(path.sep);\n\n        let needsToCreateCurrentLevel = false;\n        try{\n          await stat(currentPath); // eslint-disable-line no-await-in-loop\n        }\n        catch(err){\n          // not found\n          if (err.code === 'ENOENT'){\n            needsToCreateCurrentLevel = true;\n          }\n          else{\n            /* istanbul ignore next */\n            throw err;\n          }\n        }\n\n        if (needsToCreateCurrentLevel){\n          await mkdir(currentPath, mode); // eslint-disable-line no-await-in-loop\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = mkdirs;\n",
    "static": true,
    "longname": "src/Utils/mkdirs.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 620,
    "kind": "variable",
    "name": "__import_module__fs",
    "memberof": "src/Utils/mkdirs.js",
    "static": true,
    "longname": "src/Utils/mkdirs.js~__import_module__fs",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Utils/mkdirs.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 621,
    "kind": "variable",
    "name": "__import_module__path",
    "memberof": "src/Utils/mkdirs.js",
    "static": true,
    "longname": "src/Utils/mkdirs.js~__import_module__path",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Utils/mkdirs.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 622,
    "kind": "variable",
    "name": "__import_module__util",
    "memberof": "src/Utils/mkdirs.js",
    "static": true,
    "longname": "src/Utils/mkdirs.js~__import_module__util",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Utils/mkdirs.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 623,
    "kind": "variable",
    "name": "stat",
    "memberof": "src/Utils/mkdirs.js",
    "static": true,
    "longname": "src/Utils/mkdirs.js~stat",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Utils/mkdirs.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 624,
    "kind": "variable",
    "name": "mkdir",
    "memberof": "src/Utils/mkdirs.js",
    "static": true,
    "longname": "src/Utils/mkdirs.js~mkdir",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Utils/mkdirs.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 625,
    "kind": "function",
    "name": "mkdirs",
    "memberof": "src/Utils/mkdirs.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/Utils/mkdirs.js~mkdirs",
    "access": "private",
    "export": true,
    "importPath": "mebo/src/Utils/mkdirs.js",
    "importStyle": "mkdirs",
    "description": "Creates folders recursively, in case a level already exist then the level is skipped",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "fullPath",
        "description": "path that should be created"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "mode",
        "description": "optional octal value about the permission mode for the created\nfolders"
      }
    ]
  },
  {
    "__docId__": 626,
    "kind": "file",
    "name": "src/Writer.js",
    "content": "const stream = require('stream');\nconst assert = require('assert');\nconst TypeCheck = require('js-typecheck');\nconst debug = require('debug')('Mebo');\nconst Utils = require('./Utils');\n\n// symbols used for private instance variables to avoid any potential clashing\n// caused by re-implementations\nconst _options = Symbol('options');\nconst _value = Symbol('value');\n\n\n/**\n * A writer is used to output a value through the {@link Handler}.\n *\n * The output is determined by the kind of value that's passed to the writer where\n * exceptions are interpreted as error output otherwise, the value is interpreted\n * as success value. Therefore, new implements are expected to implement both a success\n * ({@link Writer._successOutput}) and error ({@link Writer._errorOutput}) outputs.\n *\n * **Options:** Custom options can be assigned to writers ({@link Writer.setOption}).\n * They are passed from the handler to the writer during the output process\n * ({@link Handler.output}).\n *\n * ```\n * const myHandler = Mebo.Handler.create('someHandler');\n *\n * // setting output options during the output\n * myHandler.output(value, {\n *  someOption: 10,\n * });\n * ```\n *\n * When an action is executed through a handler it can define options for\n * readers and writers via {@link Metadata} support.\n *\n * <h2>Options Summary</h2>\n *\n * Option Name | Description | Default Value\n * --- | --- | :---:\n * convertBufferToReadableStream | Tells if a buffer value should be converted to a \\\n * readable stream | ::true::\n * result | Overrides the value returned by {@link Writer.value} to an arbitrary \\\n * value (only affects the success output) | ::none::\n */\nclass Writer{\n\n  /**\n   * Creates a writer\n   *\n   * @param {*} value - arbitrary value passed to the writer\n   */\n  constructor(value){\n\n    // note: currently reader & writer are completely separated entities that don't\n    // have a common parent class (aka HandlerOperation). The reason for\n    // that is currently they are so distinctive from each other that the only member in\n    // common is the option. In case they start to share more characteristics in common\n    // then a base class should be created.\n\n    this[_value] = value;\n    this[_options] = new Utils.HierarchicalCollection();\n\n    // default options\n    this.setOption('convertBufferToReadableStream', true);\n  }\n\n  /**\n   * Returns an option\n   *\n   * @param {string} path - path about where the option is localized (the levels\n   * must be separated by '.'). In case of an empty string it returns the\n   * entire options\n   * @param {*} [defaultValue] - default value returned in case a value was\n   * not found for the path\n   * @return {*}\n   */\n  option(path, defaultValue=undefined){\n    assert(TypeCheck.isString(path), 'path needs to be defined as string');\n    return this[_options].query(path, defaultValue);\n  }\n\n  /**\n   * Sets a value under the options\n   *\n   * @param {string} path - path about where the option should be stored under\n   * the options (the levels must be separated by '.')\n   * @param {*} value - value that is going to be stored under the collection\n   * @param {boolean} [merge=true] - this option is used to decide in case of the\n   * last level is already existing under the collection, if the value should be\n   * either merged (default) or overridden.\n   */\n  setOption(path, value, merge=true){\n    assert(TypeCheck.isString(path), 'path needs to be defined as string');\n\n    this[_options].insert(path, value, merge);\n  }\n\n  /**\n   * Returns the value that should be serialized ({@link Writer.serialize}) by the writer.\n   *\n   * @return {*}\n   */\n  value(){\n    return this[_value];\n  }\n\n  /**\n   * Serializes a writer value ({@link Writer.value}) in case the value is an\n   * exception it's serialize as {@link Writer._errorOutput} otherwise it's serialized\n   * as {@link Writer._successOutput}.\n   */\n  serialize(){\n\n    if (this.value() instanceof Error){\n      this._errorOutput();\n    }\n    else{\n      this._successOutput();\n    }\n  }\n\n  /**\n   * Translates an {@link Error} to a data structure that is later serialized by a writer\n   * implementation as output. This method gets triggered when an exception is passed\n   * as value by the {@link Handler.output}.\n   *\n   * By default the contents of the error output are driven by the `err.message`,\n   * however if an error contains `err.toJSON` property ({@link ValidationFail.toJSON})\n   * then that's used instead of the message.\n   *\n   * Also, you can avoid specific errors to be handled via output process by defining the member\n   * `output` assigned with `false` to the error (for instance ```err.output = false;```). If\n   * that is in place the error gets thrown which triggers the event {@link Handler.onErrorDuringOutput}.\n   *\n   * **Tip:** You can set the env variable `NODE_ENV=development` to get the traceback information\n   * included in the error output\n   *\n   * @return {Object}\n   * @protected\n   */\n  _errorOutput(){\n\n    const err = this.value();\n\n    // checking if the error can be handled by the writer\n    if (err.output === false){\n      throw err;\n    }\n\n    // objects with the property 'toJSON' can define a custom representation\n    // when they are serialized using json using (otherwise use the error message), reference:\n    // https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\n    const result = (TypeCheck.isCallable(err.toJSON)) ? err.toJSON() : err.message;\n\n    // printing the stack-trace information when running in development mode\n    /* istanbul ignore next */\n    if (process.env.NODE_ENV === 'development'){\n      process.stderr.write(`${err.stack}\\n`);\n      debug(err.stack);\n    }\n\n    return result;\n  }\n\n  /**\n   * Translates the success value to a data structure that is later serialized\n   * by a handler implementation as output.\n   *\n   * /todo:\n   * This value is either driven by the option 'result' (when defined) or by the\n   * value defined at constructor time.\n   *\n   * All writers shipped with Mebo have support for streams where in case of\n   * any readable stream or buffer value are piped to the output,\n   * otherwise the result is encoded using JSON (defined per writer bases).\n   *\n   * Note: any Buffer value passed to this method gets automatically converted to\n   * a readable stream (this behavior is driven by the option\n   * 'convertBufferToReadableStream').\n   *\n   * This method is called by {@link Handler.output}.\n   *\n   * @return {Object|Stream}\n   * @protected\n   */\n  _successOutput(){\n\n    const optionOutput = this.option('result');\n    const result = (optionOutput === undefined) ? this.value() : optionOutput;\n\n    // stream output\n    if (this.option('convertBufferToReadableStream') && result instanceof Buffer){\n      const bufferStream = new stream.PassThrough();\n      bufferStream.end(result);\n\n      return bufferStream;\n    }\n\n    return result;\n  }\n}\n\nmodule.exports = Writer;\n",
    "static": true,
    "longname": "src/Writer.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 627,
    "kind": "variable",
    "name": "__import_module__stream",
    "memberof": "src/Writer.js",
    "static": true,
    "longname": "src/Writer.js~__import_module__stream",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Writer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 628,
    "kind": "variable",
    "name": "__import_module__assert",
    "memberof": "src/Writer.js",
    "static": true,
    "longname": "src/Writer.js~__import_module__assert",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Writer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 629,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Writer.js",
    "static": true,
    "longname": "src/Writer.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Writer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 630,
    "kind": "variable",
    "name": "__import_module__debug",
    "memberof": "src/Writer.js",
    "static": true,
    "longname": "src/Writer.js~__import_module__debug",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Writer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 631,
    "kind": "variable",
    "name": "__import_module__Utils",
    "memberof": "src/Writer.js",
    "static": true,
    "longname": "src/Writer.js~__import_module__Utils",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Writer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 632,
    "kind": "variable",
    "name": "_options",
    "memberof": "src/Writer.js",
    "static": true,
    "longname": "src/Writer.js~_options",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Writer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 633,
    "kind": "variable",
    "name": "_value",
    "memberof": "src/Writer.js",
    "static": true,
    "longname": "src/Writer.js~_value",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Writer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 634,
    "kind": "class",
    "name": "Writer",
    "memberof": "src/Writer.js",
    "static": true,
    "longname": "src/Writer.js~Writer",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Writer.js",
    "importStyle": "Writer",
    "description": "A writer is used to output a value through the {@link Handler}.\n\nThe output is determined by the kind of value that's passed to the writer where\nexceptions are interpreted as error output otherwise, the value is interpreted\nas success value. Therefore, new implements are expected to implement both a success\n({@link Writer._successOutput}) and error ({@link Writer._errorOutput}) outputs.\n\n**Options:** Custom options can be assigned to writers ({@link Writer.setOption}).\nThey are passed from the handler to the writer during the output process\n({@link Handler.output}).\n\n```\nconst myHandler = Mebo.Handler.create('someHandler');\n\n// setting output options during the output\nmyHandler.output(value, {\n someOption: 10,\n});\n```\n\nWhen an action is executed through a handler it can define options for\nreaders and writers via {@link Metadata} support.\n\n<h2>Options Summary</h2>\n\nOption Name | Description | Default Value\n--- | --- | :---:\nconvertBufferToReadableStream | Tells if a buffer value should be converted to a  readable stream | ::true::\nresult | Overrides the value returned by {@link Writer.value} to an arbitrary  value (only affects the success output) | ::none::",
    "lineNumber": 44,
    "interface": false
  },
  {
    "__docId__": 635,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Writer.js~Writer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Writer.js~Writer#constructor",
    "access": null,
    "description": "Creates a writer",
    "lineNumber": 51,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "arbitrary value passed to the writer"
      }
    ]
  },
  {
    "__docId__": 636,
    "kind": "member",
    "name": "[_value]",
    "memberof": "src/Writer.js~Writer",
    "static": false,
    "longname": "src/Writer.js~Writer#[_value]",
    "access": null,
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 637,
    "kind": "member",
    "name": "[_options]",
    "memberof": "src/Writer.js~Writer",
    "static": false,
    "longname": "src/Writer.js~Writer#[_options]",
    "access": null,
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 638,
    "kind": "method",
    "name": "option",
    "memberof": "src/Writer.js~Writer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Writer.js~Writer#option",
    "access": null,
    "description": "Returns an option",
    "lineNumber": 76,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "path about where the option is localized (the levels\nmust be separated by '.'). In case of an empty string it returns the\nentire options"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "defaultValue",
        "description": "default value returned in case a value was\nnot found for the path"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 639,
    "kind": "method",
    "name": "setOption",
    "memberof": "src/Writer.js~Writer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Writer.js~Writer#setOption",
    "access": null,
    "description": "Sets a value under the options",
    "lineNumber": 91,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "path about where the option should be stored under\nthe options (the levels must be separated by '.')"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value that is going to be stored under the collection"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "merge",
        "description": "this option is used to decide in case of the\nlast level is already existing under the collection, if the value should be\neither merged (default) or overridden."
      }
    ]
  },
  {
    "__docId__": 640,
    "kind": "method",
    "name": "value",
    "memberof": "src/Writer.js~Writer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Writer.js~Writer#value",
    "access": null,
    "description": "Returns the value that should be serialized ({@link Writer.serialize}) by the writer.",
    "lineNumber": 102,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 641,
    "kind": "method",
    "name": "serialize",
    "memberof": "src/Writer.js~Writer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Writer.js~Writer#serialize",
    "access": null,
    "description": "Serializes a writer value ({@link Writer.value}) in case the value is an\nexception it's serialize as {@link Writer._errorOutput} otherwise it's serialized\nas {@link Writer._successOutput}.",
    "lineNumber": 111,
    "params": []
  },
  {
    "__docId__": 642,
    "kind": "method",
    "name": "_errorOutput",
    "memberof": "src/Writer.js~Writer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Writer.js~Writer#_errorOutput",
    "access": "protected",
    "description": "Translates an {@link Error} to a data structure that is later serialized by a writer\nimplementation as output. This method gets triggered when an exception is passed\nas value by the {@link Handler.output}.\n\nBy default the contents of the error output are driven by the `err.message`,\nhowever if an error contains `err.toJSON` property ({@link ValidationFail.toJSON})\nthen that's used instead of the message.\n\nAlso, you can avoid specific errors to be handled via output process by defining the member\n`output` assigned with `false` to the error (for instance ```err.output = false;```). If\nthat is in place the error gets thrown which triggers the event {@link Handler.onErrorDuringOutput}.\n\n**Tip:** You can set the env variable `NODE_ENV=development` to get the traceback information\nincluded in the error output",
    "lineNumber": 140,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 643,
    "kind": "method",
    "name": "_successOutput",
    "memberof": "src/Writer.js~Writer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Writer.js~Writer#_successOutput",
    "access": "protected",
    "description": "Translates the success value to a data structure that is later serialized\nby a handler implementation as output.\n\n/todo:\nThis value is either driven by the option 'result' (when defined) or by the\nvalue defined at constructor time.\n\nAll writers shipped with Mebo have support for streams where in case of\nany readable stream or buffer value are piped to the output,\notherwise the result is encoded using JSON (defined per writer bases).\n\nNote: any Buffer value passed to this method gets automatically converted to\na readable stream (this behavior is driven by the option\n'convertBufferToReadableStream').\n\nThis method is called by {@link Handler.output}.",
    "lineNumber": 185,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Object",
        "Stream"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 644,
    "kind": "file",
    "name": "src/Writers/CliOutput.js",
    "content": "const assert = require('assert');\nconst stream = require('stream');\nconst Handler = require('../Handler');\nconst Writer = require('../Writer');\n\n// symbols used for private instance variables to avoid any potential clashing\n// caused by re-implementations\nconst _stdout = Symbol('stdout');\nconst _stderr = Symbol('stderr');\n\n\n/**\n * Command output writer.\n *\n * This writer is used by the output of the cli handler\n * ({@link Cli}).\n *\n * In case the value is an exception then it's treated as\n * {@link CliOutput._errorOutput} otherwise the value is treated as\n * {@link CliOutput._successOutput}.\n *\n * When an action is executed through a handler it can define options for\n * readers and writers via {@link Metadata} support. For instance,\n * you can use it to provide a custom result for a specific handler:\n *\n * ```\n * class MyAction extends Mebo.Action{\n *\n *    // ...\n *\n *    _perform(data){\n *      // ...\n *    }\n *\n *    _finalize(err, value){\n *      // defining a custom result that only affects the web handler\n *      // this call could be done inside of the _perform method. However, we\n *      // are defining it inside of the _finalize to keep _perform as\n *      // abstract as possible. Since, _finalize is always called (even during\n *      // an error) after the execution of the action, it provides a way to\n *      // hook and define custom metadata related with the result.\n *      if (!err){\n *          // defining a custom output option\n *          this.setMeta('$cliResult', {\n *              message: 'My custom cli result!',\n *          });\n *      }\n *\n *      return super._finalize(err, value);\n *    }\n *\n *    // ...\n * }\n * ```\n *\n * <h2>Options Summary</h2>\n *\n * Option Name | Description | Default Value\n * --- | --- | :---:\n * result | Overrides the value returned by {@link Writer.value} to an arbitrary \\\n * value (only affects the success output) | ::none::\n * parsingErrorStatusCode | Custom error status code used to identify when the \\\n * cli args could not be parsed | `700`\n */\nclass CliOutput extends Writer{\n\n  /**\n   * Creates the cli output writer\n   *\n   * @param {*} value - arbitrary value passed to the writer\n   * @param {stream} stdout - stream used as stdout\n   * @param {stream} stderr - stream used as stderr\n   */\n  constructor(value, stdout, stderr){\n    super(value);\n\n    this._setStdout(stdout);\n    this._setStderr(stderr);\n\n    // default options\n    this.setOption('parsingErrorStatusCode', 700);\n  }\n\n  /**\n   * Returns the stream used as stdout\n   *\n   * @return {stream}\n   */\n  stdout(){\n    return this[_stdout];\n  }\n\n  /**\n   * Returns the stream used as stderr\n   *\n   * @return {stream}\n   */\n  stderr(){\n    return this[_stderr];\n  }\n\n  /**\n   * Implements the response for an error value.\n   *\n   * The error output writes the error message under the stderr.\n   *\n   * @protected\n   */\n  _errorOutput(){\n\n    process.exitCode = 1;\n    const message = super._errorOutput();\n\n    if (this.value().status === this.option('parsingErrorStatusCode')){\n      this.stderr().write(`${message}\\n`);\n    }\n    else{\n      this.stderr().write(message);\n    }\n  }\n\n  /**\n   * Implements the response for a success value.\n   *\n   * Readable streams are piped to {@link Cli.stdout}, otherwise\n   * the value is serialized using json.\n   *\n   * @protected\n   */\n  _successOutput(){\n\n    let result = super._successOutput();\n\n    /* istanbul ignore next */\n    if (result === undefined){\n      return;\n    }\n\n    // readable stream\n    if (result instanceof stream.Readable){\n      result.pipe(this.stdout());\n      return;\n    }\n\n    // json result\n    result = JSON.stringify(result, null, ' ');\n    result += '\\n';\n\n    this.stdout().write(result);\n  }\n\n  /**\n   * Sets the stdout stream\n   *\n   * @param {stream} value - stream used as stdout\n   * @private\n   */\n  _setStdout(value){\n    assert(value instanceof stream, 'Invalid stream type');\n\n    this[_stdout] = value;\n  }\n\n  /**\n   * Sets the stderr stream\n   *\n   * @param {stream} value - stream used as stderr\n   * @private\n   */\n  _setStderr(value){\n    assert(value instanceof stream, 'Invalid stream type');\n\n    this[_stderr] = value;\n  }\n}\n\n// registering writer\nHandler.registerWriter(CliOutput, 'cli');\n\nmodule.exports = CliOutput;\n",
    "static": true,
    "longname": "src/Writers/CliOutput.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 645,
    "kind": "variable",
    "name": "__import_module__assert",
    "memberof": "src/Writers/CliOutput.js",
    "static": true,
    "longname": "src/Writers/CliOutput.js~__import_module__assert",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Writers/CliOutput.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 646,
    "kind": "variable",
    "name": "__import_module__stream",
    "memberof": "src/Writers/CliOutput.js",
    "static": true,
    "longname": "src/Writers/CliOutput.js~__import_module__stream",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Writers/CliOutput.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 647,
    "kind": "variable",
    "name": "__import_module__Handler",
    "memberof": "src/Writers/CliOutput.js",
    "static": true,
    "longname": "src/Writers/CliOutput.js~__import_module__Handler",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Writers/CliOutput.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 648,
    "kind": "variable",
    "name": "__import_module__Writer",
    "memberof": "src/Writers/CliOutput.js",
    "static": true,
    "longname": "src/Writers/CliOutput.js~__import_module__Writer",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Writers/CliOutput.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 649,
    "kind": "variable",
    "name": "_stdout",
    "memberof": "src/Writers/CliOutput.js",
    "static": true,
    "longname": "src/Writers/CliOutput.js~_stdout",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Writers/CliOutput.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 650,
    "kind": "variable",
    "name": "_stderr",
    "memberof": "src/Writers/CliOutput.js",
    "static": true,
    "longname": "src/Writers/CliOutput.js~_stderr",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Writers/CliOutput.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 651,
    "kind": "class",
    "name": "CliOutput",
    "memberof": "src/Writers/CliOutput.js",
    "static": true,
    "longname": "src/Writers/CliOutput.js~CliOutput",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Writers/CliOutput.js",
    "importStyle": "CliOutput",
    "description": "Command output writer.\n\nThis writer is used by the output of the cli handler\n({@link Cli}).\n\nIn case the value is an exception then it's treated as\n{@link CliOutput._errorOutput} otherwise the value is treated as\n{@link CliOutput._successOutput}.\n\nWhen an action is executed through a handler it can define options for\nreaders and writers via {@link Metadata} support. For instance,\nyou can use it to provide a custom result for a specific handler:\n\n```\nclass MyAction extends Mebo.Action{\n\n   // ...\n\n   _perform(data){\n     // ...\n   }\n\n   _finalize(err, value){\n     // defining a custom result that only affects the web handler\n     // this call could be done inside of the _perform method. However, we\n     // are defining it inside of the _finalize to keep _perform as\n     // abstract as possible. Since, _finalize is always called (even during\n     // an error) after the execution of the action, it provides a way to\n     // hook and define custom metadata related with the result.\n     if (!err){\n         // defining a custom output option\n         this.setMeta('$cliResult', {\n             message: 'My custom cli result!',\n         });\n     }\n\n     return super._finalize(err, value);\n   }\n\n   // ...\n}\n```\n\n<h2>Options Summary</h2>\n\nOption Name | Description | Default Value\n--- | --- | :---:\nresult | Overrides the value returned by {@link Writer.value} to an arbitrary  value (only affects the success output) | ::none::\nparsingErrorStatusCode | Custom error status code used to identify when the  cli args could not be parsed | `700`",
    "lineNumber": 63,
    "interface": false,
    "extends": [
      "Writer"
    ]
  },
  {
    "__docId__": 652,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Writers/CliOutput.js~CliOutput",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Writers/CliOutput.js~CliOutput#constructor",
    "access": null,
    "description": "Creates the cli output writer",
    "lineNumber": 72,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "arbitrary value passed to the writer"
      },
      {
        "nullable": null,
        "types": [
          "stream"
        ],
        "spread": false,
        "optional": false,
        "name": "stdout",
        "description": "stream used as stdout"
      },
      {
        "nullable": null,
        "types": [
          "stream"
        ],
        "spread": false,
        "optional": false,
        "name": "stderr",
        "description": "stream used as stderr"
      }
    ]
  },
  {
    "__docId__": 653,
    "kind": "method",
    "name": "stdout",
    "memberof": "src/Writers/CliOutput.js~CliOutput",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Writers/CliOutput.js~CliOutput#stdout",
    "access": null,
    "description": "Returns the stream used as stdout",
    "lineNumber": 87,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "stream"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 654,
    "kind": "method",
    "name": "stderr",
    "memberof": "src/Writers/CliOutput.js~CliOutput",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Writers/CliOutput.js~CliOutput#stderr",
    "access": null,
    "description": "Returns the stream used as stderr",
    "lineNumber": 96,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "stream"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 655,
    "kind": "method",
    "name": "_errorOutput",
    "memberof": "src/Writers/CliOutput.js~CliOutput",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Writers/CliOutput.js~CliOutput#_errorOutput",
    "access": "protected",
    "description": "Implements the response for an error value.\n\nThe error output writes the error message under the stderr.",
    "lineNumber": 107,
    "params": []
  },
  {
    "__docId__": 656,
    "kind": "method",
    "name": "_successOutput",
    "memberof": "src/Writers/CliOutput.js~CliOutput",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Writers/CliOutput.js~CliOutput#_successOutput",
    "access": "protected",
    "description": "Implements the response for a success value.\n\nReadable streams are piped to {@link Cli.stdout}, otherwise\nthe value is serialized using json.",
    "lineNumber": 128,
    "params": []
  },
  {
    "__docId__": 657,
    "kind": "method",
    "name": "_setStdout",
    "memberof": "src/Writers/CliOutput.js~CliOutput",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Writers/CliOutput.js~CliOutput#_setStdout",
    "access": "private",
    "description": "Sets the stdout stream",
    "lineNumber": 156,
    "params": [
      {
        "nullable": null,
        "types": [
          "stream"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "stream used as stdout"
      }
    ]
  },
  {
    "__docId__": 658,
    "kind": "member",
    "name": "[_stdout]",
    "memberof": "src/Writers/CliOutput.js~CliOutput",
    "static": false,
    "longname": "src/Writers/CliOutput.js~CliOutput#[_stdout]",
    "access": null,
    "description": null,
    "lineNumber": 159,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 659,
    "kind": "method",
    "name": "_setStderr",
    "memberof": "src/Writers/CliOutput.js~CliOutput",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Writers/CliOutput.js~CliOutput#_setStderr",
    "access": "private",
    "description": "Sets the stderr stream",
    "lineNumber": 168,
    "params": [
      {
        "nullable": null,
        "types": [
          "stream"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "stream used as stderr"
      }
    ]
  },
  {
    "__docId__": 660,
    "kind": "member",
    "name": "[_stderr]",
    "memberof": "src/Writers/CliOutput.js~CliOutput",
    "static": false,
    "longname": "src/Writers/CliOutput.js~CliOutput#[_stderr]",
    "access": null,
    "description": null,
    "lineNumber": 171,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 661,
    "kind": "file",
    "name": "src/Writers/WebResponse.js",
    "content": "const assert = require('assert');\nconst stream = require('stream');\nconst TypeCheck = require('js-typecheck');\nconst Settings = require('../Settings');\nconst Handler = require('../Handler');\nconst Writer = require('../Writer');\n\n// symbols used for private instance variables to avoid any potential clashing\n// caused by re-implementations\nconst _response = Symbol('response');\n\n\n/**\n * Web output writer.\n *\n * This writer is used by the output of the web handler ({@link Web}).\n *\n * In case the value is an exception then it's treated as\n * {@link WebResponse._errorOutput} otherwise the value is treated as\n * {@link WebResponse._successOutput}.\n *\n * When an action is executed through a handler it can define options for\n * readers and writers via {@link Metadata} support. For instance,\n * you can use it to provide a custom result for a specific handler:\n *\n * ```\n * class MyAction extends Mebo.Action{\n *\n *    // ...\n *\n *    _perform(data){\n *      // ...\n *    }\n *\n *    _finalize(err, value){\n *      // defining a custom result that only affects the web handler\n *      // this call could be done inside of the _perform method. However, we\n *      // are defining it inside of the _finalize to keep _perform as\n *      // abstract as possible. Since, _finalize is always called (even during\n *      // an error) after the execution of the action, it provides a way to\n *      // hook and define custom metadata related with the result.\n *      if (!err){\n *          // defining a custom output option\n *          this.setMeta('$webResult', {\n *              message: 'My custom web result!',\n *          });\n *      }\n *\n *      return super._finalize(err, value);\n *    }\n *\n *    // ...\n * }\n * ```\n *\n * <h2>Options Summary</h2>\n *\n * Option Name | Description | Default Value\n * --- | --- | :---:\n * headers | plain object containing the header names (in camel case convention) \\\n * that should be used in the response | `{}`\n * headersOnly | if enabled ends the response without any data | ::false::\n * status | success status code (the error status code is driven by the status \\\n * defined as a member of the exception) | `200`\n * root | plain object that gets deep merged at the root of the json output\\\n * of a success result, for instance:<br>`{data: {...}, <rootContentsA>: ..., \\\n * <rootContentsB> : ...}` | `{}`\n * result | Overrides the value returned by {@link Writer.value} to an \\\n * arbitrary value (only affects the success output) | ::none::\n * resultLabel | custom label used by the success output when the value is \\\n * serialized using json. This label is used to hold the result \\\n * under data, for instance:<br>`{data: {<resultLabel>: value}}`<br><br>In case of \\\n * undefined (default) then a fallback label is used based on the value type: \\\n * <br>- primitive values are held under 'value' \\\n * <br>- array value is held under 'items' \\\n * <br>- object is assigned with '' (empty string) \\\n * <br>* when an empty string is used, the value gets merged to the \\\n * result.data | ::none::\n *\n * <br>When defining options through the metadata support, it can done using\n * `option vars`. Mebo comes bundled with pre-defined option vars\n * for most of the options available for the readers & writers. The complete list\n * of the option vars can be found at {@link Metadata} documentation.\n *\n * Example of defining the `headers` option from inside of an action through\n * the metadata support:\n *\n * ```\n * // defining 'Content-Type' header\n * class MyAction extends Mebo.Action{\n *    _perform(data){\n *\n *      // 'Content-Type' header\n *      this.setMeta('$webHeaders', {\n *        contentType: 'application/octet-stream',\n *      });\n *\n *      // ...\n *    }\n * }\n * ```\n *\n * Also, headers can be defined through 'before action middlewares'\n * ({@link Web.addBeforeAction} and {@link Web.addBeforeAuthAction})\n */\nclass WebResponse extends Writer{\n\n  /**\n   * Creates a web response writer\n   *\n   * @param {*} value - arbitrary value passed to the writer\n   * @param {Object} res - express res object\n   */\n  constructor(value, res){\n    super(value);\n    this._setResponse(res);\n\n    // default options\n    this.setOption('headersOnly', false);\n    this.setOption('headers', {});\n    this.setOption('root', {\n      apiVersion: Settings.get('apiVersion'),\n    });\n    this.setOption('status', 200);\n  }\n\n  /**\n   * Returns the response object created by express\n   *\n   * @return {Object}\n   * @see http://expressjs.com/en/api.html#res\n   */\n  response(){\n    return this[_response];\n  }\n\n  /**\n   * Implements the response for an error value.\n   *\n   * Any error can carry a HTTP status code. It is done by defining `status` to any error\n   * (for instance ```err.status = 501;```).\n   * This practice can be found in all errors shipped with mebo ({@link Conflict}, {@link NoContent},\n   * {@link NotFound} and {@link ValidationFail}). In case none status is found in the error then `500`\n   * is used automatically.\n   *\n   * The error response gets automatically encoded using json, following the basics\n   * of google's json style guide. In case of an error status `500` the standard\n   * result is ignored and a message `Internal Server Error` is used instead.\n   *\n   * Further information can be found at base class documentation\n   * {@link Writer._errorOutput}.\n   *\n   * @protected\n   */\n  _errorOutput(){\n\n    const status = this.value().status || 500;\n\n    // setting the status code for the response\n    this.response().status(status);\n\n    const result = {\n      error: {\n        code: status,\n        message: super._errorOutput(),\n      },\n    };\n\n    // adding the stack-trace information when running in development mode\n    /* istanbul ignore next */\n    if (process.env.NODE_ENV === 'development'){\n      result.error.stacktrace = this.value().stack.split('\\n');\n    }\n\n    // should not leak any error message for the status code 500\n    if (status === 500){\n      result.error.message = 'Internal Server Error';\n    }\n\n    this._genericOutput(result);\n  }\n\n  /**\n   * Implements the response for a success value.\n   *\n   * A readable stream value is piped using 'application/octet-stream' by default\n   * (if it has not been defined by the header option 'contentType'),\n   * otherwise for non-readable stream value it's automatically encoded\n   * using json, following the basics of google's json style guide.\n   *\n   * Further information can be found at base class documentation\n   * {@link Writer._successOutput}.\n   *\n   * @see https://google.github.io/styleguide/jsoncstyleguide.xml\n   * @protected\n   */\n  _successOutput(){\n\n    const result = super._successOutput();\n\n    // setting the status code for the response\n    this.response().status(this.option('status'));\n\n    // setting header\n    this._setResponseHeaders();\n\n    // readable stream\n    if (result instanceof stream.Readable){\n      this._successStreamOutput(result);\n      return;\n    }\n\n    this._successJSONOutput(result);\n  }\n\n  /**\n   * Sets the response object created by express\n   *\n   * @param {Object} value - res object\n   * @see http://expressjs.com/en/api.html#res\n   * @private\n   */\n  _setResponse(value){\n    assert(TypeCheck.isObject(value) && TypeCheck.isObject(value.locals), 'Invalid response object');\n\n    this[_response] = value;\n  }\n\n  /**\n   * Results a stream through the success output\n   *\n   * @param {stream} value - output value\n   * @private\n   */\n  _successStreamOutput(value){\n    // setting a default content-type for readable stream in case\n    // it has not been set previously\n    const headers = this.option('headers');\n    if (!(headers && headers.contentType)){\n      this.response().setHeader('Content-Type', 'application/octet-stream');\n    }\n\n    value.pipe(this.response());\n  }\n\n  /**\n   * Results the default success output through google's json style guide\n   *\n   * @param {*} result - output value\n   * @private\n   */\n  _successJSONOutput(result){\n\n    const output = {};\n\n    // including the root options\n    Object.assign(output, this.option('root'));\n\n    // automatic result, it is done by figuring out the response based on\n    // the value returned by the action, otherwise if output contains data\n    // returns that instead\n    output.data = {};\n\n    if (result !== undefined){\n\n      // in case the value has defined 'toJSON' calling that to get result\n      // value that should be used for the output, reference:\n      // https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\n      let finalResult = result;\n      if (TypeCheck.isCallable(result.toJSON)){\n        finalResult = JSON.parse(JSON.stringify(result));\n      }\n\n      // resolving the result label\n      const resultLabel = this._resultLabel(finalResult);\n\n      if (resultLabel){\n        output.data[resultLabel] = finalResult;\n      }\n      else{\n        assert(!TypeCheck.isPrimitive(finalResult), \"Can't output a primitive value without a 'resultLabel'\");\n        assert(TypeCheck.isPlainObject(finalResult), \"Can't output a non-plain object value\");\n        output.data = finalResult;\n      }\n    }\n\n    this._genericOutput(output);\n  }\n\n  /**\n   * Generic output routine shared by both success and error outputs\n   *\n   * @param {*} output - arbitrary data used as output\n   * @private\n   */\n  _genericOutput(output){\n\n    // ending response without any data\n    if (this.option('headersOnly')){\n      this.response().end();\n      return;\n    }\n\n    // json output\n    this.response().json(output);\n  }\n\n  /**\n   * Returns the label used to hold the result under data. In case of undefined\n   * (default) it uses a fallback label based on the value type:\n   *\n   * - primitive values are held under 'value'\n   * - array value is held under 'items'\n   * - object is assigned with `null`\n   * * when an empty string is used, the value gets merged to the result.data\n   *\n   * @param {*} value - value that should be used by the result entry\n   * @return {string}\n   * @private\n   */\n  _resultLabel(value){\n    let resultLabel = this.option('resultLabel');\n    if (resultLabel === undefined){\n      if (TypeCheck.isPrimitive(value)){\n        resultLabel = 'value';\n      }\n      else if (TypeCheck.isList(value)){\n        resultLabel = 'items';\n      }\n      else{\n        resultLabel = '';\n      }\n    }\n\n    return resultLabel;\n  }\n\n  /**\n   * Looks for any header member defined as part of the options and sets them\n   * to the response header. It expects a camelCase name convention for the header name\n   *  where it gets translated to the header name convention, for instance:\n   * 'options.headers.contentType' translates to 'Content-Type'.\n   *\n   * @param {*} options - options passed to the output\n   * @private\n   */\n  _setResponseHeaders(){\n\n    const headers = this.option('headers');\n    const response = this.response();\n    if (headers){\n      for (const headerName in headers){\n        const convertedHeaderName = headerName.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n\n        // assigning a header value to the response\n        response.setHeader(convertedHeaderName, headers[headerName]);\n      }\n    }\n  }\n}\n\n// registering writer\nHandler.registerWriter(WebResponse, 'web');\n\nmodule.exports = WebResponse;\n",
    "static": true,
    "longname": "src/Writers/WebResponse.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 662,
    "kind": "variable",
    "name": "__import_module__assert",
    "memberof": "src/Writers/WebResponse.js",
    "static": true,
    "longname": "src/Writers/WebResponse.js~__import_module__assert",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Writers/WebResponse.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 663,
    "kind": "variable",
    "name": "__import_module__stream",
    "memberof": "src/Writers/WebResponse.js",
    "static": true,
    "longname": "src/Writers/WebResponse.js~__import_module__stream",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Writers/WebResponse.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 664,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/Writers/WebResponse.js",
    "static": true,
    "longname": "src/Writers/WebResponse.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Writers/WebResponse.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 665,
    "kind": "variable",
    "name": "__import_module__Settings",
    "memberof": "src/Writers/WebResponse.js",
    "static": true,
    "longname": "src/Writers/WebResponse.js~__import_module__Settings",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Writers/WebResponse.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 666,
    "kind": "variable",
    "name": "__import_module__Handler",
    "memberof": "src/Writers/WebResponse.js",
    "static": true,
    "longname": "src/Writers/WebResponse.js~__import_module__Handler",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Writers/WebResponse.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 667,
    "kind": "variable",
    "name": "__import_module__Writer",
    "memberof": "src/Writers/WebResponse.js",
    "static": true,
    "longname": "src/Writers/WebResponse.js~__import_module__Writer",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Writers/WebResponse.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 668,
    "kind": "variable",
    "name": "_response",
    "memberof": "src/Writers/WebResponse.js",
    "static": true,
    "longname": "src/Writers/WebResponse.js~_response",
    "access": null,
    "export": false,
    "importPath": "mebo/src/Writers/WebResponse.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 669,
    "kind": "class",
    "name": "WebResponse",
    "memberof": "src/Writers/WebResponse.js",
    "static": true,
    "longname": "src/Writers/WebResponse.js~WebResponse",
    "access": null,
    "export": true,
    "importPath": "mebo/src/Writers/WebResponse.js",
    "importStyle": "WebResponse",
    "description": "Web output writer.\n\nThis writer is used by the output of the web handler ({@link Web}).\n\nIn case the value is an exception then it's treated as\n{@link WebResponse._errorOutput} otherwise the value is treated as\n{@link WebResponse._successOutput}.\n\nWhen an action is executed through a handler it can define options for\nreaders and writers via {@link Metadata} support. For instance,\nyou can use it to provide a custom result for a specific handler:\n\n```\nclass MyAction extends Mebo.Action{\n\n   // ...\n\n   _perform(data){\n     // ...\n   }\n\n   _finalize(err, value){\n     // defining a custom result that only affects the web handler\n     // this call could be done inside of the _perform method. However, we\n     // are defining it inside of the _finalize to keep _perform as\n     // abstract as possible. Since, _finalize is always called (even during\n     // an error) after the execution of the action, it provides a way to\n     // hook and define custom metadata related with the result.\n     if (!err){\n         // defining a custom output option\n         this.setMeta('$webResult', {\n             message: 'My custom web result!',\n         });\n     }\n\n     return super._finalize(err, value);\n   }\n\n   // ...\n}\n```\n\n<h2>Options Summary</h2>\n\nOption Name | Description | Default Value\n--- | --- | :---:\nheaders | plain object containing the header names (in camel case convention)  that should be used in the response | `{}`\nheadersOnly | if enabled ends the response without any data | ::false::\nstatus | success status code (the error status code is driven by the status  defined as a member of the exception) | `200`\nroot | plain object that gets deep merged at the root of the json output of a success result, for instance:<br>`{data: {...}, <rootContentsA>: ...,  <rootContentsB> : ...}` | `{}`\nresult | Overrides the value returned by {@link Writer.value} to an  arbitrary value (only affects the success output) | ::none::\nresultLabel | custom label used by the success output when the value is  serialized using json. This label is used to hold the result  under data, for instance:<br>`{data: {<resultLabel>: value}}`<br><br>In case of  undefined (default) then a fallback label is used based on the value type:  <br>- primitive values are held under 'value'  <br>- array value is held under 'items'  <br>- object is assigned with '' (empty string)  <br>* when an empty string is used, the value gets merged to the  result.data | ::none::\n\n<br>When defining options through the metadata support, it can done using\n`option vars`. Mebo comes bundled with pre-defined option vars\nfor most of the options available for the readers & writers. The complete list\nof the option vars can be found at {@link Metadata} documentation.\n\nExample of defining the `headers` option from inside of an action through\nthe metadata support:\n\n```\n// defining 'Content-Type' header\nclass MyAction extends Mebo.Action{\n   _perform(data){\n\n     // 'Content-Type' header\n     this.setMeta('$webHeaders', {\n       contentType: 'application/octet-stream',\n     });\n\n     // ...\n   }\n}\n```\n\nAlso, headers can be defined through 'before action middlewares'\n({@link Web.addBeforeAction} and {@link Web.addBeforeAuthAction})",
    "lineNumber": 93,
    "interface": false,
    "extends": [
      "Writer"
    ]
  },
  {
    "__docId__": 670,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Writers/WebResponse.js~WebResponse",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Writers/WebResponse.js~WebResponse#constructor",
    "access": null,
    "description": "Creates a web response writer",
    "lineNumber": 101,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "arbitrary value passed to the writer"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "res",
        "description": "express res object"
      }
    ]
  },
  {
    "__docId__": 671,
    "kind": "method",
    "name": "response",
    "memberof": "src/Writers/WebResponse.js~WebResponse",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Writers/WebResponse.js~WebResponse#response",
    "access": null,
    "description": "Returns the response object created by express",
    "see": [
      "http://expressjs.com/en/api.html#res"
    ],
    "lineNumber": 120,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 672,
    "kind": "method",
    "name": "_errorOutput",
    "memberof": "src/Writers/WebResponse.js~WebResponse",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Writers/WebResponse.js~WebResponse#_errorOutput",
    "access": "protected",
    "description": "Implements the response for an error value.\n\nAny error can carry a HTTP status code. It is done by defining `status` to any error\n(for instance ```err.status = 501;```).\nThis practice can be found in all errors shipped with mebo ({@link Conflict}, {@link NoContent},\n{@link NotFound} and {@link ValidationFail}). In case none status is found in the error then `500`\nis used automatically.\n\nThe error response gets automatically encoded using json, following the basics\nof google's json style guide. In case of an error status `500` the standard\nresult is ignored and a message `Internal Server Error` is used instead.\n\nFurther information can be found at base class documentation\n{@link Writer._errorOutput}.",
    "lineNumber": 142,
    "params": []
  },
  {
    "__docId__": 673,
    "kind": "method",
    "name": "_successOutput",
    "memberof": "src/Writers/WebResponse.js~WebResponse",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Writers/WebResponse.js~WebResponse#_successOutput",
    "access": "protected",
    "description": "Implements the response for a success value.\n\nA readable stream value is piped using 'application/octet-stream' by default\n(if it has not been defined by the header option 'contentType'),\notherwise for non-readable stream value it's automatically encoded\nusing json, following the basics of google's json style guide.\n\nFurther information can be found at base class documentation\n{@link Writer._successOutput}.",
    "see": [
      "https://google.github.io/styleguide/jsoncstyleguide.xml"
    ],
    "lineNumber": 184,
    "params": []
  },
  {
    "__docId__": 674,
    "kind": "method",
    "name": "_setResponse",
    "memberof": "src/Writers/WebResponse.js~WebResponse",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Writers/WebResponse.js~WebResponse#_setResponse",
    "access": "private",
    "description": "Sets the response object created by express",
    "see": [
      "http://expressjs.com/en/api.html#res"
    ],
    "lineNumber": 210,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "res object"
      }
    ]
  },
  {
    "__docId__": 675,
    "kind": "member",
    "name": "[_response]",
    "memberof": "src/Writers/WebResponse.js~WebResponse",
    "static": false,
    "longname": "src/Writers/WebResponse.js~WebResponse#[_response]",
    "access": null,
    "description": null,
    "lineNumber": 213,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 676,
    "kind": "method",
    "name": "_successStreamOutput",
    "memberof": "src/Writers/WebResponse.js~WebResponse",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Writers/WebResponse.js~WebResponse#_successStreamOutput",
    "access": "private",
    "description": "Results a stream through the success output",
    "lineNumber": 222,
    "params": [
      {
        "nullable": null,
        "types": [
          "stream"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "output value"
      }
    ]
  },
  {
    "__docId__": 677,
    "kind": "method",
    "name": "_successJSONOutput",
    "memberof": "src/Writers/WebResponse.js~WebResponse",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Writers/WebResponse.js~WebResponse#_successJSONOutput",
    "access": "private",
    "description": "Results the default success output through google's json style guide",
    "lineNumber": 239,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "result",
        "description": "output value"
      }
    ]
  },
  {
    "__docId__": 678,
    "kind": "method",
    "name": "_genericOutput",
    "memberof": "src/Writers/WebResponse.js~WebResponse",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Writers/WebResponse.js~WebResponse#_genericOutput",
    "access": "private",
    "description": "Generic output routine shared by both success and error outputs",
    "lineNumber": 283,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "output",
        "description": "arbitrary data used as output"
      }
    ]
  },
  {
    "__docId__": 679,
    "kind": "method",
    "name": "_resultLabel",
    "memberof": "src/Writers/WebResponse.js~WebResponse",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Writers/WebResponse.js~WebResponse#_resultLabel",
    "access": "private",
    "description": "Returns the label used to hold the result under data. In case of undefined\n(default) it uses a fallback label based on the value type:\n\n- primitive values are held under 'value'\n- array value is held under 'items'\n- object is assigned with `null`\n* when an empty string is used, the value gets merged to the result.data",
    "lineNumber": 308,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value that should be used by the result entry"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 680,
    "kind": "method",
    "name": "_setResponseHeaders",
    "memberof": "src/Writers/WebResponse.js~WebResponse",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Writers/WebResponse.js~WebResponse#_setResponseHeaders",
    "access": "private",
    "description": "Looks for any header member defined as part of the options and sets them\nto the response header. It expects a camelCase name convention for the header name\n where it gets translated to the header name convention, for instance:\n'options.headers.contentType' translates to 'Content-Type'.",
    "lineNumber": 334,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "options passed to the output"
      }
    ]
  },
  {
    "__docId__": 681,
    "kind": "file",
    "name": "src/Writers/index.js",
    "content": "module.exports.CliOutput = require('./CliOutput');\nmodule.exports.WebResponse = require('./WebResponse');\n",
    "static": true,
    "longname": "src/Writers/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 682,
    "kind": "file",
    "name": "src/decorators.js",
    "content": "const assert = require('assert');\nconst TypeCheck = require('js-typecheck');\nconst Action = require('./Action');\nconst Input = require('./Input');\nconst Handler = require('./Handler');\n\n\n/**\n * Generic registration, can be used for {@link Input}, {@link Action} and {@link Handler}\n *\n * @param {...args} args - arguments passed to the registration\n * @return {function}\n */\nfunction register(...args){\n  return (target) => {\n    target.register(target, ...args);\n  };\n}\n\n/**\n * Allows the action to be executed through the handler\n *\n * @param {string} handlerName - name of the handler\n * @param {...args} args - arguments passed to the registration\n * @return {function}\n */\nfunction grant(handlerName, ...args){\n  return (target) => {\n    assert(TypeCheck.isSubClassOf(target, Action), 'grant decorator requires an action');\n    const registeredActionName = Action.registeredActionName(target);\n    Handler.grantAction(handlerName, registeredActionName, ...args);\n  };\n}\n\n/**\n * Registers a property to an input\n *\n * @param {string} propertyName - property name to be registered\n * @returns {function}\n */\nfunction property(propertyName, ...args){\n  return (target) => {\n    assert(TypeCheck.isSubClassOf(target, Input), 'property decorator requires an input');\n\n    Input.registerProperty(target, propertyName, ...args);\n  };\n}\n\nmodule.exports.register = register;\nmodule.exports.grant = grant;\nmodule.exports.property = property;\n",
    "static": true,
    "longname": "src/decorators.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 683,
    "kind": "variable",
    "name": "__import_module__assert",
    "memberof": "src/decorators.js",
    "static": true,
    "longname": "src/decorators.js~__import_module__assert",
    "access": null,
    "export": false,
    "importPath": "mebo/src/decorators.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 684,
    "kind": "variable",
    "name": "__import_module__TypeCheck",
    "memberof": "src/decorators.js",
    "static": true,
    "longname": "src/decorators.js~__import_module__TypeCheck",
    "access": null,
    "export": false,
    "importPath": "mebo/src/decorators.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 685,
    "kind": "variable",
    "name": "__import_module__Action",
    "memberof": "src/decorators.js",
    "static": true,
    "longname": "src/decorators.js~__import_module__Action",
    "access": null,
    "export": false,
    "importPath": "mebo/src/decorators.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 686,
    "kind": "variable",
    "name": "__import_module__Input",
    "memberof": "src/decorators.js",
    "static": true,
    "longname": "src/decorators.js~__import_module__Input",
    "access": null,
    "export": false,
    "importPath": "mebo/src/decorators.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 687,
    "kind": "variable",
    "name": "__import_module__Handler",
    "memberof": "src/decorators.js",
    "static": true,
    "longname": "src/decorators.js~__import_module__Handler",
    "access": null,
    "export": false,
    "importPath": "mebo/src/decorators.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 688,
    "kind": "function",
    "name": "register",
    "memberof": "src/decorators.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/decorators.js~register",
    "access": null,
    "export": false,
    "importPath": "mebo/src/decorators.js",
    "importStyle": null,
    "description": "Generic registration, can be used for {@link Input}, {@link Action} and {@link Handler}",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "...args"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "arguments passed to the registration"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 689,
    "kind": "function",
    "name": "grant",
    "memberof": "src/decorators.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/decorators.js~grant",
    "access": null,
    "export": false,
    "importPath": "mebo/src/decorators.js",
    "importStyle": null,
    "description": "Allows the action to be executed through the handler",
    "lineNumber": 27,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "handlerName",
        "description": "name of the handler"
      },
      {
        "nullable": null,
        "types": [
          "...args"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "arguments passed to the registration"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 690,
    "kind": "function",
    "name": "property",
    "memberof": "src/decorators.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/decorators.js~property",
    "access": null,
    "export": false,
    "importPath": "mebo/src/decorators.js",
    "importStyle": null,
    "description": "Registers a property to an input",
    "lineNumber": 41,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{function}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "propertyName",
        "description": "property name to be registered"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 691,
    "kind": "file",
    "name": "src/index.js",
    "content": "const modules = {};\n\n// main modules\nmodules.Errors = require('./Errors');\nmodules.Utils = require('./Utils');\nmodules.Tasks = require('./Tasks');\nmodules.Input = require('./Input');\nmodules.Metadata = require('./Metadata');\nmodules.Settings = require('./Settings');\nmodules.Action = require('./Action');\nmodules.Session = require('./Session');\nmodules.Handler = require('./Handler');\nmodules.Reader = require('./Reader');\nmodules.Writer = require('./Writer');\n\n// decorators for the main modules\nObject.assign(\n  modules, require('./decorators'),\n);\n\n// implementations bundled with mebo\nmodules.Inputs = require('./Inputs');\nmodules.Handlers = require('./Handlers');\nmodules.Readers = require('./Readers');\nmodules.Writers = require('./Writers');\n\nmodule.exports = modules;\n",
    "static": true,
    "longname": "src/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 692,
    "kind": "variable",
    "name": "modules",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~modules",
    "access": null,
    "export": true,
    "importPath": "mebo/src/index.js",
    "importStyle": "modules",
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 694,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Infinity",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 695,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~NaN",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 696,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~undefined",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 697,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~null",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 698,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Object",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 699,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~object",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 700,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Function",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 701,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~function",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 702,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Boolean",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 703,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~boolean",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 704,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Symbol",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 705,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Error",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 706,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~EvalError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 707,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~InternalError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 708,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RangeError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 709,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ReferenceError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 710,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~SyntaxError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 711,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~TypeError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 712,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~URIError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 713,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Number",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 714,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~number",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 715,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Date",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 716,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~String",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 717,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~string",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 718,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RegExp",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 719,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 720,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int8Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 721,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 722,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8ClampedArray",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 723,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int16Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 724,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint16Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 725,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 726,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 727,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 728,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float64Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 729,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Map",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 730,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Set",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 731,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakMap",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 732,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakSet",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 733,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ArrayBuffer",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 734,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~DataView",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 735,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~JSON",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 736,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Promise",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 737,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Generator",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 738,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~GeneratorFunction",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 739,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Reflect",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 740,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Proxy",
    "access": null,
    "description": "",
    "lineNumber": 193,
    "builtinExternal": true
  },
  {
    "__docId__": 742,
    "kind": "external",
    "name": "CanvasRenderingContext2D",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~CanvasRenderingContext2D",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 743,
    "kind": "external",
    "name": "DocumentFragment",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~DocumentFragment",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 744,
    "kind": "external",
    "name": "Element",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Element",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~Element",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 745,
    "kind": "external",
    "name": "Event",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Event",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~Event",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 746,
    "kind": "external",
    "name": "Node",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Node",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~Node",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 747,
    "kind": "external",
    "name": "NodeList",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/NodeList",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~NodeList",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 748,
    "kind": "external",
    "name": "XMLHttpRequest",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~XMLHttpRequest",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 749,
    "kind": "external",
    "name": "AudioContext",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/AudioContext",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~AudioContext",
    "access": null,
    "description": "",
    "lineNumber": 34,
    "builtinExternal": true
  }
]