<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/Input.js | Mebo</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
<link data-ice="userStyle" rel="stylesheet" href="user/css/0-style.css">
<link rel="icon" type="image/png" sizes="64x64" href="data/icon.png?v=1"><script async defer src="https://buttons.github.io/buttons.js"></script></head>
<body class="layout-container" data-ice="rootContainer">

<header><a href="./index.html"><img src="data/icon.png?v=1" id="meboSmallLogo" width="40" height="40" align="top"/></a>
  <a href="./">Home</a>
  <a href="./manual/overview/INTRODUCTION.html" data-ice="manualHeaderLink">Intro</a>
  
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/meboHQ/mebo" class="repo-url-github">Mebo&nbsp;GitHub</a>
  <div class="search-box">
  <span>
    <img src="data/docs/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Action.js~Action.html">Action</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Handler.js~Handler.html">Handler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Input.js~Input.html">Input</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Metadata.js~Metadata.html">Metadata</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Reader.js~Reader.html">Reader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Session.js~Session.html">Session</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Settings.js~Settings.html">Settings</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Tasks.js~Tasks.html">Tasks</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Writer.js~Writer.html">Writer</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">Error</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Error/Conflict.js~Conflict.html">Conflict</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Error/NoContent.js~NoContent.html">NoContent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Error/NotFound.js~NotFound.html">NotFound</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Error/ValidationFail.js~ValidationFail.html">ValidationFail</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">Ext/Handlers</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Ext/Handlers/CommandLine.js~CommandLine.html">CommandLine</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Ext/Handlers/Web.js~Web.html">Web</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">Ext/Inputs</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Ext/Inputs/Any.js~Any.html">Any</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Ext/Inputs/BaseText.js~BaseText.html">BaseText</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Ext/Inputs/Bool.js~Bool.html">Bool</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Ext/Inputs/Buf.js~Buf.html">Buf</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Ext/Inputs/Email.js~Email.html">Email</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Ext/Inputs/FilePath.js~FilePath.html">FilePath</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Ext/Inputs/Hash.js~Hash.html">Hash</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Ext/Inputs/Hex.js~Hex.html">Hex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Ext/Inputs/Ip.js~Ip.html">Ip</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Ext/Inputs/Numeric.js~Numeric.html">Numeric</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Ext/Inputs/Stream.js~Stream.html">Stream</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Ext/Inputs/Text.js~Text.html">Text</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Ext/Inputs/Timestamp.js~Timestamp.html">Timestamp</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Ext/Inputs/UUID.js~UUID.html">UUID</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Ext/Inputs/Url.js~Url.html">Url</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Ext/Inputs/Version.js~Version.html">Version</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">Ext/Readers</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Ext/Readers/CommandLineArgs.js~CommandLineArgs.html">CommandLineArgs</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Ext/Readers/WebRequest.js~WebRequest.html">WebRequest</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">Ext/Writers</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Ext/Writers/CommandLineOutput.js~CommandLineOutput.html">CommandLineOutput</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Ext/Writers/WebResponse.js~WebResponse.html">WebResponse</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">Util</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Util/ImmutableMap.js~ImmutableMap.html">ImmutableMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Util/LruCache.js~LruCache.html">LruCache</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/Input.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">const assert = require(&apos;assert&apos;);
const TypeCheck = require(&apos;js-typecheck&apos;);
const ValidationFail = require(&apos;./Error/ValidationFail&apos;);
const Util = require(&apos;./Util&apos;);

// symbols used for private instance variables to avoid any potential clashing
// caused by re-implementations
const _name = Symbol(&apos;name&apos;);
const _readOnly = Symbol(&apos;readOnly&apos;);
const _properties = Symbol(&apos;properties&apos;);
const _lockedProperties = Symbol(&apos;lockedProperties&apos;);
const _cache = Symbol(&apos;cache&apos;);


/**
 * An input holds a value that is used for the execution of the {@link Action}.
 *
 * The value carried by the input gets checked through a wide range of validations
 * that makes sure the value meets the necessary requirements for  the execution
 * of the {@link Action}.
 *
 * The validations are performed asynchronously which enables an implementation
 * that can go far beyond checking the data type or matching the value through
 * a regex. In most cases these validations are driven by `properties`. They are
 * usually defined at construction time. Also, non-generic validations can be
 * implemented through `extendedValidation`, making possible to define validations
 * that are tied with an action itself.
 *
 * Inputs are created through {@link Input.create} using a
 * [syntactic sugar](https://en.wikipedia.org/wiki/Syntactic_sugar) that describes
 * their name and type (aka [TypeScript](https://www.typescriptlang.org/)), for instance:
 *
 * ```javascript
 * Input.create(&apos;myInput: bool&apos;)
 * ```
 *
 * Any input can be defined as a vector by using the short array syntax `[]`:
 *
 * ```javascript
 * Input.create(&apos;myInput: bool[]&apos;)
 * ```
 *
 * Additionally, you can specify if an input is optional (not required) by adding
 * `?` beside of the input name:
 *
 * ```javascript
 * Input.create(&apos;myInput?: bool[]&apos;)
 * ```
 *
 * You can also create inputs through a verbose (boilerplate) interface where each
 * of the options described above can be defined at construction time via properties:
 * ```javascript
 * Input.create(&apos;myInput&apos;, {type: &apos;bool&apos;, vector: true, required: false})
 * ```
 *
 * Since inputs are used by actions they can be created directly inside of an {@link Action} via
 * {@link Action.createInput} that internally triggers {@link Input.create} factory method:
 *
 * ```
 * class HelloWorld extends Mebo.Action{
 *   constructor(){
 *     super();
 *     // &#x2665; compact version
 *     this.createInput(&apos;myInputA?: bool[]&apos;);
 *
 *     // same as effect as above, but not so friendly to read
 *     this.addInput(Input.create(&apos;myInputB?: bool[]&apos;));
 *   }
 * }
 * ```
 *
 * To register a new input type, take a look at {@link Input.registerInput}
 *
 * &lt;h2&gt;Property Summary&lt;/h2&gt;
 *
 * Property Name | Description | Defined&amp;nbsp;by Default | Default Value
 * --- | --- | :---: | :---:
 * required | boolean telling if the value is required (defined at the construction time) \
 * | <img src="data/docs/toggle/on.png" title="yes"> | <img src="data/docs/value/true.png" title="true">
 * immutable | boolean telling if the data of the value cannot be altered \
 * overtime, however the value of the input can still be replaced by \
 * the input value setter, in order to prevent it you can set an input as \
 * {@link readOnly} | <img src="data/docs/toggle/on.png" title="yes"> | <img src="data/docs/value/true.png" title="true">
 * defaultValue | default value of the input | <img src="data/docs/toggle/on.png" title="yes"> | <img src="data/docs/value/null.png" title="null">
 * cliElementType | tells how the input should be presented via {@link CommandLine}: \
 * `&apos;option&apos;` or `&apos;argument&apos;` ({@link http://docopt.org}) | <img src="data/docs/toggle/on.png" title="yes"> | `&apos;option&apos;`
 * vector | boolean telling if the input holds a vector value (defined \
 * at the construction time) | <img src="data/docs/toggle/on.png" title="yes"> | <img src="data/docs/value/auto.png" title="auto">
 * hidden | boolean telling if the input is hidden from the {@link Reader}, \
 * therefore it should only be used internally | <img src="data/docs/toggle/off.png" title="no"> | <img src="data/docs/value/none.png" title="none">
 * autofill | key name about a value that may be under the {@link Session.autofill}. This \
 * value is used to initialize the input. It occurs when a session is assigned \
 * to an action ({@link Action.setSession}) | <img src="data/docs/toggle/off.png" title="no"> | <img src="data/docs/value/none.png" title="none">
 * description | description about the input, currently this information is displayed \
 * when an action is running through {@link CommandLine} | <img src="data/docs/toggle/off.png" title="no"> | <img src="data/docs/value/none.png" title="none">
 * cliShortOption | short version of the input name used to speficy when running \
 * through the {@link CommandLine} | <img src="data/docs/toggle/off.png" title="no"> | <img src="data/docs/value/none.png" title="none">
 *
 * &lt;br/&gt;The assignment of a property value can be done at construction time or through
 * the setter {@link Input.assignProperty}. A property value can be queried by the
 * getter {@link Input.property}. To add new properties to an input type, please take
 * a look at {@link Input.registerProperty}.
 */
class Input{

  /**
   * Creates an input
   *
   * @param {string} name - name of the input
   * @param {Object} [properties={}] - plain object containing the properties which
   * will be assigned to the {@link Input}
   * @param {function} [extendedValidation] - callback that can be defined to supply
   * custom validations to the {@link Input}
   */
  constructor(name, properties={}, extendedValidation=null){
    assert(TypeCheck.isString(name) &amp;&amp; name.length, &apos;name cannot be empty!&apos;);
    assert(TypeCheck.isPlainObject(properties), &quot;properties need to be defined as dict {&apos;key&apos;: value}&quot;);
    assert(extendedValidation === null || TypeCheck.isCallback(extendedValidation),
      &apos;extendedValidation needs to be defined as function(contextValue) or null&apos;);

    // validating reserved names
    assert(!([&apos;help&apos;].includes(name)), `Input name &apos;${name}&apos; is reserved, it cannot be used!`);

    // validating input name
    assert(name.length, &apos;input name cannot be empty!&apos;);
    assert((/^([\w_-])+$/gi).test(name), `Illegal input name: ${name}`);

    this[_name] = name;
    this[_readOnly] = false;
    this[_properties] = new Map();
    this[_lockedProperties] = new Set();
    this[_cache] = new Util.ImmutableMap();

    // defining custom properties that may override the default ones
    for (const propertyKey in properties){
      this.assignProperty(propertyKey, properties[propertyKey]);
    }

    // locking properties
    this.lockProperty(&apos;type&apos;);
    this.lockProperty(&apos;vector&apos;);
    this.lockProperty(&apos;defaultValue&apos;);

    this.setValue(this.property(&apos;defaultValue&apos;));
    this._extendedValidation = extendedValidation;
  }

  /**
   * Creates an input instance (also available as `Mebo.createInput`)
   *
   * @param {string} inputInterface - string followed by either the pattern `name: type`
   * or `name?: type` in case of optional {@link Input}. The type is case-insensitive
   * @param {Object} [properties={}] - plain object containing the properties which
   * will be assigned to the {@link Input}
   * @param {function} [extendedValidation] - callback that can be defined to supply
   * custom validations to the {@link Input}
   * @return {Input}
   *
   *
   * @example
   * // minimal
   * Input.create(&apos;inputName: numeric&apos;);
   *
   * @example
   * // full
   * Input.create(&apos;inputName: numeric&apos;, {min: 1, max: 5}, function(at){
   *  return new Promise((resolve, reject) =&gt; {
   *    if (this.valueAt(at) === 3)
   *      reject(new ValidationFail(&apos;Failed for some reason&apos;));
   *    else
   *      resolve(this.value());
   *  });
   * })
   */
  static create(inputInterface, properties={}, extendedValidation=null){
    const inputInterfaceParts = inputInterface.split(&apos;:&apos;);
    const propertiesFinal = Object.assign({}, properties);

    if (inputInterfaceParts.length === 2){
      for (let i=0, len=inputInterfaceParts.length; i &lt; len; ++i){
        inputInterfaceParts[i] = inputInterfaceParts[i].trim();
      }

      // not required syntax
      if (inputInterfaceParts[0].endsWith(&apos;?&apos;)){
        inputInterfaceParts[0] = inputInterfaceParts[0].slice(0, -1);
        propertiesFinal.required = false;
      }

      // vector syntax
      if (inputInterfaceParts[1].endsWith(&apos;[]&apos;)){
        inputInterfaceParts[1] = inputInterfaceParts[1].slice(0, -2);
        propertiesFinal.vector = true;
      }

      propertiesFinal.type = inputInterfaceParts[1];
    }
    else if (inputInterfaceParts.length &gt; 2){
      throw new Error(&quot;Invalid input interface, it should follow the pattern: &apos;name: type&apos;&quot;);
    }

    const InputTypeClass = this.registeredInput(propertiesFinal.type);

    // storing the input type in lower-case to keep the same convention
    // found in the registration
    propertiesFinal.type = propertiesFinal.type.toLowerCase();

    // creates a new instance
    if (!InputTypeClass){
      throw new Error(`Invalid input type: ${propertiesFinal.type}`);
    }

    return new InputTypeClass(inputInterfaceParts[0], propertiesFinal, extendedValidation);
  }

  /**
   * Returns if the value of the input is empty. This is used mainly by
   * the property `required=false` to know if the input does not have a value
   * assigned to it.
   *
   * @return {boolean} If the input is empty
   */
  isEmpty(){
    return TypeCheck.isNone(this.value()) || (this.property(&apos;vector&apos;) &amp;&amp;
      TypeCheck.isList(this.value()) &amp;&amp; this.value().length === 0);
  }

  /**
   * Returns if the value of the input is a vector. This information is defined
   * by the property `vector=true`
   *
   * @return {boolean} if the input is a vector
   */
  isVector(){
    return this.property(&apos;vector&apos;) === true;
  }

  /**
   * Returns if the value of the input is required. This information is defined
   * by the property `required=true`
   *
   * @return {boolean} if the input is required
   */
  isRequired(){
    return this.property(&apos;required&apos;) === true;
  }

  /**
   * Sets the input value by avoiding the overhead that may occur when the
   * same value is used across actions that have the input type, therefore
   * this method avoids the re-computation by copying the caches and value
   * associated with the source input to the current input. The cache will be
   * only copied if both source and target inputs have the `immutable` property
   * enabled (default true).
   *
   * @param {Input} sourceInput - input used as source to setup the current input
   * @param {null|number} [at] - index used when the target input is defined as vector to
   * tells which value should be used
   * @param {boolean} [cache=true] - tells if the cache will be copied as well
   */
  setupFrom(sourceInput, at=null, cache=true){
    assert(TypeCheck.isSameType(sourceInput, this), &apos;Inputs are not the same type!&apos;);

    if (at !== null &amp;&amp; !sourceInput.isVector()){
      throw new Error(`Can&apos;t use at, since the source input is not a vector`);
    }
    else if (at !== null &amp;&amp; this.isVector()){
      throw new Error(`Can&apos;t use at, from a source vector input to a target vector input`);
    }
    else if (this.isVector() &amp;&amp; !sourceInput.isVector()){
      throw new Error(`Source input is not a vector, can&apos;t setup to a vector target input`);
    }
    else if (at === null &amp;&amp; sourceInput.isVector() &amp;&amp; !this.isVector()){
      throw new Error(`Target input is not a vector, can&apos;t setup from a vector target input without supplying &apos;at&apos;`);
    }

    // transferring the value
    if (at === null){
      this.setValue(sourceInput.value());
    }
    else{
      this.setValue(sourceInput.value()[at]);
    }

    // transferring the cache to the current input
    if (cache &amp;&amp; sourceInput.property(&apos;immutable&apos;) &amp;&amp; this.property(&apos;immutable&apos;)){
      assert(sourceInput.cache() instanceof Util.ImmutableMap);

      const sourceCache = sourceInput.cache();
      if (at === null){
        for (const key of sourceCache.keys()){
          this.cache().set(key, sourceCache.get(key));
        }
      }
      else{
        const indexToken = `(${at})`;
        for (const key of sourceCache.keys()){
          if (key.endsWith(indexToken)){
            this._setToCache(key.slice(0, -indexToken.length), sourceCache.get(key));
          }
        }
      }
    }
  }

 /**
  * Returns the cache used by the input
  *
  * This method is called by ({@link setupFrom}) to setup the input based on an
  * already existing input
  *
  * @return {ImmutableMap}
  */
  cache(){
    return this[_cache];
  }

  /**
   * Forces to flush the internal input cache
   */
  clearCache(){
    this.cache().clear();
  }

  /**
   * Executes the input validations ({@link _validation}), in case of a failed
   * validation then an exception of type {@link ValidationFail} is raised
   *
   * @return {Promise&lt;*&gt;} Returns the value of the input
   */
  async validate(){

    try{
      // required check
      if (this.isEmpty()){
        if (this.isRequired() !== false){
          throw new ValidationFail(&apos;Input is required, it cannot be empty!&apos;, Input.errorCodes[0]);
        }
      }

      // vector check
      else if (this.isVector() &amp;&amp; !TypeCheck.isList(this.value())){
        throw new ValidationFail(&apos;Input needs to be a vector!&apos;, Input.errorCodes[1]);
      }

      // otherwise perform the asynchronous validations
      else{
        const validationPromises = [];
        const length = this.isVector() ? this.value().length : 1;
        for (let i=0; i &lt; length; ++i){
          // setting the context index
          const at = this.isVector() ? i : null;
          validationPromises.push(this._validation(at));

          // running extended validations
          if (TypeCheck.isCallback(this._extendedValidation)){
            validationPromises.push(this._extendedValidation.call(this, at));
          }
        }

        // running generic validations
        await Promise.all(validationPromises);
      }
    }
    catch(err){
      // including the input name to the validation fail
      if (err instanceof ValidationFail){
        err.inputName = this.name();

        // disabling the output when input is marked as hidden
        if (this.property(&apos;hidden&apos;)){
          err.output = false;
        }
      }

      throw err;
    }

    return true;
  }

  /**
   * Returns the property value for the input property name
   *
   * @param {string} name - name of the property
   * @return {Promise&lt;*&gt;} The value of the property (or the defaultValue in case of the
   * property does not exist)
   */
  property(name){
    assert(TypeCheck.isString(name), &apos;property name needs to be defined as string&apos;);

    if (this[_properties].has(name)){
      return this[_properties].get(name);
    }

    // checking if the property is valid
    const allRegisteredProperties = Input._allRegisteredProperties(this.constructor);
    if (allRegisteredProperties.has(name)){
      return allRegisteredProperties.get(name);
    }

    throw new Error(`Property ${name} is not registered!`);
  }

  /**
   * Sets a property to the input. In case the property already exists then the value
   * is going to be overridden. By default the only properties that can be modified are
   * the ones found under {@link Input.registeredInputNames}. However you can
   * assign a non-registered property by enabling `loose` parameter.
   *
   * Property values can be locked, therefore preventing modifications
   * ({@link Input.lockProperty}).
   *
   * @param {string} name - name of the property
   * @param {*} value - value for the property
   * @param {boolean} [loose=false] - when true lets to assign a property that is not
   * registered to the input ({@link Input.registeredInputNames})
   */
  assignProperty(name, value, loose=false){
    assert(TypeCheck.isString(name), &apos;property name needs to be defined as string&apos;);

    // checking if input is read-only
    if (this.readOnly()){
      throw new Error(`Input ${this.name()} is read only, cannot be modified!`);
    }

    // checking if property is valid
    if (!loose &amp;&amp; !Input._allRegisteredProperties(this.constructor).has(name)){
      throw new Error(`Property ${name} is not registered!`);
    }

    // checking if property has been locked
    if (this[_lockedProperties].has(name)){
      throw new Error(`Property ${name} is locked!`);
    }

    this[_properties].set(name, value);

    this.clearCache();
  }

  /**
   * Prevents a property value to be modified by {@link Input.assignProperty}
   *
   * @param {string} name - name of the property
   * @param {boolean} [lock=true] - if true it locks the property otherwise
   * it removes the lock from the property
   */
  lockProperty(name, lock=true){

    // checking if input is read-only
    if (this.readOnly()){
      throw new Error(`Input ${this.name()} is read only, cannot be modified!`);
    }

    if (lock){
      this[_lockedProperties].add(name);
    }
    else{
      this[_lockedProperties].delete(name);
    }
  }

  /**
   * Returns a boolean telling if the property is locked ({@link Input.lockProperty})
   *
   * @param {string} name - name of the property
   * @return {boolean}
   */
  isPropertyLocked(name){
    return this[_lockedProperties].has(name);
  }

  /**
   * Returns a boolean telling if the input property name is assigned to the input
   *
   * @param {string} name - name of the property
   * @return {boolean}
   */
  hasProperty(name){
    assert(TypeCheck.isString(name), &apos;property name needs to be defined as string&apos;);

    return Input._allRegisteredProperties(this.constructor).has(name) || this[_properties].has(name);
  }

  /**
   * Returns a list containing the property names assigned to the input
   *
   * @return {Array&lt;string&gt;}
   */
  propertyNames(){
    return [...new Set([...this[_properties].keys(),
      ...Input._allRegisteredProperties(this.constructor).keys(),
    ])];
  }

  /**
   * Sets the value of the input
   *
   * @param {*} value - value that should be set to the input
   */
  setValue(value){

    // checking if input is read-only
    if (this.readOnly()){
      throw new Error(`Input ${this.name()} is read only, cannot be modified!`);
    }

    // Due the overhead that may occur on going through recursively and freezing
    // the whole hierarchy of the value, it freezes only value itself. In case
    // this is not enough consider in changing it to perform a deep-freeze instead
    this._value = (!this.property(&apos;immutable&apos;) || TypeCheck.isNone(value)) ||
      value instanceof Buffer ? value : Object.freeze(value);

    // flushing the cache when a new value is set
    this.clearCache();
  }

  /**
   * Returns the value of the input
   *
   * @return {*}
   */
  value(){
    return this._value;
  }

  /**
   * Returns the name of the input which is defined at construction time (inputs cannot
   * be renamed)
   *
   * @return {string}
   */
  name(){
    return this[_name];
  }

  /**
   * Returns if the input is serializable
   *
   * This method should be re-implemented by derived classes to tell if the input can be
   * serialized (default true).
   *
   * In case of a serializable input, the methods {@link Input._encode} and {@link Input._decode}
   * are expected to be implemented.
   *
   * @return {boolean}
   */
  isSerializable(){
    return true;
  }

  /**
   * Changes the read-only state of the input. A read-only input cannot have its
   * value and properties modified. It&apos;s mainly used during the execution of the {@link Action}
   * where all inputs are assigned as read-only, therefore when the execution is completed
   * the inputs are restored with the original read-only value assigned before
   * the execution of the action
   *
   * @param {boolean} enable - tells if a input is read-only
   */
  setReadOnly(enable){
    this[_readOnly] = enable;
  }

  /**
   * Returns a boolean telling if the input is in read-only mode. A read-only input
   * cannot have its value and properties modified
   *
   * @return {boolean}
   */
  readOnly(){
    return this[_readOnly];
  }

  /**
   * Decodes a value represented as string to the type that is compatible with the input.
   * This method is called by the {@link Handler} or when an action is loaded/created using
   * {@link Action.fromJSON}/{@link Action.createFromJSON}. In case the input
   * is defined as vector then the value can be defined using an array encoded in JSON.
   * The parsed value gets returned and assigned to the input as well (you can control this
   * by the `assignValue` argument).
   *
   * The implementation of the decoding is done by the method {@link Input._decode}.
   * To know if an input supports decoding checkout the {@link Input.isSerializable}.
   *
   * To know how the serialization is done for the inputs bundled with
   * Mebo take a look at {@link Reader} documentation.
   *
   * @param {string} value - string containing the serialized data
   * @param {boolean} [assignValue=true] - tells if the parsed value should be assigned
   * to the input
   * @return {*}
   */
  parseValue(value, assignValue=true){
    assert(this.isSerializable(), &apos;parsing not supported!&apos;);
    assert(TypeCheck.isString(value), &apos;value needs to be defined as string or string array&apos;);

    let result;

    // empty string is treated as null
    if (value.length === 0){
      result = null;
    }
    else if (this.isVector()){
      const decodedValue = [];

      // it may worth to allow passing an Array directly as valid value as well, so it would
      // avoid the overhead of encoding/decoding JSON when using it internally. Let&apos;s keep
      // an eye on it for now.
      const parsedValue = JSON.parse(value);

      assert(TypeCheck.isList(parsedValue), &apos;Could not parse, unexpected data type&apos;);
      for (const parsedItem of parsedValue){
        let finalParsedItem = parsedItem;

        // casting the parsed value to a string if necessary
        if (!TypeCheck.isString(parsedItem) &amp;&amp; parsedItem !== null){
          finalParsedItem = String(parsedItem);
        }

        // empty string is treated as null
        if (finalParsedItem === &apos;&apos;){
          finalParsedItem = null;
        }

        // decoding the value
        decodedValue.push(finalParsedItem ? this.constructor._decode(finalParsedItem) : null);
      }

      result = decodedValue;
    }
    else{
      result = this.constructor._decode(value);
    }

    if (assignValue){
      this.setValue(result);
    }

    return result;
  }

  /**
   * This method should return a string representation about the current value in a way that
   * can be recovered later through {@link parseValue}.
   *
   * The encode implementation is done by the  method {@link Input._encode}.
   * To know if an input supports serialization checkout the {@link Input.isSerializable}.
   *
   * Also, in case you want to know the serialization form for the inputs bundled with
   * Mebo checkout {@link Reader}.
   *
   * @return {Promise&lt;string&gt;}
   */
  async serializeValue(){
    assert(this.isSerializable(), &apos;serialization not supported!&apos;);

    // making sure the value can be serialized without any issues
    await this.validate();

    // serializing the value
    let result;

    if (this.isEmpty()){
      result = &apos;&apos;;
    }
    else if (this.isVector()){
      const encodedValue = [];

      for (const item of this.value()){
        encodedValue.push(this.constructor._encode(item));
      }

      return JSON.stringify(encodedValue);
    }
    else{
      result = this.constructor._encode(this.value());
    }

    return String(result);
  }

  /**
   * Decodes the input value from the string representation ({@link Input._encode}) to the
   * data type of the input. This method is called internally during {@link Input.parseValue}
   *
   * @param {string} value - encoded value
   * @return {*}
   * @protected
   */
  static _decode(value){
    assert(TypeCheck.isString(value), &apos;value needs to be defined as string&apos;);

    return value;
  }

  /**
   * Encodes the input value to a string representation that can be later decoded
   * through {@link Input._decode}. This method is called internally during the
   * {@link serializeValue}
   *
   * @param {*} value - value that should be encoded to a string
   * @return {string}
   * @protected
   */
  static _encode(value){
    return String(value);
  }

  /**
   * Registers a new input type to the available inputs
   * (also available as `Mebo.registerInput`)
   *
   * @param {Input} inputClass - input implementation that will be registered
   * @param {string} [name] - string containing the registration name for the
   * input. In case of an empty string, the registration is done by using the name
   * of the type (this information is stored in lowercase)
   */
  static registerInput(inputClass, name=&apos;&apos;){
    assert(TypeCheck.isSubClassOf(inputClass, Input), &apos;Invalid input type!&apos;);
    assert(TypeCheck.isString(name), &apos;Invalid optional registration name!&apos;);

    const nameFinal = ((name === &apos;&apos;) ? inputClass.name : name).toLowerCase();

    // validating name
    assert((/^([\w_\.\-])+$/gi).test(nameFinal), `Illegal input name: ${nameFinal}`); // eslint-disable-line no-useless-escape

    this._registeredInputs.set(nameFinal, inputClass);
  }

  /**
   * Returns the input type based on the registration name
   *
   * @param {string} name - name of the registered input type
   * @return {Input|null}
   */
  static registeredInput(name){
    assert(TypeCheck.isString(name), &apos;Invalid name!&apos;);

    const normalizedName = name.toLowerCase();

    if (this._registeredInputs.has(normalizedName)){
      return this._registeredInputs.get(normalizedName);
    }

    return null;
  }

  /**
   * Returns a list containing the names of the registered input types
   *
   * @return {Array&lt;string&gt;}
   */
  static registeredInputNames(){
    return [...this._registeredInputs.keys()];
  }

  /**
   * This method enforces the context of the value being queried.
   * Since the input can behave as vector it makes sure that when that&apos;s
   * the case the index must be supplied otherwise it raises an exception.
   * Use this method when you need to query the value through validations where
   * the index (at) is always passed to them, whether if the input is vector
   * or scalar
   *
   * @param {number} [index] - used when the input is set to a vector to tell the
   * index of the value
   * @return {*}
   */
  valueAt(index=null){
    if (this.isVector()){
      assert(index !== null, &apos;Could not determine the index of the vector&apos;);
      return this.value()[index];
    }

    return this.value();
  }

  /**
   * Registers a property for the input type (also available as `Mebo.registerProperty`)
   *
   * ```
   * // example of registering a new property
   * Mebo.registerProperty(&apos;text&apos;, &apos;myCustomProperty&apos;, &apos;A initial value if necessary&apos;)
   * ```
   *
   * @param {string|Input} inputClassOrRegisteredName - registered input name or input class
   * in which the property should be registered
   * @param {string} name - name of the property (in case the property name already
   * exists than it going to be overridden for the input type)
   * @param {*} [initialValue] - optional initial value for the property (undefined by default)
   */
  static registerProperty(inputClassOrRegisteredName, name, initialValue){
    assert(TypeCheck.isString(name), &apos;property name needs to be defined as string&apos;);
    assert(name.length, &apos;property name cannot be empty&apos;);

    const inputType = this._resolveInputType(inputClassOrRegisteredName);

    // appending to the existing registered properties
    if (!this._registeredProperties.has(inputType)){
      this._registeredProperties.set(inputType, new Map());
    }

    this._registeredProperties.get(inputType).set(name, initialValue);

    // resetting the properties caches
    this._propertiesCache.clear();
  }

  /**
   * Returns a list about all registered property names including the inherited ones for
   * the input type
   *
   * ```
   * // returning all properties for an input type (using &apos;numeric&apos; as example)
   * Mebo.Input.registeredPropertyNames(&apos;numeric&apos;);
   * ```
   *
   * @param {string|Input} inputClassOrRegisteredName - registered input name or input class
   * @return {Array&lt;string&gt;}
   */
  static registeredPropertyNames(inputClassOrRegisteredName){
    const inputType = this._resolveInputType(inputClassOrRegisteredName);

    return [...this._allRegisteredProperties(inputType).keys()];
  }

  /**
   * Use this method to implement generic validations
   * for your input implementation. In case any validation fails this method
   * should return a {@link ValidationFail} (This method is called when the
   * validations are perform through {@link Input.validate})
   *
   * @param {null|number} at - index used when input has been created as a vector that
   * tells which value should be used
   * @return {Promise&lt;*&gt;} Returns the value of the input
   * @protected
   */
  async _validation(at){
    return this.valueAt(at);
  }

  /**
   * Auxiliary method used internally by input implementations to check if the key
   * is under the cache
   *
   * @param {string} name - name of the key
   * @param {null|number} [at] - used when the input is set to a vector to tell the
   * index of the value
   * @return {boolean}
   * @protected
   */
  _isCached(name, at=null){
    return this.cache().has(this._cacheEntry(name, at));
  }

  /**
   * Auxiliary method used internally by input implementations to set a value to
   * the cache
   *
   * @param {string} name - name of the key
   * @param {*} value - value that should be set in the cache
   * @param {null|number} [at] - used when the input is set to a vector to tell the
   * index of the value
   * @protected
   */
  _setToCache(name, value, at=null){
    this.cache().set(this._cacheEntry(name, at), value);
  }

  /**
   * Auxiliary method used internally by the input implementations to get a value
   * from the cache
   *
   * @param {string} name - name of the key
   * @param {null|number} [at] - used when the input is set to a vector to tell the
   * index of the value
   * @return {*}
   * @protected
   */
  _getFromCache(name, at=null){
    return this.cache().get(this._cacheEntry(name, at));
  }

  /**
   * Returns the cache entry based on the name and index (at)
   *
   * @param {string} name - name of the key
   * @param {number|null} at - used when the input is set to a vector to tell the
   * @return {string}
   *
   * @private
   */
  _cacheEntry(name, at){
    if (this.isVector()){
      assert(at !== null, &apos;Could not determine the index of the vector&apos;);
    }

    return (this.isVector()) ? `${name}(${at})` : `${name}()`;
  }

  /**
   * Auxiliary method that resolves the registered input type based
   *
   * @param {string|Input} inputClassOrRegisteredName - registered input name or input class
   * @return {Input}
   * @private
   */
  static _resolveInputType(inputClassOrRegisteredName){
    if (TypeCheck.isSubClassOf(inputClassOrRegisteredName, Input) || inputClassOrRegisteredName === Input){
      return inputClassOrRegisteredName;
    }

    return this.registeredInput(inputClassOrRegisteredName);
  }

  /**
   * Auxiliary method that collects all available registered property names for the input type
   * and returns them
   *
   * @param {Input} inputType - input class that should be used to collect the properties
   * @return {Array&lt;string&gt;}
   * @private
   */
  static _allRegisteredProperties(inputType){

    if (!this._propertiesCache.has(inputType)){
      let currentClass = inputType;
      const inputProperties = new Map();

      while (currentClass.name !== &apos;&apos;){
        if (this._registeredProperties.has(currentClass)){
          for (const [propertyName, propertyValue] of this._registeredProperties.get(currentClass)){
            // if a property has been overriding by a sub class then skip it
            if (!inputProperties.has(propertyName)){
              inputProperties.set(propertyName, propertyValue);
            }
          }
        }
        currentClass = Object.getPrototypeOf(currentClass);
      }

      this._propertiesCache.set(inputType, inputProperties);
    }

    return this._propertiesCache.get(inputType);
  }

  // codes used by error validations
  static errorCodes = [
    &apos;28a03a60-a405-4737-b94d-2b695b6ce156&apos;,
    &apos;e03709a0-6c31-4a33-9f63-fa751948a6cb&apos;,
  ];

  static _propertiesCache = new Map();
  static _registeredInputs = new Map();
  static _registeredProperties = new Map();
}

// registering properties
Input.registerProperty(Input, &apos;required&apos;, true);
Input.registerProperty(Input, &apos;type&apos;, true);
Input.registerProperty(Input, &apos;immutable&apos;, true);
Input.registerProperty(Input, &apos;defaultValue&apos;, null);
Input.registerProperty(Input, &apos;vector&apos;, false);
Input.registerProperty(Input, &apos;hidden&apos;);
Input.registerProperty(Input, &apos;autofill&apos;);
Input.registerProperty(Input, &apos;description&apos;);

module.exports = Input;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
