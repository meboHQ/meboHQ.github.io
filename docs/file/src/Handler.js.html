<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/Handler.js | Mebo</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
<link data-ice="userStyle" rel="stylesheet" href="user/css/0-style.css">
<link rel="icon" type="image/png" sizes="64x64" href="data/icon.png?v=1"><script async defer src="https://buttons.github.io/buttons.js"></script></head>
<body class="layout-container" data-ice="rootContainer">

<header><a href="./index.html"><img src="data/icon.png?v=1" id="meboSmallLogo" width="40" height="40" align="top"/></a>
  <a href="./">Home</a>
  <a href="./manual/overview/INTRODUCTION.html" data-ice="manualHeaderLink">Intro</a>
  
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/meboHQ/mebo" class="repo-url-github">Mebo&nbsp;GitHub</a>
  <div class="search-box">
  <span>
    <img src="data/docs/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Action.js~Action.html">Action</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Handler.js~Handler.html">Handler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Input.js~Input.html">Input</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Metadata.js~Metadata.html">Metadata</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Reader.js~Reader.html">Reader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Session.js~Session.html">Session</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Settings.js~Settings.html">Settings</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Tasks.js~Tasks.html">Tasks</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Writer.js~Writer.html">Writer</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">Errors</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Errors/Conflict.js~Conflict.html">Conflict</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Errors/NoContent.js~NoContent.html">NoContent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Errors/NotFound.js~NotFound.html">NotFound</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Errors/ValidationFail.js~ValidationFail.html">ValidationFail</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">Handlers</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Handlers/Cli.js~Cli.html">Cli</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Handlers/Web.js~Web.html">Web</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">Inputs</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/Any.js~Any.html">Any</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/BaseText.js~BaseText.html">BaseText</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/Bool.js~Bool.html">Bool</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/Buf.js~Buf.html">Buf</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/Email.js~Email.html">Email</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/FilePath.js~FilePath.html">FilePath</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/Hash.js~Hash.html">Hash</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/Hex.js~Hex.html">Hex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/Ip.js~Ip.html">Ip</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/Numeric.js~Numeric.html">Numeric</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/Stream.js~Stream.html">Stream</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/Text.js~Text.html">Text</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/Timestamp.js~Timestamp.html">Timestamp</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/UUID.js~UUID.html">UUID</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/Url.js~Url.html">Url</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/Version.js~Version.html">Version</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">Readers</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Readers/CliArgs.js~CliArgs.html">CliArgs</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Readers/WebRequest.js~WebRequest.html">WebRequest</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">Utils</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Utils/ImmutableMap.js~ImmutableMap.html">ImmutableMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Utils/LruCache.js~LruCache.html">LruCache</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">Writers</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Writers/CliOutput.js~CliOutput.html">CliOutput</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Writers/WebResponse.js~WebResponse.html">WebResponse</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/Handler.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">const assert = require(&apos;assert&apos;);
const EventEmitter = require(&apos;events&apos;);
const TypeCheck = require(&apos;js-typecheck&apos;);
const minimatch = require(&apos;minimatch&apos;);
const Session = require(&apos;./Session&apos;);
const Action = require(&apos;./Action&apos;);
const Metadata = require(&apos;./Metadata&apos;);
const Reader = require(&apos;./Reader&apos;);
const Writer = require(&apos;./Writer&apos;);
const Utils = require(&apos;./Utils&apos;);

// symbols used for private instance variables to avoid any potential clashing
// caused by re-implementations
const _session = Symbol(&apos;session&apos;);
const _metadata = Symbol(&apos;metadata&apos;);


/**
 * A handler is used to bridge an execution method to Mebo.
 *
 * The data used to perform the execution of action through a handler
 * ({@link Handler.runAction}) is parsed using a reader {@link Reader}.
 *
 * The result of a handler is done through a {@link Writer}. Writers are designed
 * to support reporting a success output and an error output as well. The way the
 * result is serialized is determined by the writer implementation
 * ({@link Writer._successOutput}, {@link Writer._errorOutput}). All writers
 * shipped with Mebo have support for streams where in case of any readable stream
 * or buffer value they are piped to the output, otherwise the result is encoded
 * using JSON.
 *
 * Both reader and writer can be customized through options that can be either
 * defined through the action&apos;s metadata or directly through the handler. If you would
 * like to know more about the available options check out the respective
 * {@link Reader} &amp; {@link Writer} documentation for the handler implementation
 * you are interested.
 *
 * Defining options through actions (detailed information can be found at
 * {@link Metadata}):
 * ```
 * @Mebo.register(&apos;myAction&apos;)
 * class MyAction extends Mebo.Action{
 *    constructor(){
 *      super();
 *
 *      // change &apos;name&apos; for the registration name of the handler you
 *      // want to define the read options
 *      this.setMeta(&apos;handler.name.readOptions&apos;, {
 *        someReadOption: true
 *      });
 *    }
 *
 *    async _perform(data){
 *      // ...
 *    }
 *
 *    _finalize(err, value){
 *
 *      // change &apos;name&apos; for the registration name of the handler you
 *      // want to define the write options
 *      if (!err){
 *        // defining the write option inside of the _finalize to keep _perform as
 *        // abstract as possible. Since, _finalize is always called (even during
 *        // an error) after the execution of the action, it provides a way to
 *        // hook and define custom metadata related with the result.
 *        this.setMeta(&apos;handler.name.writeOptions&apos;, {
 *            someWriteOption: 10,
 *        });
 *      }
 *
 *      super._finalize(err, value);
 *    }
 * }
 * ```
 *
 * Defining options directly through the handler:
 * ```
 * // read options
 * myHandler.runAction(&apos;myAction&apos;, {
 *  someReadOption: true,
 * })
 *
 * // write options
 * myHandler.output(value, {
 *  someWriteOption: 10,
 * })
 * ```
 *
 * Handlers are created by their registration name ({@link Handler.register}),
 * the creation is done by {@link Handler.create}:
 *
 * ```
 * // creating a handle based on the handler registration name
 * const handler = Mebo.Handler.create(&apos;myHandler&apos;);
 *
 * // loading the parsed information to the action
 * handler.runAction(&apos;actionName&apos;).then((result) =&gt; {
 *
 *    // success output
 *    handler.output(result);
 *
 * // error output
 * }).catch((err) =&gt; {
 *    handler.output(err);
 * });
 * ```
 *
 * **Tip:** You can set the env variable `NODE_ENV=development` to get the
 * traceback information included in the error output.
 */
class Handler{

  /**
   * Creates a Handler
   */
  constructor(){
    this[_metadata] = new Metadata();
  }

  /**
   * Associates a {@link Session} with the handler. The session assigned to
   * the handler is cloned during the assignment ({@link Session.clone}).
   *
   * @param {Session} session - session object
   */
  setSession(session){
    assert(session instanceof Session, &apos;Invalid session!&apos;);

    this[_session] = session.clone();
  }

  /**
   * Returns the session
   *
   * @return {Session}
   */
  session(){

    // creating session on demanding
    if (!this[_session]){
      this[_session] = new Session();
    }

    return this[_session];
  }

  /**
   * Returns a value under the handler&apos;s metadata.
   *
   * @param {string} path - path about where the value is localized (the levels
   * must be separated by &apos;.&apos;). In case of an empty string it returns the
   * entire metadata. The path can be defined using `option vars`
   * ({@link Metadata.optionVar}).
   * @param {*} [defaultValue] - default value returned in case a value was
   * not found for the path
   * @return {*}
   */
  meta(path, defaultValue=undefined){
    assert(TypeCheck.isString(path), &apos;path needs to be defined as string&apos;);

    return this[_metadata].value(path, defaultValue);
  }

  /**
   * Sets a value to the handler&apos;s metadata.
   *
   * Detailed information about the metadata support can be found at
   * {@link Metadata}.
   *
   * @param {string} path - path about where the value should be stored under the metadata
   * (the levels must be separated by &apos;.&apos;). The path can be defined using `option vars`
   * ({@link Metadata.optionVar}).
   * @param {*} value - value that is going to be stored under the collection
   * @param {boolean} [merge=true] - this option is used to decide in case of the
   * last level is already existing under the collection, if the value should be
   * either merged (default) or overridden.
   */
  setMeta(path, value, merge=true){
    assert(TypeCheck.isString(path), &apos;path needs to be defined as string&apos;);

    this[_metadata].setValue(path, value, merge);
  }

  /**
   * Executes an action through the handler.
   *
   * This process is done by creating an action that loads the information
   * parsed by the {@link Reader}.
   *
   * After the construction of the action it looks for reading options that can
   * be defined as part of the action&apos;s metadata ({@link Action.metadata}) and
   * when found they are passed to the reader. After the execution of the action
   * it looks again inside of the action&apos;s metadata for writing options, which
   * are later used during the output ({@link Handler.output}). To know how
   * to define action&apos;s metadata for the handler take a look at the initial
   * documentation about the {@link Handler}.
   *
   * @param {string} actionName - registered action name that should be executed
   * @param {Object} options - plain object containing the options that is passed
   * to the {@link Reader}.
   * for the handler should be fetched.
   * @return {*} result of the action
   */
  async runAction(actionName, options={}){

    const action = Action.create(actionName, this.session());

    // collecting read options from the action
    let actionHandlerName = this._actionHandlerName(action);

    if (actionHandlerName.length){
      this.setMeta(
        &apos;readOptions&apos;,
        action.meta(`handler.${actionHandlerName}.readOptions`, {}),
      );
    }

    // executing action
    let result;
    await this._load(action, options);
    try{
      result = await action.run();
    }
    finally{

      // handler metadata can be defined later during
      // for this reason querying it again if it was not defined previously
      if (!actionHandlerName.length){
        actionHandlerName = this._actionHandlerName(action);
      }

      // collecting write options from the action
      if (actionHandlerName.length){
        this.setMeta(
          &apos;writeOptions&apos;,
          action.meta(`handler.${actionHandlerName}.writeOptions`, {}),
        );
      }
    }

    return result;
  }

  /**
   * Results a value through the handler.
   *
   * In case the value is an exception then it&apos;s treated as {@link Writer._errorOutput}
   * otherwise the value is treated as {@link Writer._successOutput}.
   *
   * When an action is executed through the handler ({@link Handler.runAction})
   * it can define writing options that are used by the output. These
   * options are stored under the {@link Handler.metadata} where any options passed
   * directly to the output method override them.
   *
   * If `finalizeSession` is enabled (default) the {@link Handler.session} gets finalized
   * at the end of the output process.
   *
   * By default the {@link Writer._errorOutput} tries to handle the error as output.
   * However you can tell a writer to do not handle specific errors, by doing that the writer
   * will raise the errors instead of trying to handle them. This can be achieved
   * by having `output` defined as member of the error (`error.output = false`),
   * further information can be found at the error output documentation
   * ({@link Writer._errorOutput}).
   *
   * In case of any error raised during the output process the handler emits the signal
   * {@link Handler.onErrorDuringOutput}.
   *
   * @param {*} value - raw value that should be resulted by the handler
   * @param {Object} [options] - plain object containing options that should be used
   * by the output where each handler implementation contains their own set of options.
   * @param {boolean} [finalizeSession=true] - tells if it should finalize the session
   * ({@link Session.finalize})
   */
  output(value, options={}, finalizeSession=true){

    const writeOptions = Utils.deepMerge(this.meta(&apos;writeOptions&apos;, {}), options);
    const writer = this._createWriter(value, writeOptions);
    try{
      writer.serialize();
    }
    catch(err){
      this._emitOutputError(err);
    }

    // the session finalization runs in parallel, since it does secondary tasks
    // (such as clean-up, logging, etc...) there is no need to await for that
    if (finalizeSession){
      this.session().finalize().then(() =&gt; {
        // runaway promise
        return null;
      }).catch((err) =&gt; {
        this._emitOutputError(err);
      });
    }
  }

  /**
   * Creates a handler based on the registered name
   *
   * Alternatively this method can be called directly from Mebo as `Mebo.Handler.create(...)`
   *
   * Also, the handler name gets included in the session as arbitrary data, it can be
   * retrieved through &apos;handler&apos;. This name follows the registration pattern where this
   * value is represented in lowercase internally:
   * ```
   * Session.get(&apos;handler&apos;);
   * ```
   * @param {string} handlerName - registered handler name
   * @param {string} [mask=&apos;*&apos;] - optional mask that supports a glob syntax used
   * to match a custom registered handler (it allows to have
   * custom handler implementations for specific masks)
   * @param {...args} args - custom args passed to the constructor during factoring
   * @return {Handler}
   */
  static create(handlerName, mask=&apos;*&apos;, ...args){
    const HandlerClass = this.registeredHandler(handlerName, mask);

    // creates a new instance
    const handler = new HandlerClass(...args);

    // adding the handler name used to factory the handler under the metadata
    const normalizedHandlerName = handlerName.toLowerCase();
    handler.setMeta(&apos;handler.name&apos;, normalizedHandlerName);
    handler.setMeta(&apos;handler.mask&apos;, mask.toLowerCase());

    // also, adding the handler name under the session arbitrary data
    handler.session().set(&apos;handler&apos;, normalizedHandlerName);

    return handler;
  }

  /**
   * Register an {@link Handler} type to the available handlers
   *
   * @param {Handler} handlerClass - handler implementation that will be registered
   * @param {string} [handlerName] - string containing the registration name for the
   * handler. In case of an empty string, the registration is done by using the name
   * of the type (this information is stored in lowercase)
   * @param {string} [handlerMask=&apos;*&apos;] - optional mask that supports a glob syntax used
   * to match a custom registered handler (it allows to have
   * custom handler implementations for specific masks)
   */
  static register(handlerClass, handlerName=&apos;&apos;, handlerMask=&apos;*&apos;){
    assert(TypeCheck.isSubClassOf(handlerClass, Handler), &apos;Invalid handler type!&apos;);
    const handlerNameFinal = ((handlerName === &apos;&apos;) ? handlerClass.name : handlerName);

    this._register(this._registeredHandlers, handlerClass, handlerNameFinal, handlerMask);
  }

  /**
   * Register a {@link Reader} for the handler
   *
   * @param {Reader} readerClass - reader class
   * @param {string} handlerName - registered handler name
   * @param {string} [handlerMask=&apos;*&apos;] - optional mask that supports a glob syntax used
   * to match a custom registered handler (it allows to have
   * custom handler implementations for specific masks)
   */
  static registerReader(readerClass, handlerName, handlerMask=&apos;*&apos;){
    assert(TypeCheck.isSubClassOf(readerClass, Reader), &apos;Invalid reader type&apos;);

    this._register(this._registeredReaders, readerClass, handlerName, handlerMask);
  }

  /**
   * Register a {@link Writer} for the handler
   *
   * @param {Writer} writerClass - writer class
   * @param {string} handlerName - registered handler name
   * @param {string} [handlerMask=&apos;*&apos;] - optional mask that supports a glob syntax used
   * to match a custom registered handler (it allows to have
   * custom handler implementations for specific masks)
   */
  static registerWriter(writerClass, handlerName, handlerMask=&apos;*&apos;){
    assert(TypeCheck.isSubClassOf(writerClass, Writer), &apos;Invalid writer type&apos;);

    this._register(this._registeredWriters, writerClass, handlerName, handlerMask);
  }

  /**
   * Returns the registered handler
   *
   * (it can be also done via {@link Handler.registeredHandler}).
   *
   * @param {string} handlerName - registered handler name
   * @param {string} [handlerMask] - optional handler mask
   * @return {Handler}
   */
  static get(handlerName, handlerMask=&apos;*&apos;){
    return this.registeredHandler(handlerName, handlerMask);
  }

  /**
   * Returns the registered handler
   *
   * (it can be also done via {@link Handler.get})
   *
   * @param {string} handlerName - name of the registered handler type
   * @param {string} [handlerMask=&apos;*&apos;] - optional mask that supports a glob syntax used
   * to match a custom registered handler
   * @return {Handler}
   */
  static registeredHandler(handlerName, handlerMask=&apos;*&apos;){
    const result = this._registered(this._registeredHandlers, handlerName, handlerMask);

    if (result){
      return result;
    }

    throw new Error(`Handler ${handlerName} is not registered!`);
  }

  /**
   * Returns the reader registered for the handler
   *
   * @param {string} handlerName - name of the registered handler type
   * @param {string} [handlerMask=&apos;*&apos;] - optional mask that supports a glob syntax used
   * to match a custom registered handler
   * @return {Reader}
   */
  static registeredReader(handlerName, handlerMask=&apos;*&apos;){
    const result = this._registered(this._registeredReaders, handlerName, handlerMask);

    if (result){
      return result;
    }

    throw new Error(`Reader is not registered for handler ${handlerName}!`);
  }

  /**
   * Returns the writer registered for the handler
   *
   * @param {string} handlerName - name of the registered handler type
   * @param {string} [handlerMask=&apos;*&apos;] - optional mask that supports a glob syntax used
   * to match a custom registered handler
   * @return {Writer}
   */
  static registeredWriter(handlerName, handlerMask=&apos;*&apos;){
    const result = this._registered(this._registeredWriters, handlerName, handlerMask);

    if (result){
      return result;
    }

    throw new Error(`Writer is not registered for handler ${handlerName}!`);
  }

  /**
   * Returns a list containing the names of the registered handler types
   *
   * @return {Array&lt;string&gt;}
   */
  static registeredHandlerNames(){
    const result = new Set();

    for (const [registeredHandleName] of this._registeredHandlers.keys()){
      result.add(registeredHandleName);
    }

    return [...result];
  }

  /**
   * Returns a list of registered handler makers for the input handler name
   *
   * @param {string} handlerName - registered handler name
   * @return {Array&lt;string&gt;}
   */
  static registeredHandlerMasks(handlerName){
    const result = [];

    const normalizedName = handlerName.toLowerCase();

    for (const [registeredHandleName, registeredMask] of this._registeredHandlers.keys()){
      if (registeredHandleName === normalizedName){
        result.push(registeredMask);
      }
    }

    return result;
  }

  /**
   * Grants the execution of the action through the handler
   *
   * @param {string} handlerName - registered name of the handler
   * @param {string} actionName - registered action name
   * @param {...args} args - custom args passed to {@link Handler._grantingAction}
   */
  static grantAction(handlerName, actionName, ...args){
    assert(TypeCheck.isString(handlerName), &apos;handlerName needs to be defined as string&apos;);

    // making sure the action is registered, otherwise throws an exception
    Action.registeredAction(actionName);

    const normalizedHandlerName = handlerName.toLowerCase();
    const handlerMasks = this.registeredHandlerMasks(normalizedHandlerName);
    for (const handleMask of handlerMasks){
      const HandlerClass = this.registeredHandler(normalizedHandlerName, handleMask);
      HandlerClass._grantingAction.call(HandlerClass, normalizedHandlerName, actionName, ...args);
    }

    assert(handlerMasks.length, `Handler ${handlerName} is not registered`);
    if (!this._addedActions.has(normalizedHandlerName)){
      this._addedActions.set(normalizedHandlerName, new Set());
    }

    this._addedActions.get(normalizedHandlerName).add(actionName.toLowerCase());
  }

  /**
   * Returns a list granted actions for the input handler
   *
   * @param {string} handlerName - registered handler name
   * @return {Array&lt;string&gt;}
   */
  static grantedActionNames(handlerName){
    assert(TypeCheck.isString(handlerName), &apos;handlerName needs to be defined as string&apos;);

    const normalizedHandlerName = handlerName.toLowerCase();

    if (this._addedActions.has(normalizedHandlerName)){
      return [...this._addedActions.get(normalizedHandlerName).values()];
    }

    return [];
  }

  /**
   * Adds a listener to an exception raised during the {@link Handler.output} process.
   * It can happen either during the serialization process ({@link Writer.serialize})
   * or during the finalization of the session ({@link Session.finalize}).
   * This event passes as argument: error, handlerName and handlerMask.
   *
   * Currently this event is static to make easy to hook it in your application,
   * if none listener is registered to it then the error is thrown,
   * a stack trace is printed, and the Node.js process exits.
   *
   * ```
   * // registering a listener for the error
   * Mebo.Handler.onErrorDuringOutput((err, handlerName, handlerMask =&gt; {
   *    console.error(err.stack);
   * }));
   * ```
   *
   * @param {function} listener - listener function
   */
  static onErrorDuringOutput(listener){
    this._outputEventEmitter.on(&apos;error&apos;, listener);
  }

  /**
   * This method can be re-implemented by derived classes to hook when an {@link Action}
   * is granted for a handler ({@link Handler.grantAction})
   *
   * @param {string} handlerName - registered handler name
   * @param {string} actionName - registered action name
   * @param {...args} args - custom args passed during {@link Handler.grantAction}
   * @protected
   */
  static _grantingAction(handlerName, actionName, ...args){
  }

  /**
   * Creates an instance of a reader for the current handler
   *
   * @param {Action} action - action instance used by the reader to parse the values
   * @param {Object} options - plain object containing the options passed to the reader
   * @param {...additionalArgs} additionalArgs - additional args passed to the
   * constructor during factoring of the reader (should be used by derived classes)
   * @return {Reader}
   * @protected
   */
  _createReader(action, options, ...additionalArgs){
    const ReaderClass = Handler.registeredReader(
      this.meta(&apos;handler.name&apos;),
      this.meta(&apos;handler.mask&apos;),
    );

    const reader = new ReaderClass(action, ...additionalArgs);

    // passing options to the reader
    for (const option in options){
      reader.setOption(option, options[option]);
    }

    return reader;
  }

  /**
   * Creates an instance of a writer for the current handler
   *
   * @param {*} value - arbitrary value passed to the writer
   * @param {Object} options - plain object containing the options passed to the writer
   * @param {...additionalArgs} additionalArgs - additional args passed to the
   * constructor during factoring of the reader (should be used by derived classes)
   * @return {Writer}
   * @protected
   */
  _createWriter(value, options, ...additionalArgs){
    const WriterClass = Handler.registeredWriter(
      this.meta(&apos;handler.name&apos;),
      this.meta(&apos;handler.mask&apos;),
    );

    const writer = new WriterClass(value, ...additionalArgs);

    // passing options to the writer
    for (const option in options){
      writer.setOption(option, options[option]);
    }

    return writer;
  }

  /**
   * Loads the {@link Reader} information to the {@link Action} and {@link Session}. This
   * process is called during the execution ({@link Handler.runAction}).
   *
   * Changes done by this method to the action:
   * - Assigns the {@link Handler.session} to the action ({@link Action.session})
   * - Modifies the action input values based on the information collected by the reader
   *
   * Changes done by this method to the session:
   * - Modifies the {@link Session.autofill} based on the information collected by the reader
   * ({@link Reader.autofillValues})
   *
   * @param {Action} action - action that should be used
   * @param {Object} options - options passed to the reader
   * @private
   */
  async _load(action, options){

    assert(action instanceof Action, &apos;Invalid action&apos;);

    const readOptions = Utils.deepMerge(this.meta(&apos;readOptions&apos;, {}), options);
    const reader = this._createReader(action, readOptions);

    // collecting the reader values
    const inputValues = await reader.inputValues();
    const autofillValues = await reader.autofillValues();

    // setting inputs
    for (const inputName in inputValues){
      action.input(inputName).setValue(inputValues[inputName]);
    }

    // setting autofill
    const session = action.session();
    for (const autofillName in autofillValues){
      session.setAutofill(autofillName, autofillValues[autofillName]);
    }
  }

  /**
   * Auxiliary method used to get the registration of writers, readers and handlers.
   *
   * @param {Map} where - map used to find the registration
   * @param {string} handlerName - name of the registered handler type
   * @param {string} handlerMask - mask that supports a glob syntax used
   * to match a custom registered handler
   * @return {Handler|function}
   *
   * @private
   */
  static _registered(where, handlerName, handlerMask){
    assert(TypeCheck.isString(handlerName), &apos;handlerName needs to be defined as string&apos;);
    assert(TypeCheck.isString(handlerMask), &apos;mask needs to be defined as string&apos;);

    let result = null;
    const normalizedHandlerName = handlerName.toLowerCase();
    const normalizedHandlerMask = handlerMask.toLowerCase();

    for (const key of where.keys()){
      if (key[0] === normalizedHandlerName &amp;&amp; (key[1] === &apos;*&apos; || minimatch(normalizedHandlerMask, key[1]))){
        result = where.get(key);
        break;
      }
    }

    return result;
  }

  /**
  * Auxiliary method that returns the handler name defined as metadata inside
  * of the action, if not defined returns an empty string
  *
  * @param {Action} action - action that should be used
  * @return {string}
  * @private
  */
  _actionHandlerName(action){
    let result = &apos;&apos;;

    const registeredHandlerName = this.meta(&apos;handler.name&apos;);
    for (const handlerName in action.meta(&apos;handler&apos;, {})){

      // the searching for the handler name (case insensitive)
      if (handlerName.toLowerCase() === registeredHandlerName){
        result = handlerName;
        break;
      }
    }

    return result;
  }

  /**
   * Auxiliary method used for the registration of writers, readers and handlers
   *
   * @param {Map} where - map used to store the registration
   * @param {Handler|function} what - data that should be stored
   * @param {string} handlerName - name of the registered handler type
   * @param {string} handlerMask - mask that supports a glob syntax used
   * to match a custom registered handler
   *
   * @private
   */
  static _register(where, what, handlerName, handlerMask){
    assert(TypeCheck.isString(handlerName), &apos;Invalid handler registration name!&apos;);
    assert(TypeCheck.isString(handlerMask), &apos;handlerMask needs to be defined as string&apos;);
    assert(handlerName.length, &apos;handlerName cannot be empty&apos;);
    assert(handlerMask.length, &apos;handlerMask cannot be empty&apos;);

    const normalilzeHandlerName = handlerName.toLowerCase();
    const normalizedHandlerMask = handlerMask.toLowerCase();

    // validating handler name
    assert(normalilzeHandlerName.length, &apos;handler name cannot be empty&apos;);
    assert((/^([\w_\.\-])+$/gi).test(normalilzeHandlerName), `Invalid handler name: ${normalilzeHandlerName}`); // eslint-disable-line no-useless-escape

    // since when querying registrations the new ones precede to the old ones,
    // therefore the new ones are stored on the top of the pile, for this reason creating
    // a temporary reversed map that will be used to include the new one
    const currentData = new Map();
    for (const key of Array.from(where.keys()).reverse()){

      // if there is already an existing registration for it, skipping it
      if (key[0] === normalilzeHandlerName &amp;&amp; key[1] === normalizedHandlerMask){
        continue;
      }

      currentData.set(key, where.get(key));
    }

    // including the new registration
    currentData.set([normalilzeHandlerName, normalizedHandlerMask], what);

    // reversing back the final order
    where.clear();
    for (const key of Array.from(currentData.keys()).reverse()){
      where.set(key, currentData.get(key));
    }
  }

  /**
   * Emits the output error signal, it passes as argument: error, handler name
   * and handler mask.
   *
   * @param {Error} err - exception used as critical error
   */
  _emitOutputError(err){
    process.nextTick(() =&gt; {
      this.constructor._outputEventEmitter.emit(
        &apos;error&apos;,
        err,
        this.meta(&apos;handler.name&apos;),
        this.meta(&apos;handler.mask&apos;),
      );
    });
  }

  static _outputEventEmitter = new EventEmitter();

  static _registeredHandlers = new Map();

  static _registeredWriters = new Map();

  static _registeredReaders = new Map();

  static _addedActions = new Map();
}

module.exports = Handler;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
