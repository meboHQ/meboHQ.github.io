<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/Readers/WebRequest.js | Mebo</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
<link data-ice="userStyle" rel="stylesheet" href="user/css/0-style.css">
<link rel="icon" type="image/png" sizes="64x64" href="data/icon.png?v=1"><script async defer src="https://buttons.github.io/buttons.js"></script></head>
<body class="layout-container" data-ice="rootContainer">

<header><a href="./index.html"><img src="data/icon.png?v=1" id="meboSmallLogo" width="40" height="40" align="top"/></a>
  <a href="./">Home</a>
  <a href="./manual/overview/INTRODUCTION.html" data-ice="manualHeaderLink">Intro</a>
  
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/meboHQ/mebo" class="repo-url-github">Mebo&nbsp;GitHub</a>
  <div class="search-box">
  <span>
    <img src="data/docs/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Action.js~Action.html">Action</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Handler.js~Handler.html">Handler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Input.js~Input.html">Input</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/MeboError.js~MeboError.html">MeboError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Metadata.js~Metadata.html">Metadata</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Reader.js~Reader.html">Reader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Session.js~Session.html">Session</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Settings.js~Settings.html">Settings</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Tasks.js~Tasks.html">Tasks</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Writer.js~Writer.html">Writer</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">Handlers</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Handlers/Cli.js~Cli.html">Cli</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Handlers/Web.js~Web.html">Web</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">Inputs</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/Any.js~Any.html">Any</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/BaseText.js~BaseText.html">BaseText</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/Bool.js~Bool.html">Bool</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/Buf.js~Buf.html">Buf</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/Email.js~Email.html">Email</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/FilePath.js~FilePath.html">FilePath</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/Hash.js~Hash.html">Hash</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/Hex.js~Hex.html">Hex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/Ip.js~Ip.html">Ip</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/Numeric.js~Numeric.html">Numeric</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/Stream.js~Stream.html">Stream</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/Text.js~Text.html">Text</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/Timestamp.js~Timestamp.html">Timestamp</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/UUID.js~UUID.html">UUID</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/Url.js~Url.html">Url</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Inputs/Version.js~Version.html">Version</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">MeboErrors</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/MeboErrors/Conflict.js~Conflict.html">Conflict</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/MeboErrors/Help.js~Help.html">Help</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/MeboErrors/NoContent.js~NoContent.html">NoContent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/MeboErrors/NotFound.js~NotFound.html">NotFound</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/MeboErrors/ValidationFail.js~ValidationFail.html">ValidationFail</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">Readers</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Readers/CliArgs.js~CliArgs.html">CliArgs</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Readers/WebRequest.js~WebRequest.html">WebRequest</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">Utils</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Utils/ImmutableMap.js~ImmutableMap.html">ImmutableMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Utils/LruCache.js~LruCache.html">LruCache</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">Writers</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Writers/CliOutput.js~CliOutput.html">CliOutput</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Writers/WebResponse.js~WebResponse.html">WebResponse</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/Readers/WebRequest.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">const os = require(&apos;os&apos;);
const fs = require(&apos;fs&apos;);
const util = require(&apos;util&apos;);
const path = require(&apos;path&apos;);
const assert = require(&apos;assert&apos;);
const formidable = require(&apos;formidable&apos;);
const TypeCheck = require(&apos;js-typecheck&apos;);
const ejs = require(&apos;ejs&apos;);
const Settings = require(&apos;../Settings&apos;);
const Inputs = require(&apos;../Inputs&apos;);
const Handler = require(&apos;../Handler&apos;);
const Reader = require(&apos;../Reader&apos;);
const Utils = require(&apos;../Utils&apos;);
const MeboError = require(&apos;../MeboError&apos;);
const MeboErrors = require(&apos;../MeboErrors&apos;);

// promisifying
const mkdtemp = util.promisify(fs.mkdtemp);
const rename = util.promisify(fs.rename);
const stat = util.promisify(fs.stat);
const rmdir = util.promisify(fs.rmdir);
const unlink = util.promisify(fs.unlink);
const readFile = util.promisify(fs.readFile);

// symbols used for private members to avoid any potential clashing
// caused by re-implementations
const _temporaryFolders = Symbol(&apos;temporaryFolders&apos;);
const _temporaryFiles = Symbol(&apos;temporaryFiles&apos;);
const _request = Symbol(&apos;request&apos;);
const _checkedUploadDirectories = Symbol(&apos;checkedUploadDirectories&apos;);

/**
 * Web request reader.
 *
 * This reader is used by the {@link Web} handler to query values from a request.
 *
 * This reader supports all serializable inputs. It deals with file uploads
 * automatically; therefore any {@link FilePath} input becomes a potential
 * upload field. When that is the case the input gets assigned with the file path
 * about where the file has been uploaded to. By default it tries to keep the original
 * uploaded file name by replacing any illegal character with underscore, however you can
 * control this behavior via `uploadPreserveName` (if disabled each uploaded file
 * gets named with an unique name).
 *
 * This reader works by looking for the input names in the request, for instance:
 *
 * `http://.../?myInput=10&amp;myOtherInput=20`
 *
 * ```
 * class MyAction extends Mebo.Action {
 *   constructor(){
 *     super();
 *     this.createInput(&apos;myInput: numeric&apos;);
 *     this.createInput(&apos;myOtherInput: numeric&apos;);
 *   }
 * }
 * ```
 *
 * When a value is found for the input, it gets loaded via {@link Input.parseValue}
 * where each input implementation has its own way of parsing the serialized data,
 * to find out about how a value is serialized for an specific input type you could simply
 * set an arbitrary value to the input you are interested then query it back through
 * {@link Input.serializeValue}. Also, Mebo provides a reference datasheet
 * about the serialization forms for the inputs bundled with it, found at {@link Reader}.
 *
 * As supported for the cli handler (--help/-h) you can also query a basic help page
 * for any action through the web handler by including: `help` to the query string:
 * `http://.../?help`
 * By doing that it renders a page with the description of the action and helpful
 * information about the inputs. This setting is available through `handler/web/allowHelp`
 * (default true).
 *
 * You can define the description displayed in the help of each input by
 * setting the input&apos;s property `description`. Also, the description for the action
 * itself can be defined by setting the action&apos;s metadata `description`.
 *
 * **Route parameters:**
 * If an webfied action contains route parameters defined (`/users/:userId/books/:bookId`)
 * this reader is going to try to find them under the action input names.
 * Therefore when a route parameter matches to the name of an input then the value of
 * the parameter is loaded to the input.
 *
 * **Vector Inputs:**
 * Supported conventions for array parameters:
 *
 * - *Serialized vector value (JSON Style)*
 * ```
 * http://.../?vectorInput=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
 * ```
 *
 * - *Repeated param names*
 * ```
 * http://.../?vectorInput[]=a&amp;vectorInput[]=b&amp;vectorInput[]=c
 * ```
 * *or*
 * ```
 * http://.../?vectorInput=a&amp;vectorInput=b&amp;vectorInput=c
 * ```
 *
 * &lt;h2&gt;Options Summary&lt;/h2&gt;
 *
 * Option Name | Description
 * --- | ---
 * uploadDirectory | directory used for placing file uploads in, default value\
 * (`TMP_DIR/upload`) driven by:\
 * &lt;br&gt;`Settings.get(&apos;reader/webRequest/uploadDirectory&apos;)`
 * uploadPreserveName | enabled by default it tries to keep the original final name of \
 * uploads, any illegal character is replaced by underscore, otherwise if disabled \
 * it gives a random name to the upload, default value driven by: \
 * &lt;br&gt;`Settings.get(&apos;reader/webRequest/uploadPreserveName&apos;)`
 * uploadDefaultMaxFileSize | total maximum file size about all uploads in bytes, \
 * default value (`4 mb`) driven by: \
 * &lt;br&gt;`Settings.get(&apos;reader/webRequest/uploadDefaultMaxFileSize&apos;)`
 * maxFields | Limits the number of fields that the querystring parser will decode, \
 * default value (`1000`) driven by: \
 * &lt;br&gt;`Settings.get(&apos;reader/webRequest/maxFields&apos;)`
 * maxFieldsSize | Limits the amount of memory all fields together (except files) can\
 * allocate in bytes, default value (`2 mb`) driven by:\
 * &lt;br&gt;`Settings.get(&apos;reader/webRequest/maxFieldsSize&apos;)` [`2 mb`]
 *
 * &lt;br/&gt;Example about defining a custom `uploadDefaultMaxFileSize` option from inside of an
 * action through the metadata support:
 *
 * ```
 * class MyAction extends Mebo.Action{
 *    constructor(){
 *      super();
 *
 *      // &apos;uploadDefaultMaxFileSize&apos; option
 *      this.setMeta(&apos;handler.web.readOptions&apos;, {
 *        uploadDefaultMaxFileSize: 10 * 1024 * 1024,
 *      });
 *    }
 * }
 * ```
 */
class WebRequest extends Reader{

  /**
   * Creates a web request reader
   *
   * @param {Action} action - action that should be used by the reader
   * @param {Object} req - request object created by express-js
   */
  constructor(action, req){
    super(action);

    this._setRequest(req);

    // default options
    this.setOption(&apos;uploadDirectory&apos;, Settings.get(&apos;reader/webRequest/uploadDirectory&apos;));
    this.setOption(&apos;uploadPreserveName&apos;, Settings.get(&apos;reader/webRequest/uploadPreserveName&apos;));
    this.setOption(&apos;uploadDefaultMaxFileSize&apos;, Settings.get(&apos;reader/webRequest/uploadDefaultMaxFileSize&apos;));
    this.setOption(&apos;maxFields&apos;, Settings.get(&apos;reader/webRequest/maxFields&apos;));
    this.setOption(&apos;maxFieldsSize&apos;, Settings.get(&apos;reader/webRequest/maxFieldsSize&apos;));

    this[_temporaryFolders] = [];
    this[_temporaryFiles] = [];
  }

  /**
   * Returns the request object created by express
   *
   * @return {Object}
   * @see http://expressjs.com/en/api.html#req
   */
  request(){
    return this[_request];
  }

  /**
   * Implements the web request reader
   *
   * @param {Array&lt;Input&gt;} inputList - Valid list of inputs that should be used for
   * the parsing
   * @return {Promise&lt;Object&gt;}
   * @protected
   */
  async _perform(inputList){
    const result = {};
    const request = this.request();
    const test = new Map();

    // when help is requested
    if (Settings.get(&apos;handler/web/allowHelp&apos;) &amp;&amp; &apos;help&apos; in request.query){
      throw new MeboErrors.Help(await this._renderHelp(inputList));
    }

    // handling body fields
    let bodyFields = null;
    if ([&apos;POST&apos;, &apos;PUT&apos;, &apos;PATCH&apos;].includes(request.method)){
      bodyFields = await this._bodyFields(inputList);
    }

    // setting the action inputs based on the request parameters
    for (const input of inputList){
      const inputName = input.name();

      // value set by the request
      let requestInputValue;
      const restrictWebAccess = input.hasProperty(&apos;restrictWebAccess&apos;) ? input.property(&apos;restrictWebAccess&apos;) : false;

      // mapping param to input names
      if (!restrictWebAccess &amp;&amp; inputName in request.params){
        requestInputValue = request.params[inputName];
      }
      // body fields
      else if (bodyFields !== null){
        if (restrictWebAccess &amp;&amp; inputName in bodyFields.files){
          requestInputValue = bodyFields.files[inputName];
        }
        else if (!restrictWebAccess){

          if (inputName in bodyFields.files){
            requestInputValue = bodyFields.files[inputName];
          }
          else if (inputName in bodyFields.fields){
            requestInputValue = bodyFields.fields[inputName];
          }
        }
      }

      // GET, DELETE ...
      else if (!restrictWebAccess &amp;&amp; inputName in request.query){
        requestInputValue = request.query[inputName];
      }

      if (requestInputValue !== undefined){

        // reading buffer data
        if (input instanceof Inputs.Buf){
          // creating a promise that is later executed to retrieve the buffer
          // from the uploaded file
          test.set(inputName, readFile(requestInputValue));

          // marking for removal temporary file used by the buffer input
          this[_temporaryFiles].push(requestInputValue);
        }

        result[inputName] = requestInputValue;
      }
    }

    // retrieving the value from the buffer inputs
    const bufferPromisesResult = await Promise.all(test.values());
    let currentIndex = 0;
    for (const bufferInputName of test.keys()){
      result[bufferInputName] = bufferPromisesResult[currentIndex];
      currentIndex++;
    }

    return result;
  }

  /**
   * Computes the output displayed as help
   *
   * @param {Array&lt;Input&gt;} inputList - Valid list of inputs
   * @return {Promise&lt;string&gt;}
   * @protected
   */
  async _renderHelp(inputList){

    const inputData = [];

    /* eslint-disable no-await-in-loop */
    for (const input of inputList){
      // computing description
      let inputDescription = await input.property(&apos;description&apos;);
      if (TypeCheck.isNone(inputDescription)){
        inputDescription = &apos;&apos;;
      }

      // querying any type hint defined for the input
      let webTypeHint = &apos;&apos;;
      if (input.hasProperty(&apos;webTypeHint&apos;)){
        webTypeHint = input.property(&apos;webTypeHint&apos;);
      }

      // input data passed to the help
      inputData.push({
        name: input.name(),
        type: input.property(&apos;type&apos;),
        required: input.isRequired() &amp;&amp; input.isEmpty(),
        vector: input.isVector(),
        description: inputDescription,
        typeHint: webTypeHint,
      });
    }

    const data = {
      method: this.request().method,
      routePath: this.request().route.path,
      description: this.action().meta(&apos;description&apos;, &apos;&apos;),
      inputs: inputData,
    };

    return ejs.renderFile(
      Settings.get(&apos;reader/webRequest/helpTemplate&apos;),
      data,
    );
  }

  /**
   * Sets the request object created by express
   *
   * @param {Object} value - req object
   * @see http://expressjs.com/en/api.html#req
   * @private
   */
  _setRequest(value){
    assert(TypeCheck.isObject(value) &amp;&amp; value.method, &apos;Invalid request object&apos;);

    this[_request] = value;
  }

  /**
   * Returns an object containing the processed body fields parsed, this object separates
   * the fields from the files
   *
   * @param {Array&lt;Input&gt;} inputList - Valid list of inputs that should be used for
   * the parsing
   * @return {Promise&lt;Object&gt;}
   * @private
   */
  async _bodyFields(inputList){

    // making sure the upload directory exists
    const uploadDirectory = this.option(&apos;uploadDirectory&apos;);
    if (uploadDirectory &amp;&amp; !WebRequest[_checkedUploadDirectories].includes(uploadDirectory)){

      // in case the stat fails it will try to recreate the folders
      let needsToCreate = false;
      try{
        await stat(uploadDirectory);
      }
      // otherwise tries to create it
      catch(err){

        // file not found
        if (err.code === &apos;ENOENT&apos;){
          needsToCreate = true;
        }
        else{
          /* istanbul ignore next */
          throw err;
        }
      }

      if (needsToCreate){
        await Utils.mkdirs(uploadDirectory);
      }

      WebRequest[_checkedUploadDirectories].push(uploadDirectory);
    }

    // parsing the body fields
    const bodyFields = await this._parseForm(inputList);

    // normalizing multiple values for the fields
    this._normalizeFieldMultipleValues(bodyFields);

    // handling the uploaded files
    await this._handleUploadedFiles(bodyFields);

    return bodyFields;
  }

  /**
   * Normalizing multiple values for the fields by adding the values to an array
   * followed by the name of the field (field=[value1, value2...]) rather than
   * having an individual field entry for each of the indexes of the array
   * (field[0]=value1, field[1]=value2...)
   *
   * @param {Object} bodyFields - parsed body object
   * @private
   */
  _normalizeFieldMultipleValues(bodyFields){

    const multipleValueFields = {};

    for (const inputName in bodyFields.fields){

      // checking if there is any array field if so extracting their name and value
      if (inputName.endsWith(&apos;]&apos;)){
        const inputParts = inputName.split(&apos;[&apos;);
        if (inputParts.length === 2){
          if (!(inputParts[0] in multipleValueFields)){
            multipleValueFields[inputParts[0]] = [];
          }

          multipleValueFields[inputParts[0]].push(bodyFields.fields[inputName]);
        }
      }
    }

    // merging the normalized multiple values to the original fields
    Object.assign(bodyFields.fields, multipleValueFields);
  }

  /**
   * Handles the uploaded files (changes bodyFields in-place)
   *
   * @param {Object} bodyFields - parsed body object
   * @private
   */
  async _handleUploadedFiles(bodyFields){
    const keepOrignalNamePromises = new Map();

    const preserveFileName = this.option(&apos;uploadPreserveName&apos;);
    for (const inputName in bodyFields.files){
      // multiple files
      if (TypeCheck.isList(bodyFields.files[inputName])){

        for (const index in bodyFields.files[inputName]){
          if (preserveFileName){
            keepOrignalNamePromises.set([inputName, index], this._keepOriginalUploadName(bodyFields.files[inputName][index]));
          }
          else{
            bodyFields.files[inputName][index] = bodyFields.files[inputName][index].path;
          }
        }
      }

      // single file
      else{
        if (preserveFileName){
          keepOrignalNamePromises.set([inputName], this._keepOriginalUploadName(bodyFields.files[inputName]));
        }
        else{
          bodyFields.files[inputName] = bodyFields.files[inputName].path;
        }
      }
    }

    // &apos;keep original name&apos; is done in parallel for all files at once
    if (keepOrignalNamePromises.size){
      const originalNameKeys = Array.from(keepOrignalNamePromises.keys());
      const originalNameValues = await Promise.all(keepOrignalNamePromises.values());

      for (let i=0, len=keepOrignalNamePromises.size; i &lt; len; ++i){
        // single
        if (originalNameKeys[i].length === 1){
          bodyFields.files[originalNameKeys[i][0]] = originalNameValues[i];
        }
        // multi
        else{
          bodyFields.files[originalNameKeys[i][0]][originalNameKeys[i][1]] = originalNameValues[i];
        }
      }
    }

    // adding a wrapup to cleanup temporary files used for the uploads
    if (this[_temporaryFolders].length){
      this.action().session().wrapup().addWrappedPromise(
        this._cleanupTemporaryFiles.bind(this),
        {
          priority: 100,
        },
      );
    }

    // adding a wrapup to cleanup temporary folders used for the uploads
    if (this[_temporaryFolders].length){
      this.action().session().wrapup().addWrappedPromise(
        this._cleanupTemporaryFolders.bind(this),
        {
          priority: 1000,
        },
      );
    }
  }

  /**
   * Auxiliary method used to promisify formidable&apos;s form.parse call
   *
   * @param {Array&lt;Input&gt;} inputList - Valid list of inputs that should be used for
   * the parsing
   * @return {Promise&lt;Object&gt;}
   * @private
   */
  _parseForm(inputList){
    return new Promise((resolve, reject) =&gt; {

      const form = new formidable.IncomingForm();

      // formidable settings
      form.uploadDir = this.option(&apos;uploadDirectory&apos;);

      // in case the max size has been cranked-up by the inputs
      // to a value that is greater than the option &apos;uploadDefaultMaxFileSize&apos;
      // we use that value instead
      let maxFileSize = this.option(&apos;uploadDefaultMaxFileSize&apos;);
      for (const input of inputList){
        // file path input
        if (input instanceof Inputs.FilePath
        &amp;&amp; input.hasProperty(&apos;maxFileSize&apos;)
        &amp;&amp; input.property(&apos;maxFileSize&apos;) &gt; maxFileSize){
          maxFileSize = input.property(&apos;maxFileSize&apos;);
        }
        // buffer input
        else if (input instanceof Inputs.Buf
        &amp;&amp; input.hasProperty(&apos;maxBufferSize&apos;)
        &amp;&amp; input.property(&apos;maxBufferSize&apos;) &gt; maxFileSize){
          maxFileSize = input.property(&apos;maxBufferSize&apos;);
        }
      }

      form.maxFileSize = maxFileSize;
      form.keepExtensions = true;
      form.multiples = true;
      form.encoding = &apos;utf-8&apos;;
      form.maxFields = this.option(&apos;maxFields&apos;);
      form.maxFieldsSize = this.option(&apos;maxFieldsSize&apos;);

      form.parse(this.request(), (err, formFields, formFiles) =&gt; {

        // in case of any error
        /* istanbul ignore next */
        if (err){
          err.status = err.status || 500;

          // converting some of the formidable exceptions
          // to mebo mebo exceptions.
          // formidable does not provide a custom exception type
          // for the exceptions. Therefore, we need to parse
          // the message to know the context.
          if (!(err instanceof MeboError) &amp;&amp; err.message.startsWith(&apos;maxFileSize exceeded,&apos;)){
            reject(new MeboErrors.ValidationFail(err.message));
            return;
          }

          reject(err);
          return;
        }

        const result = {};
        result.files = formFiles;
        result.fields = formFields;

        resolve(result);
      });
    });
  }

  /**
   * Renames the uploaded file names which receive random unique names to the original uploaded file name,
   * this is done by creating an intermediated unique name folder for each of the upload files then
   * renaming them back to the original name.
   * This method is called when `uploadPreserveName` returns true
   *
   * @param {string} uploadFile - input file name
   * @return {string} output file name
   * @private
   */
  async _keepOriginalUploadName(uploadFile){
    const uploadFolder = await mkdtemp(path.join(this.option(&apos;uploadDirectory&apos;), &apos;file-&apos;));
    const finalName = path.join(uploadFolder, uploadFile.name.replace(/[^a-zA-Z0-9 _.-]/g, &apos;_&apos;));
    await rename(uploadFile.path, finalName);

    // temporary folders removed at the end of the request
    this[_temporaryFolders].push(uploadFolder);

    return finalName;
  }

  /**
   * Promise based method that removes the temporary files created during upload
   * (used by buffer inputs)
   *
   * @return {Promise}
   * @private
   */
  _cleanupTemporaryFiles(){
    const result = Promise.all(
      this[_temporaryFiles].map((x) =&gt; unlink(x)),
    );

    // theoretically this method can be called multiple times by handler.run
    // for the same request
    this[_temporaryFiles] = [];

    return result;
  }

  /**
   * Promise based method that removes the temporary folders that are created
   * when `uploadPreserveName` is enabled
   *
   * @return {Promise}
   * @private
   */
  _cleanupTemporaryFolders(){
    const result = Promise.all(
      this[_temporaryFolders].map((x) =&gt; this._deleteTemporaryFolder(x)),
    );

    // theoretically this method can be called multiple times by handler.run
    // for the same request
    this[_temporaryFolders] = [];

    return result;
  }

  /**
   * Deletes a temporary folder
   *
   * @param {string} folder - folder to be deleted
   * @return {Promise}
   * @private
   */
  _deleteTemporaryFolder(folder){
    return rmdir(folder).then((result) =&gt; {
      // runaway promise
      return null;
    }).catch(/* istanbul ignore next */ (err) =&gt; {
      if (!([&apos;ENOTEMPTY&apos;, &apos;ENOENT&apos;].includes(err.code))){
        throw err;
      }
    });
  }
}

WebRequest[_checkedUploadDirectories] = [];

// default settings
Settings.set(&apos;reader/webRequest/uploadDirectory&apos;, path.join(os.tmpdir(), &apos;upload&apos;));
Settings.set(&apos;reader/webRequest/uploadDefaultMaxFileSize&apos;, 4 * 1024 * 1024);
Settings.set(&apos;reader/webRequest/uploadPreserveName&apos;, true);
Settings.set(&apos;reader/webRequest/maxFields&apos;, 1000);
Settings.set(&apos;reader/webRequest/maxFieldsSize&apos;, 4 * 1024 * 1024);
Settings.set(
  &apos;reader/webRequest/helpTemplate&apos;,
  path.join(path.dirname(path.dirname(path.dirname(__filename))), &apos;data&apos;, &apos;handlers&apos;, &apos;web&apos;, &apos;help.ejs&apos;),
);

// registering reader
Handler.registerReader(WebRequest, &apos;web&apos;);

module.exports = WebRequest;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
